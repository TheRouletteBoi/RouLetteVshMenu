<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Advanced lookup and insertion functions for associative containers</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../intrusive.html" title="Chapter 10. Boost.Intrusive">
<link rel="prev" href="sg_set_multiset.html" title="Intrusive scapegoat tree based associative containers: sg_set, sg_multiset and sgtree">
<link rel="next" href="erasing_and_disposing.html" title="Erasing and disposing values from Boost.Intrusive containers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sg_set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="intrusive.advanced_lookups_insertions"></a><a class="link" href="advanced_lookups_insertions.html" title="Advanced lookup and insertion functions for associative containers"> Advanced lookup
    and insertion functions for associative containers</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups">
      Advanced lookups</a></span></dt>
<dt><span class="section"><a href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions">
      Advanced insertions</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_lookups"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_lookups" title="Advanced lookups">
      Advanced lookups</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Intrusive</strong></span> associative containers offer
        the same interface as STL associative containers. However, STL and TR1 ordered
        and unordered simple associative containers (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code>,
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">multiset</span></code>, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_multiset</span></code>) have some inefficiencies
        caused by the interface: the user can only operate with <code class="computeroutput"><span class="identifier">value_type</span></code>
        objects. When using these containers we must use <code class="computeroutput"><span class="identifier">iterator</span>
        <span class="identifier">find</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">value_type</span>
        <span class="special">&amp;</span><span class="identifier">value</span><span class="special">)</span></code> to find a value. The same happens in other
        functions like <code class="computeroutput"><span class="identifier">equal_range</span></code>,
        <code class="computeroutput"><span class="identifier">lower_bound</span></code>, <code class="computeroutput"><span class="identifier">upper_bound</span></code>, etc.
      </p>
<p>
        However, sometimes the object to be searched is quite expensive to construct:
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">intrusive</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cstring</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">intrusive</span><span class="special">;</span>

<span class="comment">// Hash function for strings
</span><span class="keyword">struct</span> <span class="identifier">StrHasher</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">seed</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
      <span class="keyword">for</span><span class="special">(;</span> <span class="special">*</span><span class="identifier">str</span><span class="special">;</span> <span class="special">++</span><span class="identifier">str</span><span class="special">)</span>   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hash_combine</span><span class="special">(</span><span class="identifier">seed</span><span class="special">,</span> <span class="special">*</span><span class="identifier">str</span><span class="special">);</span>
      <span class="keyword">return</span> <span class="identifier">seed</span><span class="special">;</span>
   <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">Expensive</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">set_base_hook</span><span class="special">&lt;&gt;,</span> <span class="keyword">public</span> <span class="identifier">unordered_set_base_hook</span><span class="special">&lt;&gt;</span>
<span class="special">{</span>
   <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">key_</span><span class="special">;</span>
   <span class="comment">// Other members...
</span>  
   <span class="keyword">public</span><span class="special">:</span>
   <span class="identifier">Expensive</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">:</span>  <span class="identifier">key_</span><span class="special">(</span><span class="identifier">key</span><span class="special">)</span>
      <span class="special">{}</span>  <span class="comment">//other expensive initializations...
</span>
   <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span> <span class="identifier">get_key</span><span class="special">()</span> <span class="keyword">const</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">key_</span><span class="special">;</span>   <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">&lt;</span>  <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">&lt;</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> <span class="special">==</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">a</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">b</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">a</span><span class="special">.</span><span class="identifier">key_</span> <span class="special">==</span> <span class="identifier">b</span><span class="special">.</span><span class="identifier">key_</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">friend</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">hash_value</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">object</span><span class="special">)</span>
      <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">StrHasher</span><span class="special">()(</span><span class="identifier">object</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">());</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// A set and unordered_set that store Expensive objects
</span><span class="keyword">typedef</span> <span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span>           <span class="identifier">Set</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">Expensive</span><span class="special">&gt;</span> <span class="identifier">UnorderedSet</span><span class="special">;</span>

<span class="comment">// Search functions
</span><span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>     <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">Expensive</span> <span class="special">(</span><span class="identifier">key</span><span class="special">));</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">Expensive</span></code> is an expensive
        object to construct. If "key" c-string is quite long <code class="computeroutput"><span class="identifier">Expensive</span></code> has to construct a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
        using heap memory. Like <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        many times the only member taking part in ordering issues is just a small
        part of the class. For example, with <code class="computeroutput"><span class="identifier">Expensive</span></code>,
        only the internal <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> is needed to compare the object.
      </p>
<p>
        In both containers, if we call <code class="computeroutput"><span class="identifier">get_from_set</span><span class="special">/</span><span class="identifier">get_from_unordered_set</span></code>
        in a loop, we might get a performance penalty, because we are forced to create
        a whole <code class="computeroutput"><span class="identifier">Expensive</span></code> object
        to be able to find an equivalent one.
      </p>
<p>
        Sometimes this interface limitation is severe, because we <span class="bold"><strong>might
        not have enough information to construct the object</strong></span> but we might
        <span class="bold"><strong>have enough information to find the object</strong></span>.
        In this case, a name is enough to search <code class="computeroutput"><span class="identifier">Expensive</span></code>
        in the container but constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        might require more information that the user might not have.
      </p>
<p>
        To solve this, <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code> offer alternative functions,
        which take any type comparable with the value and a functor that should be
        compatible with the ordering function of the associative container. <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>/<code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        offers functions that take any key type and compatible hash and equality
        functions. Now, let's see the optimized search function:
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="comment">// These compare Expensive and a c-string
</span><span class="keyword">struct</span> <span class="identifier">StrExpComp</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">&lt;</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">StrExpEqual</span>
<span class="special">{</span>
   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">str</span><span class="special">,</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">())</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>

   <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="identifier">Expensive</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">str</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>  <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">strcmp</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">get_key</span><span class="special">().</span><span class="identifier">c_str</span><span class="special">(),</span> <span class="identifier">str</span><span class="special">)</span> <span class="special">==</span> <span class="number">0</span><span class="special">;</span>  <span class="special">}</span>
<span class="special">};</span>

<span class="comment">// Optimized search functions
</span><span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>

<span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">get_from_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">());</span>
   <span class="keyword">if</span><span class="special">(</span> <span class="identifier">it</span> <span class="special">==</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">)</span>  <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="special">&amp;*</span><span class="identifier">it</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
<p>
        This new arbitrary key overload is also available for other functions taking
        values as arguments:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          equal_range
        </li>
<li>
          lower_bound
        </li>
<li>
          upper_bound
        </li>
<li>
          count
        </li>
<li>
          find
        </li>
<li>
          erase
        </li>
</ul></div>
<p>
        Check <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
        references to know more about those functions.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="intrusive.advanced_lookups_insertions.advanced_insertions"></a><a class="link" href="advanced_lookups_insertions.html#intrusive.advanced_lookups_insertions.advanced_insertions" title="Advanced insertions">
      Advanced insertions</a>
</h3></div></div></div>
<p>
        A similar issue happens with insertions in simple ordered and unordered associative
        containers with unique keys (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> and
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tr1</span><span class="special">::</span><span class="identifier">unordered_set</span></code>).
        In these containers, if a value is already present, the value to be inserted
        is discarded. With expensive values, if the value is already present, we
        can suffer efficiency problems.
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
        have insertion functions to check efficiently, without constructing the value,
        if a value is present or not and if it's not present, a function to insert
        it immediately without any further lookup. For example, using the same <code class="computeroutput"><span class="identifier">Expensive</span></code> class, this function can be inefficient:
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="comment">// Insertion functions
</span><span class="keyword">bool</span> <span class="identifier">insert_to_set</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Expensive</span> <span class="special">*</span><span class="identifier">pobject</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">);</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(*</span><span class="identifier">pobject</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(!</span><span class="identifier">success</span><span class="special">)</span>   <span class="keyword">delete</span> <span class="identifier">pobject</span><span class="special">;</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
<p>
        If the object is already present, we are constructing an <code class="computeroutput"><span class="identifier">Expensive</span></code>
        that will be discarded, and this is a waste of resources. Instead of that,
        let's use <code class="computeroutput"><span class="identifier">insert_check</span></code> and
        <code class="computeroutput"><span class="identifier">insert_commit</span></code> functions:
      </p>
<p>
        </p>
<p>
          
</p>
<pre class="programlisting"><span class="comment">// Optimized insertion functions
</span><span class="keyword">bool</span> <span class="identifier">insert_to_set_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">Set</span> <span class="special">&amp;</span><span class="identifier">set_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">Set</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_check</span><span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrExpComp</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">set_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">bool</span> <span class="identifier">insert_to_uset_optimized</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">key</span><span class="special">,</span> <span class="identifier">UnorderedSet</span> <span class="special">&amp;</span><span class="identifier">uset_object</span><span class="special">)</span>
<span class="special">{</span>
   <span class="identifier">UnorderedSet</span><span class="special">::</span><span class="identifier">insert_commit_data</span> <span class="identifier">insert_data</span><span class="special">;</span>
   <span class="keyword">bool</span> <span class="identifier">success</span> <span class="special">=</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_check</span>
      <span class="special">(</span><span class="identifier">key</span><span class="special">,</span> <span class="identifier">StrHasher</span><span class="special">(),</span> <span class="identifier">StrExpEqual</span><span class="special">(),</span> <span class="identifier">insert_data</span><span class="special">).</span><span class="identifier">second</span><span class="special">;</span>
   <span class="keyword">if</span><span class="special">(</span><span class="identifier">success</span><span class="special">)</span> <span class="identifier">uset_object</span><span class="special">.</span><span class="identifier">insert_commit</span><span class="special">(*</span><span class="keyword">new</span> <span class="identifier">Expensive</span><span class="special">(</span><span class="identifier">key</span><span class="special">),</span> <span class="identifier">insert_data</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="identifier">success</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
      </p>
<p>
        <code class="computeroutput"><span class="identifier">insert_check</span></code> is similar to
        a normal <code class="computeroutput"><span class="identifier">insert</span></code> but:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="computeroutput"><span class="identifier">insert_check</span></code> can be used
          with arbitrary keys
        </li>
<li>
          if the insertion is possible (there is no equivalent value) <code class="computeroutput"><span class="identifier">insert_check</span></code> collects all the needed
          information in an <code class="computeroutput"><span class="identifier">insert_commit_data</span></code>
          structure, so that <code class="computeroutput"><span class="identifier">insert_commit</span></code>:
          <div class="itemizedlist"><ul type="circle">
<li>
<span class="bold"><strong>does not execute</strong></span> further comparisons
            </li>
<li>
              can be executed with <span class="bold"><strong>constant-time complexity</strong></span>
</li>
<li>
              has <span class="bold"><strong>no-throw guarantee</strong></span>.
            </li>
</ul></div>
</li>
</ul></div>
<p>
        These functions must be used with care, since no other insertion or erasure
        must be executed between an <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and an <code class="computeroutput"><span class="identifier">insert_commit</span></code> pair.
        Otherwise, the behaviour is undefined. <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code> will come
        in handy for developers programming efficient non-intrusive associative containers.
        See <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code> and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code> reference
        for more information about <code class="computeroutput"><span class="identifier">insert_check</span></code>
        and <code class="computeroutput"><span class="identifier">insert_commit</span></code>.
      </p>
<p>
        With multiple ordered and unordered associative containers (<code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>)
        there's no need for these advanced insertion functions, since insertions
        are always succesful.
      </p>
</div>
<p>
      For more information about advanced lookup and insertion functions see <code class="computeroutput"><a class="link" href="../boost/intrusive/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/intrusive/multiset.html" title="Class template multiset">multiset</a></code>,
      <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_set.html" title="Class template unordered_set">unordered_set</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/intrusive/unordered_multiset.html" title="Class template unordered_multiset">unordered_multiset</a></code>
      references.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 Olaf Krzikalla, 2006-2007 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sg_set_multiset.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../intrusive.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="erasing_and_disposing.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Synchronization</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../thread.html" title="Chapter 18. Thread">
<link rel="prev" href="thread_management.html" title="Thread Management">
<link rel="next" href="thread_local_storage.html" title="Thread Local Storage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="thread_management.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="thread.synchronization"></a><a class="link" href="synchronization.html" title="Synchronization"> Synchronization</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts"> Mutex Concepts</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks"> Lock Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions"> Lock functions</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types"> Mutex Types</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref"> Condition Variables</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once"> One-time Initialization</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers"> Barriers</a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_concepts"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts" title="Mutex Concepts"> Mutex Concepts</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable"> <code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable">
        <code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable">
        <code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept</a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable">
        <code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept</a></span></dt>
</dl></div>
<p>
        A mutex object facilitates protection against data races and allows thread-safe
        synchronization of data between threads. A thread obtains ownership of a
        mutex object by calling one of the lock functions and relinquishes ownership
        by calling the corresponding unlock function. Mutexes may be either recursive
        or non-recursive, and may grant simultaneous ownership to one or many threads.
        <span class="bold"><strong>Boost.Thread</strong></span> supplies recursive and non-recursive
        mutexes with exclusive ownership semantics, along with a shared ownership
        (multiple-reader / single-writer) mutex.
      </p>
<p>
        <span class="bold"><strong>Boost.Thread</strong></span> supports four basic concepts
        for lockable objects: <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code></a> and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code></a>. Each mutex type
        implements one or more of these concepts, as do the various lock types.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"> <code class="computeroutput"><span class="identifier">Lockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> models exclusive
          ownership. A type that implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> shall provide
          the following member functions:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span></code></a></li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                The current thread blocks until ownership can be obtained for the
                current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Attempt to obtain ownership for the current thread without blocking.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if ownership was
                obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                the current thread owns the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.lockable.unlock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Releases ownership by the current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread no longer owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept">
        <code class="computeroutput"><span class="identifier">TimedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">DurationType</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">DurationType</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> refines
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to add support
          for timeouts when trying to acquire the lock.
        </p>
<p>
          A type that implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> shall meet
          the requirements of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>. In addition,
          the following member functions must be provided:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
            <span class="keyword">const</span><span class="special">&amp;</span>
            <span class="identifier">abs_time</span><span class="special">);</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="template&lt;typename DurationType&gt; bool timed_lock(DurationType const&amp; rel_time)"><code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">DurationType</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">DurationType</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span></code></a></li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Attempt to obtain ownership for the current thread. Blocks until
                ownership can be obtained, or the specified time is reached. If the
                specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if ownership was
                obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                the current thread owns <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="template&lt;typename DurationType&gt; bool timed_lock(DurationType const&amp; rel_time)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">DurationType</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">DurationType</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                As-if <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()+</span><span class="identifier">rel_time</span><span class="special">)</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept">
        <code class="computeroutput"><span class="identifier">SharedLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>shared ownership</em></span> as well as <span class="emphasis"><em>exclusive
          ownership</em></span>. This is the standard multiple-reader / single-write
          model: at most one thread can have exclusive ownership, and if any thread
          does have exclusive ownership, no other threads can have shared or exclusive
          ownership. Alternatively, many threads may have shared ownership.
        </p>
<p>
          For a type to implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>, as well
          as meeting the requirements of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a>, it must
          also provide the following member functions:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="void unlock_shared()"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">unlock_shared</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
            <span class="keyword">const</span><span class="special">&amp;</span>
            <span class="identifier">abs_time</span><span class="special">);</span></code></a></li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="void unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                The current thread blocks until shared ownership can be obtained
                for the current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Attempt to obtain shared ownership for the current thread without
                blocking.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                was obtained for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                the current thread has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Attempt to obtain shared ownership for the current thread. Blocks
                until shared ownership can be obtained, or the specified time is
                reached. If the specified time has already passed, behaves as <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if shared ownership
                was acquired for the current thread, <code class="computeroutput"><span class="keyword">false</span></code>
                otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                If the call returns <code class="computeroutput"><span class="keyword">true</span></code>,
                the current thread has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.shared_lockable.unlock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="void unlock_shared()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Releases shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread no longer has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept">
        <code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> Concept</a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<p>
          The <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> is a refinement
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a> that allows
          for <span class="emphasis"><em>upgradable ownership</em></span> as well as <span class="emphasis"><em>shared
          ownership</em></span> and <span class="emphasis"><em>exclusive ownership</em></span>. This
          is an extension to the multiple-reader / single-write model provided by
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>: a single
          thread may have <span class="emphasis"><em>upgradable ownership</em></span> at the same time
          as others have <span class="emphasis"><em>shared ownership</em></span>. The thread with
          <span class="emphasis"><em>upgradable ownership</em></span> may at any time attempt to upgrade
          that ownership to <span class="emphasis"><em>exclusive ownership</em></span>. If no other
          threads have shared ownership, the upgrade is completed immediately, and
          the thread now has <span class="emphasis"><em>exclusive ownership</em></span>, which must
          be relinquished by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>,
          just as if it had been acquired by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>.
        </p>
<p>
          If a thread with <span class="emphasis"><em>upgradable ownership</em></span> tries to upgrade
          whilst other threads have <span class="emphasis"><em>shared ownership</em></span>, the attempt
          will fail and the thread will block until <span class="emphasis"><em>exclusive ownership</em></span>
          can be acquired.
        </p>
<p>
          Ownership can also be <span class="emphasis"><em>downgraded</em></span> as well as <span class="emphasis"><em>upgraded</em></span>:
          exclusive ownership of an implementation of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a> can be
          downgraded to upgradable ownership or shared ownership, and upgradable
          ownership can be downgraded to plain shared ownership.
        </p>
<p>
          For a type to implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a>, as well
          as meeting the requirements of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable" title="SharedLockable Concept"><code class="computeroutput"><span class="identifier">SharedLockable</span></code> concept</a>, it must
          also provide the following member functions:
        </p>
<div class="itemizedlist"><ul type="disc">
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="void lock_upgrade()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="void unlock_upgrade()"><code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="void unlock_upgrade_and_lock()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="void unlock_and_lock_upgrade()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span></code></a></li>
<li><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="void unlock_upgrade_and_lock_shared()"><code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span></code></a></li>
</ul></div>
<p>
          Lock ownership acquired through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="void lock_upgrade()"><code class="computeroutput"><span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
          must be released through a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="void unlock_upgrade()"><code class="computeroutput"><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
          If the ownership type is changed through a call to one of the <code class="computeroutput"><span class="identifier">unlock_xxx_and_lock_yyy</span><span class="special">()</span></code>
          functions, ownership must be released through a call to the unlock function
          corresponding to the new level of ownership.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.lock_upgrade" title="void lock_upgrade()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                The current thread blocks until upgrade ownership can be obtained
                for the current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="void unlock_upgrade()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Releases upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current thread.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread no longer has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock" title="void unlock_upgrade_and_lock()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically releases upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current thread and acquires
                exclusive ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>. If any other threads have shared
                ownership, blocks until exclusive ownership can be acquired.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread has exclusive ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade_and_lock_shared" title="void unlock_upgrade_and_lock_shared()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically releases upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current thread and acquires
                shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> without blocking.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread has shared ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_upgrade" title="void unlock_and_lock_upgrade()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread has exclusive ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically releases exclusive ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> by the current thread and acquires
                upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> without blocking.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                The current thread has upgrade ownership of <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing
              </p></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.locks"></a><a class="link" href="synchronization.html#thread.synchronization.locks" title="Lock Types"> Lock Types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard"> Class template
        <code class="computeroutput"><span class="identifier">lock_guard</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock"> Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock"> Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_lock"> Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock">
        Class template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.scoped_try_lock"> Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code></a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.lock_guard"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"> Class template
        <code class="computeroutput"><span class="identifier">lock_guard</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.constructor">
          <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt">
          <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.lock_guard.destructor">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">lock_guard</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">lock_guard</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>
          is very simple: on construction it acquires ownership of the implementation
          of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> supplied as the
          constructor parameter. On destruction, the ownership is released. This
          provides simple RAII-style locking of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, to facilitate
          exception-safe locking and unlocking. In addition, the <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)"><code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code>
          constructor</a> allows the <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a> object to take ownership
          of a lock already held by the current thread.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor" title="lock_guard(Lockable &amp; m)">
          <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.constructor_adopt" title="lock_guard(Lockable &amp; m,boost::adopt_lock_t)">
          <code class="computeroutput"><span class="identifier">lock_guard</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread owns a lock on <code class="computeroutput"><span class="identifier">m</span></code>
                equivalent to one obtained by a call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.lock_guard.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard.destructor" title="~lock_guard()">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">lock_guard</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code></a>
                on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object passed to
                the constructor.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"> Class template
        <code class="computeroutput"><span class="identifier">unique_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.destructor">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.mutex">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">mutex</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.bool_conversion">
          <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="keyword">bool</span><span class="special">-</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.operator_not">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.unique_lock.release">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">unique_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">unique_lock</span><span class="special">();</span>

    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">operator</span> <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;();</span>
    <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">move</span><span class="special">();</span>
    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(::</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">absolute_time</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">operator</span> <span class="emphasis"><em>unspecified-bool-type</em></span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">Lockable</span><span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is more complex than
          <a class="link" href="synchronization.html#thread.synchronization.locks.lock_guard" title="Class template lock_guard"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span></code></a>:
          not only does it provide for RAII-style locking, it also allows for deferring
          acquiring the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          Specializations of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> model the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> if the supplied
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> type itself models <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> (e.g. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span></code>),
          or the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> otherwise (e.g.
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>).
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a> is intended to model
          the ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.defaultconstructor" title="unique_lock()">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Creates a lock object with no associated mutex.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor" title="unique_lock(Lockable &amp; m)">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_adopt" title="unique_lock(Lockable &amp; m,boost::adopt_lock_t)">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_defer" title="unique_lock(Lockable &amp; m,boost::defer_lock_t)">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_try" title="unique_lock(Lockable &amp; m,boost::try_to_lock_t)">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
                and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
                returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.constructor_abs_time" title="unique_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="identifier">unique_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
                returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.destructor" title="~unique_lock()">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">unique_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
                if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">mutex</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                is no such object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.bool_conversion"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.bool_conversion" title="operator unspecified-bool-type() const">
          <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="keyword">bool</span><span class="special">-</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                If <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                would return <code class="computeroutput"><span class="keyword">true</span></code>, a
                value that evaluates to <code class="computeroutput"><span class="keyword">true</span></code>
                in boolean contexts, otherwise a value that evaluates to <code class="computeroutput"><span class="keyword">false</span></code> in boolean contexts.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.operator_not"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.operator_not" title="bool operator!() const">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">!</span></code> <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.unique_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.release" title="Lockable* release()">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                it is the responsibility of the calling code to ensure that the
                <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly unlocked.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                if there is no such object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.shared_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"> Class template
        <code class="computeroutput"><span class="identifier">shared_lock</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.destructor">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.mutex">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">mutex</span><span class="special">()</span>
          <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.bool_conversion">
          <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="keyword">bool</span><span class="special">-</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.operator_not">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.locks.shared_lock.release">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">release</span><span class="special">()</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">shared_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">shared_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">shared_lock</span><span class="special">();</span>

    <span class="keyword">operator</span> <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;();</span>
    <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">move</span><span class="special">();</span>

    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">shared_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">shared_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">target_time</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">operator</span> <span class="emphasis"><em>unspecified-bool-type</em></span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> acquires shared ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="void unlock_shared()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock" title="Class template shared_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_lock</span></code></a> is intended to model
          the shared ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.defaultconstructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.defaultconstructor" title="shared_lock()">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Creates a lock object with no associated mutex.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="identifier">NULL</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor" title="shared_lock(Lockable &amp; m)">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exception thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock_shared</span><span class="special">()</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_adopt"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_adopt" title="shared_lock(Lockable &amp; m,boost::adopt_lock_t)">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">adopt_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                The current thread owns an exclusive lock on <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Takes ownership of the lock state of <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_defer"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_defer" title="shared_lock(Lockable &amp; m,boost::defer_lock_t)">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">defer_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_try"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_try" title="shared_lock(Lockable &amp; m,boost::try_to_lock_t)">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_to_lock_t</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>,
                and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
                returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.constructor_abs_time"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.constructor_abs_time" title="shared_lock(Lockable &amp; m,boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="identifier">shared_lock</span><span class="special">(</span><span class="identifier">Lockable</span> <span class="special">&amp;</span>
          <span class="identifier">m</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Stores a reference to <code class="computeroutput"><span class="identifier">m</span></code>.
                Invokes <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>,
                and takes ownership of the lock state if the call returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="special">&amp;</span><span class="identifier">m</span></code>.
                If the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
                returned <code class="computeroutput"><span class="keyword">true</span></code>, then
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>, otherwise
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Any exceptions thrown by the call to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">abs_time</span><span class="special">)</span></code></a>.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.destructor" title="~shared_lock()">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">shared_lock</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Invokes <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a><code class="computeroutput"><span class="special">-&gt;</span></code> <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.unlock_shared" title="void unlock_shared()"><code class="computeroutput"><span class="identifier">unlock_shared</span><span class="special">()</span></code></a>
                if <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">true</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.owns_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">true</span></code> if the <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                owns the lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.mutex" title="Lockable* mutex() const">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">mutex</span><span class="special">()</span>
          <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                or <code class="computeroutput"><span class="identifier">NULL</span></code> if there
                is no such object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.bool_conversion"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.bool_conversion" title="operator unspecified-bool-type() const">
          <code class="computeroutput"><span class="keyword">operator</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="keyword">bool</span><span class="special">-</span><span class="identifier">type</span><span class="special">()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                If <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                would return <code class="computeroutput"><span class="keyword">true</span></code>, a
                value that evaluates to <code class="computeroutput"><span class="keyword">true</span></code>
                in boolean contexts, otherwise a value that evaluates to <code class="computeroutput"><span class="keyword">false</span></code> in boolean contexts.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.operator_not"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.operator_not" title="bool operator!() const">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">!</span></code> <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.locks.shared_lock.release"></a><a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.release" title="Lockable* release()">
          <code class="computeroutput"><span class="identifier">Lockable</span><span class="special">*</span>
          <span class="identifier">release</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                The association between <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> and the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is removed,
                without affecting the lock state of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. If <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                would have returned <code class="computeroutput"><span class="keyword">true</span></code>,
                it is the responsibility of the calling code to ensure that the
                <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is correctly unlocked.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                A pointer to the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object associated
                with <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                at the point of the call, or <code class="computeroutput"><span class="identifier">NULL</span></code>
                if there is no such object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                is no longer associated with any <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object. <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="identifier">NULL</span></code> and
                <a class="link" href="synchronization.html#thread.synchronization.locks.shared_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
                returns <code class="computeroutput"><span class="keyword">false</span></code>.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"> Class template
        <code class="computeroutput"><span class="identifier">upgrade_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">Lockable</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">);</span>

    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">upgrade_lock</span><span class="special">();</span>

    <span class="keyword">operator</span> <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;();</span>
    <span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">move</span><span class="special">();</span>

    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">operator</span> <span class="emphasis"><em>unspecified-bool-type</em></span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> models the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>, but rather than
          acquiring unique ownership of the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, locking an instance
          of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> acquires upgrade
          ownership.
        </p>
<p>
          Like <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span></code></a>, not only does it
          provide for RAII-style locking, it also allows for deferring acquiring
          the lock until the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          member function is called explicitly, or trying to acquire the lock in
          a non-blocking fashion, or with a timeout. Consequently, <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          is only called in the destructor if the lock object has locked the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, or otherwise
          adopted a lock on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object.
        </p>
<p>
          An instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is said to <span class="emphasis"><em>own</em></span>
          the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> <code class="computeroutput"><span class="identifier">m</span></code>
          if <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.mutex" title="Lockable* mutex() const"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code></a>
          returns a pointer to <code class="computeroutput"><span class="identifier">m</span></code>
          and <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock.owns_lock" title="bool owns_lock() const"><code class="computeroutput"><span class="identifier">owns_lock</span><span class="special">()</span></code></a>
          returns <code class="computeroutput"><span class="keyword">true</span></code>. If an object
          that <span class="emphasis"><em>owns</em></span> the lock state of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object is destroyed,
          then the destructor will invoke <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_upgrade" title="void unlock_upgrade()"><code class="computeroutput"><span class="identifier">mutex</span><span class="special">()-&gt;</span><span class="identifier">unlock_upgrade</span><span class="special">()</span></code></a>.
        </p>
<p>
          The member functions of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> are not thread-safe.
          In particular, <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> is intended to model
          the upgrade ownership of a <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object by a particular
          thread, and the member functions that release ownership of the lock state
          (including the destructor) must be called by the same thread that acquired
          ownership of the lock state.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.upgrade_to_unique_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock">
        Class template <code class="computeroutput"><span class="identifier">upgrade_to_unique_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">locks</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lockable</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">upgrade_to_unique_lock</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">explicit</span> <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">upgrade_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;&amp;</span> <span class="identifier">m_</span><span class="special">);</span>

    <span class="special">~</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">();</span>

    <span class="identifier">upgrade_to_unique_lock</span><span class="special">(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">detail</span><span class="special">::</span><span class="identifier">thread_move_t</span><span class="special">&lt;</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&lt;</span><span class="identifier">Lockable</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">upgrade_to_unique_lock</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">operator</span> <span class="emphasis"><em>unspecified-bool-type</em></span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> allows
          for a temporary upgrade of an <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a> to exclusive ownership.
          When constructed with a reference to an instance of <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_lock" title="Class template upgrade_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_lock</span></code></a>, if that instance
          has upgrade ownership on some <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> object, that ownership
          is upgraded to exclusive ownership. When the <a class="link" href="synchronization.html#thread.synchronization.locks.upgrade_to_unique_lock" title="Class template upgrade_to_unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">upgrade_to_unique_lock</span></code></a> instance
          is destroyed, the ownership of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> is downgraded back to
          <span class="emphasis"><em>upgrade ownership</em></span>.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.locks.scoped_try_lock"></a><a class="link" href="synchronization.html#thread.synchronization.locks.scoped_try_lock" title="Mutex-specific class scoped_try_lock"> Mutex-specific
        class <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">();</span>
    <span class="keyword">explicit</span> <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">adopt_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">defer_lock_t</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">&amp;</span> <span class="identifier">m_</span><span class="special">,</span><span class="identifier">try_to_lock_t</span><span class="special">);</span>

    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>
    <span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span><span class="identifier">MutexType</span><span class="special">::</span><span class="identifier">scoped_try_lock</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">owns_lock</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">mutex</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="identifier">MutexType</span><span class="special">*</span> <span class="identifier">release</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">typedef</span> <span class="emphasis"><em>unspecified-bool-type</em></span> <span class="identifier">bool_type</span><span class="special">;</span>
    <span class="keyword">operator</span> <span class="identifier">bool_type</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          The member typedef <code class="computeroutput"><span class="identifier">scoped_try_lock</span></code>
          is provided for each distinct <code class="computeroutput"><span class="identifier">MutexType</span></code>
          as a typedef to a class with the preceding definition. The semantics of
          each constructor and member function are identical to those of <a class="link" href="synchronization.html#thread.synchronization.locks.unique_lock" title="Class template unique_lock"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">MutexType</span><span class="special">&gt;</span></code></a>
          for the same <code class="computeroutput"><span class="identifier">MutexType</span></code>,
          except that the constructor that takes a single reference to a mutex will
          call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">try_lock</span><span class="special">()</span></code></a> rather than <code class="computeroutput"><span class="identifier">m</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.lock_functions"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions" title="Lock functions"> Lock functions</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_multiple">
        Non-member function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.lock_range">
        Non-member function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple">
        Non-member function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.lock_functions.try_lock_range">
        Non-member function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_multiple" title="Non-member function lock(Lockable1,Lockable2,...)">
        Non-member function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Locks the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
              as arguments in an unspecified and indeterminate order in a way that
              avoids deadlock. It is safe to call this function concurrently from
              multiple threads with the same mutexes (or other lockable objects)
              in different orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
              or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws an
              exception any locks acquired by the function will be released before
              the function exits.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
              or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
            </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              All the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
              by the calling thread.
            </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.lock_range" title="Non-member function lock(begin,end)">
        Non-member function <code class="computeroutput"><span class="identifier">lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
              The <code class="computeroutput"><span class="identifier">value_type</span></code> of
              <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
              implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Locks all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the supplied
              range in an unspecified and indeterminate order in a way that avoids
              deadlock. It is safe to call this function concurrently from multiple
              threads with the same mutexes (or other lockable objects) in different
              orders without risk of deadlock. If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
              or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              operations on the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the supplied
              range throws an exception any locks acquired by the function will be
              released before the function exits.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
              or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
            </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              All the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the supplied
              range are locked by the calling thread.
            </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_multiple"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_multiple" title="Non-member function try_lock(Lockable1,Lockable2,...)">
        Non-member function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">,...)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Lockable1</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable2</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable3</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable4</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">Lockable5</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">Lockable1</span><span class="special">&amp;</span> <span class="identifier">l1</span><span class="special">,</span><span class="identifier">Lockable2</span><span class="special">&amp;</span> <span class="identifier">l2</span><span class="special">,</span><span class="identifier">Lockable3</span><span class="special">&amp;</span> <span class="identifier">l3</span><span class="special">,</span><span class="identifier">Lockable4</span><span class="special">&amp;</span> <span class="identifier">l4</span><span class="special">,</span><span class="identifier">Lockable5</span><span class="special">&amp;</span> <span class="identifier">l5</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects supplied
              as arguments. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              returns <code class="computeroutput"><span class="keyword">false</span></code> then all
              locks acquired are released and the zero-based index of the failed
              lock is returned.
            </p>
<p>
              If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws an
              exception any locks acquired by the function will be released before
              the function exits.
            </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
              if all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now locked
              by the calling thread, the zero-based index of the object which could
              not be locked otherwise.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
            </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              If the function returns <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>, all the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are locked
              by the calling thread. Otherwise any locks acquired by this function
              will have been released.
            </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.lock_functions.try_lock_range"></a><a class="link" href="synchronization.html#thread.synchronization.lock_functions.try_lock_range" title="Non-member function try_lock(begin,end)">
        Non-member function <code class="computeroutput"><span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">begin</span><span class="special">,</span><span class="identifier">end</span><span class="special">)</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">ForwardIterator</span><span class="special">&gt;</span>
<span class="identifier">ForwardIterator</span> <span class="identifier">try_lock</span><span class="special">(</span><span class="identifier">ForwardIterator</span> <span class="identifier">begin</span><span class="special">,</span><span class="identifier">ForwardIterator</span> <span class="identifier">end</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Preconditions:</span></dt>
<dd><p>
              The <code class="computeroutput"><span class="identifier">value_type</span></code> of
              <code class="computeroutput"><span class="identifier">ForwardIterator</span></code> must
              implement the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a>
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
              Calls <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on each of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the supplied
              range. If any of the calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              returns <code class="computeroutput"><span class="keyword">false</span></code> then all
              locks acquired are released and an iterator referencing the failed
              lock is returned.
            </p>
<p>
              If any of the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              operations on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects throws an
              exception any locks acquired by the function will be released before
              the function exits.
            </p>
</dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">end</span></code> if all the supplied
              <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects are now locked
              by the calling thread, an iterator referencing the object which could
              not be locked otherwise.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Any exceptions thrown by calling <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
              on the supplied <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects.
            </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
              If the function returns <code class="computeroutput"><span class="identifier">end</span></code>
              then all the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code></a> objects in the supplied
              range are locked by the calling thread, otherwise all locks acquired
              by the function have been released.
            </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.mutex_types"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types" title="Mutex Types"> Mutex Types</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex"> Class <code class="computeroutput"><span class="identifier">mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.try_mutex"> Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex"> Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex">
        Class <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex">
        Typedef <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex">
        Class <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.shared_mutex"> Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code></a></span></dt>
</dl></div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"> Class <code class="computeroutput"><span class="identifier">mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">mutex</span><span class="special">();</span>
    
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
    
    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership mutex. At most one thread can own the lock on a given
          instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a> at any time. Multiple concurrent
          calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex.nativehandle" title="Member function native_handle()">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                that can be used with platform-specific APIs to manipulate the underlying
                implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                are not present.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex"> Typedef
        <code class="computeroutput"><span class="identifier">try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">mutex</span> <span class="identifier">try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.try_mutex" title="Typedef try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code>
          to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.mutex" title="Class mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span></code></a>, provided for backwards
          compatibility with previous releases of boost.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"> Class
        <code class="computeroutput"><span class="identifier">timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">timed_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_timed_lock</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership mutex. At most one thread can own the lock on a
          given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex" title="Class timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timed_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="template&lt;typename DurationType&gt; bool timed_lock(DurationType const&amp; rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.timed_mutex.nativehandle" title="Member function native_handle()">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                that can be used with platform-specific APIs to manipulate the underlying
                implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                are not present.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex">
        Class <code class="computeroutput"><span class="identifier">recursive_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_mutex</span><span class="special">();</span>
    
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
    
    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> implements the
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable" title="Lockable Concept"><code class="computeroutput"><span class="identifier">Lockable</span></code> concept</a> to provide an
          exclusive-ownership recursive mutex. At most one thread can own the lock
          on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> at any time. Multiple
          concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a> instance can call
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex.nativehandle" title="Member function native_handle()">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                that can be used with platform-specific APIs to manipulate the underlying
                implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                are not present.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_try_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex">
        Typedef <code class="computeroutput"><span class="identifier">recursive_try_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">recursive_mutex</span> <span class="identifier">recursive_try_mutex</span><span class="special">;</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_try_mutex" title="Typedef recursive_try_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_try_mutex</span></code></a> is a <code class="computeroutput"><span class="keyword">typedef</span></code> to <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_mutex" title="Class recursive_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_mutex</span></code></a>, provided for
          backwards compatibility with previous releases of boost.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex">
        Class <code class="computeroutput"><span class="identifier">recursive_timed_mutex</span></code></a>
</h4></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a></span></dt></dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">recursive_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">recursive_timed_mutex</span><span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">recursive_timed_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">recursive_timed_mutex</span><span class="special">();</span>
    
    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">TimeDuration</span><span class="special">&gt;</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">TimeDuration</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">relative_time</span><span class="special">);</span>

    <span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
    <span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
    
    <span class="keyword">typedef</span> <span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">recursive_timed_mutex</span><span class="special">&gt;</span> <span class="identifier">scoped_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">scoped_try_lock</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="identifier">scoped_lock</span> <span class="identifier">scoped_timed_lock</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
          <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> implements
          the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable" title="TimedLockable Concept"><code class="computeroutput"><span class="identifier">TimedLockable</span></code> concept</a> to provide
          an exclusive-ownership recursive mutex. At most one thread can own the
          lock on a given instance of <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> at any time.
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="template&lt;typename DurationType&gt; bool timed_lock(DurationType const&amp; rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          shall be permitted. A thread that already has exclusive ownership of a
          given <a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex" title="Class recursive_timed_mutex"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_timed_mutex</span></code></a> instance
          can call <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock_duration" title="template&lt;typename DurationType&gt; bool timed_lock(DurationType const&amp; rel_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>
          or <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>
          to acquire an additional level of ownership of the mutex. <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.unlock" title="void unlock()"><code class="computeroutput"><span class="identifier">unlock</span><span class="special">()</span></code></a>
          must be called once for each level of ownership acquired by a single thread
          before ownership can be acquired by another thread.
        </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.recursive_timed_mutex.nativehandle" title="Member function native_handle()">
          Member function <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">native_handle_type</span><span class="special">;</span>
<span class="identifier">native_handle_type</span> <span class="identifier">native_handle</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Returns an instance of <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                that can be used with platform-specific APIs to manipulate the underlying
                implementation. If no such instance exists, <code class="computeroutput"><span class="identifier">native_handle</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">native_handle_type</span></code>
                are not present.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.mutex_types.shared_mutex"></a><a class="link" href="synchronization.html#thread.synchronization.mutex_types.shared_mutex" title="Class shared_mutex"> Class
        <code class="computeroutput"><span class="identifier">shared_mutex</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">shared_mutex</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">shared_mutex</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">shared_mutex</span><span class="special">();</span>
    <span class="special">~</span><span class="identifier">shared_mutex</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock_shared</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock_shared</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock_shared</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">try_lock</span><span class="special">();</span>
    <span class="keyword">bool</span> <span class="identifier">timed_lock</span><span class="special">(</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">timeout</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">unlock</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">lock_upgrade</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_upgrade</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_and_lock_shared</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">unlock_upgrade_and_lock_shared</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          The class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">shared_mutex</span></code> provides an implementation
          of a multiple-reader / single-writer mutex. It implements the <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable" title="UpgradeLockable Concept"><code class="computeroutput"><span class="identifier">UpgradeLockable</span></code> concept</a>.
        </p>
<p>
          Multiple concurrent calls to <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.lock" title="void lock()"><code class="computeroutput"><span class="identifier">lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.lockable.try_lock" title="bool try_lock()"><code class="computeroutput"><span class="identifier">try_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.timed_lockable.timed_lock" title="bool timed_lock(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.lock_shared" title="void lock_shared()"><code class="computeroutput"><span class="identifier">lock_shared</span><span class="special">()</span></code></a>,
          <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.try_lock_shared" title="bool try_lock_shared()"><code class="computeroutput"><span class="identifier">try_lock_shared</span><span class="special">()</span></code></a>
          and <a class="link" href="synchronization.html#thread.synchronization.mutex_concepts.shared_lockable.timed_lock_shared" title="bool timed_lock_shared(boost::system_time const&amp; abs_time)"><code class="computeroutput"><span class="identifier">timed_lock_shared</span><span class="special">()</span></code></a>
          shall be permitted.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.condvar_ref"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref" title="Condition Variables"> Condition Variables</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable">
        Class <code class="computeroutput"><span class="identifier">condition_variable</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any">
        Class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition"> Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code></a></span></dt>
</dl></div>
<a name="thread.synchronization.condvar_ref.synopsis"></a><h5>
<a name="id3556971"></a>
        <a class="link" href="synchronization.html#thread.synchronization.condvar_ref.synopsis">Synopsis</a>
      </h5>
<p>
        The classes <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        and <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        provide a mechanism for one thread to wait for notification from another
        thread that a particular condition has become true. The general usage pattern
        is that one thread locks a mutex and then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        on an instance of <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        or <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
        When the thread is woken from the wait, then it checks to see if the appropriate
        condition is now true, and continues if so. If the condition is not true,
        then the thread then calls <code class="computeroutput"><span class="identifier">wait</span></code>
        again to resume waiting. In the simplest case, this condition is just a boolean
        variable:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">condition_variable</span> <span class="identifier">cond</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span> <span class="identifier">mut</span><span class="special">;</span>
<span class="keyword">bool</span> <span class="identifier">data_ready</span><span class="special">;</span>

<span class="keyword">void</span> <span class="identifier">process_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">wait_for_data_to_process</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
    <span class="keyword">while</span><span class="special">(!</span><span class="identifier">data_ready</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">cond</span><span class="special">.</span><span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="identifier">process_data</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Notice that the <code class="computeroutput"><span class="identifier">lock</span></code> is passed
        to <code class="computeroutput"><span class="identifier">wait</span></code>: <code class="computeroutput"><span class="identifier">wait</span></code>
        will atomically add the thread to the set of threads waiting on the condition
        variable, and unlock the mutex. When the thread is woken, the mutex will
        be locked again before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
        returns. This allows other threads to acquire the mutex in order to update
        the shared data, and ensures that the data associated with the condition
        is correctly synchronized.
      </p>
<p>
        In the mean time, another thread sets the condition to <code class="computeroutput"><span class="keyword">true</span></code>,
        and then calls either <code class="computeroutput"><span class="identifier">notify_one</span></code>
        or <code class="computeroutput"><span class="identifier">notify_all</span></code> on the condition
        variable to wake one waiting thread or all the waiting threads respectively.
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">retrieve_data</span><span class="special">();</span>
<span class="keyword">void</span> <span class="identifier">prepare_data</span><span class="special">();</span>

<span class="keyword">void</span> <span class="identifier">prepare_data_for_processing</span><span class="special">()</span>
<span class="special">{</span>
    <span class="identifier">retrieve_data</span><span class="special">();</span>
    <span class="identifier">prepare_data</span><span class="special">();</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lock_guard</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span> <span class="identifier">lock</span><span class="special">(</span><span class="identifier">mut</span><span class="special">);</span>
        <span class="identifier">data_ready</span><span class="special">=</span><span class="keyword">true</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">cond</span><span class="special">.</span><span class="identifier">notify_one</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
        Note that the same mutex is locked before the shared data is updated, but
        that the mutex does not have to be locked across the call to <code class="computeroutput"><span class="identifier">notify_one</span></code>.
      </p>
<p>
        This example uses an object of type <code class="computeroutput"><span class="identifier">condition_variable</span></code>,
        but would work just as well with an object of type <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>:
        <code class="computeroutput"><span class="identifier">condition_variable_any</span></code> is
        more general, and will work with any kind of lock or mutex, whereas <code class="computeroutput"><span class="identifier">condition_variable</span></code> requires that the lock
        passed to <code class="computeroutput"><span class="identifier">wait</span></code> is an instance
        of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;</span></code>.
        This enables <code class="computeroutput"><span class="identifier">condition_variable</span></code>
        to make optimizations in some cases, based on the knowledge of the mutex
        type; <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>
        typically has a more complex implementation than <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable" title="Class condition_variable">
        Class <code class="computeroutput"><span class="identifier">condition_variable</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor">
          <code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">condition_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

    <span class="comment">// backwards compatibility
</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.constructor" title="condition_variable()">
          <code class="computeroutput"><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.destructor" title="~condition_variable()">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                not have returned).
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Destroys the object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_one" title="void notify_one()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code>, unblocks
                one of those threads.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.notify_all" title="void notify_all()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code>, unblocks
                all of those threads.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait" title="void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock)">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread, and either no other thread is currently waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the calls
                to <code class="computeroutput"><span class="identifier">wait</span></code> or <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all the threads currently
                waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                would return the same value as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code> for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                or spuriously. When the thread is unblocked (for whatever reason),
                the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.wait_predicate" title="template&lt;typename predicate_type&gt; void wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, predicate_type pred)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                As-if 
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait" title="bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread, and either no other thread is currently waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the calls
                to <code class="computeroutput"><span class="identifier">wait</span></code> or <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all the threads currently
                waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                would return the same value as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code> for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                or spuriously. When the thread is unblocked (for whatever reason),
                the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">false</span></code> if the call is
                returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                was reached, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_rel" title="template&lt;typename duration_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,duration_type const&amp; rel_time)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread, and either no other thread is currently waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>,
                or the execution of the <code class="computeroutput"><span class="identifier">mutex</span><span class="special">()</span></code> member function on the <code class="computeroutput"><span class="identifier">lock</span></code> objects supplied in the calls
                to <code class="computeroutput"><span class="identifier">wait</span></code> or <code class="computeroutput"><span class="identifier">timed_wait</span></code> in all the threads currently
                waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                would return the same value as <code class="computeroutput"><span class="identifier">lock</span><span class="special">-&gt;</span><span class="identifier">mutex</span><span class="special">()</span></code> for this call to <code class="computeroutput"><span class="identifier">wait</span></code>.
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                argument has elapsed, or spuriously. When the thread is unblocked
                (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">false</span></code> if the call is
                returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable.timed_wait_predicate" title="template&lt;typename predicate_type&gt; bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">unique_lock</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mutex</span><span class="special">&gt;&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span>
          <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                As-if 
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any" title="Class condition_variable_any">
        Class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code></a>
</h4></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor">
          <code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a></span></dt>
</dl></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">condition_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>
    <span class="keyword">class</span> <span class="identifier">condition_variable_any</span>
    <span class="special">{</span>
    <span class="keyword">public</span><span class="special">:</span>
        <span class="identifier">condition_variable_any</span><span class="special">();</span>
        <span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">();</span>

        <span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">();</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">rel_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>

    <span class="comment">// backwards compatibility
</span>
        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&gt;&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">);</span>

        <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
        <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">xtime</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">,</span><span class="identifier">predicate_type</span> <span class="identifier">predicate</span><span class="special">);</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.constructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.constructor" title="condition_variable_any()">
          <code class="computeroutput"><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Constructs an object of class <code class="computeroutput"><span class="identifier">condition_variable_any</span></code>.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.destructor"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.destructor" title="~condition_variable_any()">
          <code class="computeroutput"><span class="special">~</span><span class="identifier">condition_variable_any</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
                All threads waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code> have been notified by a call
                to <code class="computeroutput"><span class="identifier">notify_one</span></code> or
                <code class="computeroutput"><span class="identifier">notify_all</span></code> (though
                the respective calls to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code> need
                not have returned).
              </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Destroys the object.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_one"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_one" title="void notify_one()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_one</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code>, unblocks
                one of those threads.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.notify_all"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.notify_all" title="void notify_all()">
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">notify_all</span><span class="special">()</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                If any threads are currently <span class="emphasis"><em>blocked</em></span> waiting
                on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>
                in a call to <code class="computeroutput"><span class="identifier">wait</span></code>
                or <code class="computeroutput"><span class="identifier">timed_wait</span></code>, unblocks
                all of those threads.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                Nothing.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait" title="template&lt;typename lock_type&gt; void wait(lock_type&amp; lock)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                or spuriously. When the thread is unblocked (for whatever reason),
                the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; void wait(lock_type&amp; lock, predicate_type pred)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">void</span> <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">predicate_type</span>
          <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                As-if 
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="identifier">wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait" title="template&lt;typename lock_type&gt; bool timed_wait(lock_type&amp; lock,boost::system_time const&amp; abs_time)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">&gt;</span> <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span>
          <span class="identifier">lock</span><span class="special">,</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">abs_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                when the time as reported by <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">get_system_time</span><span class="special">()</span></code> would be equal to or later than
                the specified <code class="computeroutput"><span class="identifier">abs_time</span></code>,
                or spuriously. When the thread is unblocked (for whatever reason),
                the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> before the call to <code class="computeroutput"><span class="identifier">wait</span></code> returns. The lock is also
                reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">false</span></code> if the call is
                returning because the time specified by <code class="computeroutput"><span class="identifier">abs_time</span></code>
                was reached, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_rel" title="template&lt;typename lock_type,typename duration_type&gt; bool timed_wait(lock_type&amp; lock,duration_type const&amp; rel_time)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">duration_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span><span class="identifier">duration_type</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">rel_time</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
                Atomically call <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">unlock</span><span class="special">()</span></code> and blocks the current thread.
                The thread will unblock when notified by a call to <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_one</span><span class="special">()</span></code>
                or <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">notify_all</span><span class="special">()</span></code>,
                after the period of time indicated by the <code class="computeroutput"><span class="identifier">rel_time</span></code>
                argument has elapsed, or spuriously. When the thread is unblocked
                (for whatever reason), the lock is reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code>
                before the call to <code class="computeroutput"><span class="identifier">wait</span></code>
                returns. The lock is also reacquired by invoking <code class="computeroutput"><span class="identifier">lock</span><span class="special">.</span><span class="identifier">lock</span><span class="special">()</span></code> if the function exits with an exception.
              </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="keyword">false</span></code> if the call is
                returning because the time period specified by <code class="computeroutput"><span class="identifier">rel_time</span></code>
                has elapsed, <code class="computeroutput"><span class="keyword">true</span></code> otherwise.
              </p></dd>
<dt><span class="term">Postcondition:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">lock</span></code> is locked by
                the current thread.
              </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
                <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
                occurs. <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_interrupted</span></code> if the wait
                was interrupted by a call to <a class="link" href="thread_management.html#thread.thread_management.thread.interrupt" title="Member function interrupt()"><code class="computeroutput"><span class="identifier">interrupt</span><span class="special">()</span></code></a>
                on the <a class="link" href="thread_management.html#thread.thread_management.thread" title="Class thread"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread</span></code></a> object associated
                with the current thread of execution.
              </p></dd>
</dl>
</div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
              The duration overload of timed_wait is difficult to use correctly.
              The overload taking a predicate should be preferred in most cases.
            </p></td></tr>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h5 class="title">
<a name="thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition_variable_any.timed_wait_predicate" title="template&lt;typename lock_type,typename predicate_type&gt; bool timed_wait(lock_type&amp; lock, boost::system_time const&amp; abs_time, predicate_type pred)">
          <code class="computeroutput"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">lock_type</span><span class="special">,</span><span class="keyword">typename</span> <span class="identifier">predicate_type</span><span class="special">&gt;</span>
          <span class="keyword">bool</span> <span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock_type</span><span class="special">&amp;</span> <span class="identifier">lock</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">system_time</span>
          <span class="keyword">const</span><span class="special">&amp;</span>
          <span class="identifier">abs_time</span><span class="special">,</span>
          <span class="identifier">predicate_type</span> <span class="identifier">pred</span><span class="special">)</span></code></a>
</h5></div></div></div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd>
<p>
                As-if 
</p>
<pre class="programlisting"><span class="keyword">while</span><span class="special">(!</span><span class="identifier">pred</span><span class="special">())</span>
<span class="special">{</span>
    <span class="keyword">if</span><span class="special">(!</span><span class="identifier">timed_wait</span><span class="special">(</span><span class="identifier">lock</span><span class="special">,</span><span class="identifier">abs_time</span><span class="special">))</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">pred</span><span class="special">();</span>
    <span class="special">}</span>
<span class="special">}</span>
<span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
              </p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.condvar_ref.condition"></a><a class="link" href="synchronization.html#thread.synchronization.condvar_ref.condition" title="Typedef condition"> Typedef
        <code class="computeroutput"><span class="identifier">condition</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">condition</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">condition_variable_any</span> <span class="identifier">condition</span><span class="special">;</span>
</pre>
<p>
          The typedef <code class="computeroutput"><span class="identifier">condition</span></code> is
          provided for backwards compatibility with previous boost releases.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.once"></a><a class="link" href="synchronization.html#thread.synchronization.once" title="One-time Initialization"> One-time Initialization</a>
</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.once_flag"> Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a></span></dt>
<dt><span class="section"><a href="synchronization.html#thread.synchronization.once.call_once"> Non-member
        function <code class="computeroutput"><span class="identifier">call_once</span></code></a></span></dt>
</dl></div>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">call_once</span></code> provides a mechanism for ensuring
        that an initialization routine is run exactly once without data races or
        deadlocks.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.once_flag"></a><a class="link" href="synchronization.html#thread.synchronization.once.once_flag" title="Typedef once_flag"> Typedef <code class="computeroutput"><span class="identifier">once_flag</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">once</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">once_flag</span><span class="special">;</span>
<span class="preprocessor">#define</span> <span class="identifier">BOOST_ONCE_INIT</span> <span class="identifier">platform</span><span class="special">-</span><span class="identifier">specific</span><span class="special">-</span><span class="identifier">initializer</span>
</pre>
<p>
          Objects of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span></code> shall be initialized with
          <code class="computeroutput"><span class="identifier">BOOST_ONCE_INIT</span></code>:
        </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">once_flag</span> <span class="identifier">f</span><span class="special">=</span><span class="identifier">BOOST_ONCE_INIT</span><span class="special">;</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.once.call_once"></a><a class="link" href="synchronization.html#thread.synchronization.once.call_once" title="Non-member function call_once"> Non-member
        function <code class="computeroutput"><span class="identifier">call_once</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">once</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Callable</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">,</span><span class="identifier">Callable</span> <span class="identifier">func</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Requires:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">Callable</span></code> is <code class="computeroutput"><span class="identifier">CopyConstructible</span></code>. Copying <code class="computeroutput"><span class="identifier">func</span></code> shall have no side effects,
              and the effect of calling the copy shall be equivalent to calling the
              original.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Calls to <code class="computeroutput"><span class="identifier">call_once</span></code>
              on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
              object are serialized. If there has been no prior effective <code class="computeroutput"><span class="identifier">call_once</span></code> on the same <code class="computeroutput"><span class="identifier">once_flag</span></code> object, the argument <code class="computeroutput"><span class="identifier">func</span></code> (or a copy thereof) is called
              as-if by invoking <code class="computeroutput"><span class="identifier">func</span><span class="special">()</span></code>, and the invocation of <code class="computeroutput"><span class="identifier">call_once</span></code> is effective if and only
              if <code class="computeroutput"><span class="identifier">func</span><span class="special">()</span></code>
              returns without exception. If an exception is thrown, the exception
              is propagated to the caller. If there has been a prior effective <code class="computeroutput"><span class="identifier">call_once</span></code> on the same <code class="computeroutput"><span class="identifier">once_flag</span></code> object, the <code class="computeroutput"><span class="identifier">call_once</span></code> returns without invoking
              <code class="computeroutput"><span class="identifier">func</span></code>.
            </p></dd>
<dt><span class="term">Synchronization:</span></dt>
<dd><p>
              The completion of an effective <code class="computeroutput"><span class="identifier">call_once</span></code>
              invocation on a <code class="computeroutput"><span class="identifier">once_flag</span></code>
              object, synchronizes with all subsequent <code class="computeroutput"><span class="identifier">call_once</span></code>
              invocations on the same <code class="computeroutput"><span class="identifier">once_flag</span></code>
              object.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">thread_resource_error</span></code>
              when the effects cannot be achieved. or any exception propagated from
              <code class="computeroutput"><span class="identifier">func</span></code>.
            </p></dd>
</dl>
</div>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">call_once</span><span class="special">(</span><span class="keyword">void</span> <span class="special">(*</span><span class="identifier">func</span><span class="special">)(),</span><span class="identifier">once_flag</span><span class="special">&amp;</span> <span class="identifier">flag</span><span class="special">);</span>
</pre>
<p>
          This second overload is provided for backwards compatibility. The effects
          of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">func</span><span class="special">,</span><span class="identifier">flag</span><span class="special">)</span></code>
          shall be the same as those of <code class="computeroutput"><span class="identifier">call_once</span><span class="special">(</span><span class="identifier">flag</span><span class="special">,</span><span class="identifier">func</span><span class="special">)</span></code>.
        </p>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="thread.synchronization.barriers"></a><a class="link" href="synchronization.html#thread.synchronization.barriers" title="Barriers"> Barriers</a>
</h3></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="synchronization.html#thread.synchronization.barriers.barrier"> Class <code class="computeroutput"><span class="identifier">barrier</span></code></a></span></dt></dl></div>
<p>
        A barrier is a simple concept. Also known as a <span class="emphasis"><em>rendezvous</em></span>,
        it is a synchronization point between multiple threads. The barrier is configured
        for a particular number of threads (<code class="computeroutput"><span class="identifier">n</span></code>),
        and as threads reach the barrier they must wait until all <code class="computeroutput"><span class="identifier">n</span></code>
        threads have arrived. Once the <code class="computeroutput"><span class="identifier">n</span></code>-th
        thread has reached the barrier, all the waiting threads can proceed, and
        the barrier is reset.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="thread.synchronization.barriers.barrier"></a><a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier"> Class <code class="computeroutput"><span class="identifier">barrier</span></code></a>
</h4></div></div></div>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">thread</span><span class="special">/</span><span class="identifier">barrier</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">barrier</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
    <span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>

    <span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
<span class="special">};</span>
</pre>
<p>
          Instances of <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier" title="Class barrier"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">barrier</span></code></a> are not copyable or movable.
        </p>
<a name="thread.synchronization.barriers.barrier.constructor"></a><h6>
<a name="id3565754"></a>
          <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.constructor">Constructor</a>
        </h6>
<pre class="programlisting"><span class="identifier">barrier</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="identifier">count</span><span class="special">);</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Construct a barrier for <code class="computeroutput"><span class="identifier">count</span></code>
              threads.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
              occurs.
            </p></dd>
</dl>
</div>
<a name="thread.synchronization.barriers.barrier.destructor"></a><h6>
<a name="id3565869"></a>
          <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.destructor">Destructor</a>
        </h6>
<pre class="programlisting"><span class="special">~</span><span class="identifier">barrier</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Precondition:</span></dt>
<dd><p>
              No threads are waiting on <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
            </p></dd>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Destroys <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              Nothing.
            </p></dd>
</dl>
</div>
<a name="thread.synchronization.barriers.barrier.member_function__code__phrase_role__identifier__wait__phrase___code_"></a><h6>
<a name="id3565983"></a>
          <a class="link" href="synchronization.html#thread.synchronization.barriers.barrier.member_function__code__phrase_role__identifier__wait__phrase___code_">Member
          function <code class="computeroutput"><span class="identifier">wait</span></code></a>
        </h6>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">wait</span><span class="special">();</span>
</pre>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Effects:</span></dt>
<dd><p>
              Block until <code class="computeroutput"><span class="identifier">count</span></code> threads
              have called <code class="computeroutput"><span class="identifier">wait</span></code> on
              <code class="computeroutput"><span class="special">*</span><span class="keyword">this</span></code>.
              When the <code class="computeroutput"><span class="identifier">count</span></code>-th thread
              calls <code class="computeroutput"><span class="identifier">wait</span></code>, all waiting
              threads are unblocked, and the barrier is reset.
            </p></dd>
<dt><span class="term">Returns:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="keyword">true</span></code> for exactly one thread
              from each batch of waiting threads, <code class="computeroutput"><span class="keyword">false</span></code>
              otherwise.
            </p></dd>
<dt><span class="term">Throws:</span></dt>
<dd><p>
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">thread_resource_error</span></code> if an error
              occurs.
            </p></dd>
</dl>
</div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2007 -8 Anthony Williams<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="thread_management.html"><img src="../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../thread.html"><img src="../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="thread_local_storage.html"><img src="../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

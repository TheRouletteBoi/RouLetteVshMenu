<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Class template unique_ptr</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="../../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../../boost_interprocess_reference.html#header.boost.interprocess.smart_ptr.unique_ptr.hpp" title="Header &lt;boost/interprocess/smart_ptr/unique_ptr.hpp&gt;">
<link rel="prev" href="make_managed_shared_ptr.html" title="Function template make_managed_shared_ptr">
<link rel="next" href="managed_unique_ptr.html" title="Struct template managed_unique_ptr">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../boost.png"></td>
<td align="center"><a href="../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="make_managed_shared_ptr.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.smart_ptr.unique_ptr.hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="managed_unique_ptr.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="refentry" lang="en">
<a name="boost.interprocess.unique_ptr"></a><div class="titlepage"></div>
<div class="refnamediv">
<h2><span class="refentrytitle">Class template unique_ptr</span></h2>
<p>boost::interprocess::unique_ptr</p>
</div>
<h2 xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv-title">Synopsis</h2>
<div xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="refsynopsisdiv"><pre class="synopsis"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> T, <span class="bold"><strong>typename</strong></span> D&gt; 
<span class="bold"><strong>class</strong></span> <a class="link" href="unique_ptr.html" title="Class template unique_ptr">unique_ptr</a> {
<span class="bold"><strong>public</strong></span>:
  <span class="emphasis"><em>// types</em></span>
  <span class="bold"><strong>typedef</strong></span> T           <a name="boost.interprocess.unique_ptr.element_type"></a>element_type;
  <span class="bold"><strong>typedef</strong></span> D           <a name="boost.interprocess.unique_ptr.deleter_type"></a>deleter_type;
  <span class="bold"><strong>typedef</strong></span> <span class="emphasis"><em>unspecified</em></span> <a name="boost.interprocess.unique_ptr.pointer"></a>pointer;     

  <span class="emphasis"><em>// <a class="link" href="unique_ptr.html#boost.interprocess.unique_ptrconstruct-copy-destruct">construct/copy/destruct</a></em></span>
  <a class="link" href="unique_ptr.html#id2904844-bb">unique_ptr</a>();
  <a class="link" href="unique_ptr.html#id2904860-bb">unique_ptr</a>(pointer);
  <a class="link" href="unique_ptr.html#id2904885-bb">unique_ptr</a>(pointer, <span class="emphasis"><em>unspecified</em></span>);
  <a class="link" href="unique_ptr.html#id2904910-bb">unique_ptr</a>(<span class="emphasis"><em>unspecified</em></span>);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U, <span class="bold"><strong>typename</strong></span> E&gt; 
    <a class="link" href="unique_ptr.html#id2904944-bb">unique_ptr</a>(<span class="emphasis"><em>unspecified</em></span>, <span class="emphasis"><em>unspecified</em></span> = nat());
  unique_ptr&amp; <a class="link" href="unique_ptr.html#id2905007-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="emphasis"><em>unspecified</em></span>);
  <span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U, <span class="bold"><strong>typename</strong></span> E&gt; unique_ptr&amp; <a class="link" href="unique_ptr.html#id2905033-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="emphasis"><em>unspecified</em></span>);
  unique_ptr&amp; <a class="link" href="unique_ptr.html#id2905072-bb"><span class="bold"><strong>operator</strong></span>=</a>(<span class="bold"><strong>int</strong></span> nat::*);
  <a class="link" href="unique_ptr.html#id2904999-bb">~unique_ptr</a>();

  <span class="emphasis"><em>// <a class="link" href="unique_ptr.html#id2904674-bb">public member functions</a></em></span>
  <span class="type"><span class="emphasis"><em>unspecified</em></span></span> <a class="link" href="unique_ptr.html#id2904678-bb"><span class="bold"><strong>operator</strong></span>*</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">pointer</span> <a class="link" href="unique_ptr.html#id2904691-bb"><span class="bold"><strong>operator</strong></span>-&gt;</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">pointer</span> <a class="link" href="unique_ptr.html#id2904704-bb">get</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">deleter_reference</span> <a class="link" href="unique_ptr.html#id2904716-bb">get_deleter</a>() ;
  <span class="type">deleter_const_reference</span> <a class="link" href="unique_ptr.html#id2904730-bb">get_deleter</a>() <span class="bold"><strong>const</strong></span>;
  <a class="link" href="unique_ptr.html#id2904745-bb"><span class="bold"><strong>operator</strong></span> <span class="bold"><strong>int</strong></span> nat::*</a>() <span class="bold"><strong>const</strong></span>;
  <span class="type">pointer</span> <a class="link" href="unique_ptr.html#id2904761-bb">release</a>() ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unique_ptr.html#id2904778-bb">reset</a>(pointer = 0) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unique_ptr.html#id2904804-bb">swap</a>(<a class="link" href="unique_ptr.html" title="Class template unique_ptr">unique_ptr</a> &amp;) ;
  <span class="type"><span class="bold"><strong>void</strong></span></span> <a class="link" href="unique_ptr.html#id2904830-bb">swap</a>(<span class="emphasis"><em>unspecified</em></span>) ;
};</pre></div>
<div class="refsect1" lang="en">
<a name="id3139608"></a><h2>Description</h2>
<p>Template unique_ptr stores a pointer to an object and deletes that object using the associated deleter when it is itself destroyed (such as when leaving block scope.</p>
<p>The unique_ptr provides a semantics of strict ownership. A unique_ptr owns the object it holds a pointer to.</p>
<p>A unique_ptr is not CopyConstructible, nor CopyAssignable, however it is MoveConstructible and Move-Assignable.</p>
<p>The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from a function</p>
<p>A client-supplied template argument D must be a function pointer or functor for which, given a value d of type D and a pointer ptr to a type T*, the expression d(ptr) is valid and has the effect of deallocating the pointer as appropriate for that deleter. D may also be an lvalue-reference to a deleter.</p>
<p>If the deleter D maintains state, it is intended that this state stay with the associated pointer as ownership is transferred from unique_ptr to unique_ptr. The deleter state need never be copied, only moved or swapped as pointer ownership is moved around. That is, the deleter need only be MoveConstructible, MoveAssignable, and Swappable, and need not be CopyConstructible (unless copied into the unique_ptr) nor CopyAssignable. </p>
<div class="refsect2" lang="en">
<a name="id3139647"></a><h3>
<a name="boost.interprocess.unique_ptrconstruct-copy-destruct"></a><code class="computeroutput">unique_ptr</code> 
        public
       construct/copy/destruct</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><a name="id2904844-bb"></a>unique_ptr();</pre>
<p>Requires: D must be default constructible, and that construction must not throw an exception. D must not be a reference type.</p>
<p>Effects: Constructs a unique_ptr which owns nothing.</p>
<p>Postconditions: get() == 0. get_deleter() returns a reference to a default constructed deleter D.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><a name="id2904860-bb"></a>unique_ptr(pointer p);</pre>
<p>Requires: The expression D()(p) must be well formed. The default constructor of D must not throw an exception.</p>
<p>D must not be a reference type.</p>
<p>Effects: Constructs a unique_ptr which owns p.</p>
<p>Postconditions: get() == p. get_deleter() returns a reference to a default constructed deleter D.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><a name="id2904885-bb"></a>unique_ptr(pointer p, <span class="emphasis"><em>unspecified</em></span> d);</pre>
<p>Requires: The expression d(p) must be well formed.</p>
<p>Postconditions: get() == p. get_deleter() returns a reference to the internally stored deleter. If D is a reference type then get_deleter() returns a reference to the lvalue d.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><a name="id2904910-bb"></a>unique_ptr(<span class="emphasis"><em>unspecified</em></span> u);</pre>
<p>Requires: If the deleter is not a reference type, construction of the deleter D from an lvalue D must not throw an exception.</p>
<p>Effects: Constructs a unique_ptr which owns the pointer which u owns (if any). If the deleter is not a reference type, it is move constructed from u's deleter, otherwise the reference is copy constructed from u's deleter.</p>
<p>After the construction, u no longer owns a pointer. [ Note: The deleter constructor can be implemented with std::detail::forward_impl&lt;D&gt;. -end note ]</p>
<p>Postconditions: get() == value u.get() had before the construction. get_deleter() returns a reference to the internally stored deleter which was constructed from u.get_deleter(). If D is a reference type then get_- deleter() and u.get_deleter() both reference the same lvalue deleter.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U, <span class="bold"><strong>typename</strong></span> E&gt; 
  <a name="id2904944-bb"></a>unique_ptr(<span class="emphasis"><em>unspecified</em></span> u, <span class="emphasis"><em>unspecified</em></span> = nat());</pre>
<p>Requires: If D is not a reference type, construction of the deleter D from an rvalue of type E must be well formed and not throw an exception. If D is a reference type, then E must be the same type as D (diagnostic required). unique_ptr&lt;U, E&gt;::pointer must be implicitly convertible to pointer.</p>
<p>Effects: Constructs a unique_ptr which owns the pointer which u owns (if any). If the deleter is not a reference type, it is move constructed from u's deleter, otherwise the reference is copy constructed from u's deleter.</p>
<p>After the construction, u no longer owns a pointer.</p>
<p>postconditions get() == value u.get() had before the construction, modulo any required offset adjustments resulting from the cast from U* to T*. get_deleter() returns a reference to the internally stored deleter which was constructed from u.get_deleter().</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout">unique_ptr&amp; <a name="id2905007-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="emphasis"><em>unspecified</em></span> u);</pre>
<p>Requires: Assignment of the deleter D from an rvalue D must not throw an exception.</p>
<p>Effects: reset(u.release()) followed by a move assignment from u's deleter to this deleter.</p>
<p>Postconditions: This unique_ptr now owns the pointer which u owned, and u no longer owns it.</p>
<p>Returns: *this.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="bold"><strong>template</strong></span>&lt;<span class="bold"><strong>typename</strong></span> U, <span class="bold"><strong>typename</strong></span> E&gt; unique_ptr&amp; <a name="id2905033-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="emphasis"><em>unspecified</em></span> mu);</pre>
<p>Requires: Assignment of the deleter D from an rvalue D must not throw an exception. U* must be implicitly convertible to T*.</p>
<p>Effects: reset(u.release()) followed by a move assignment from u's deleter to this deleter. If either D or E is a reference type, then the referenced lvalue deleter participates in the move assignment.</p>
<p>Postconditions: This unique_ptr now owns the pointer which u owned, and u no longer owns it.</p>
<p>Returns: *this.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout">unique_ptr&amp; <a name="id2905072-bb"></a><span class="bold"><strong>operator</strong></span>=(<span class="bold"><strong>int</strong></span> nat::*);</pre>
<p>Assigns from the literal 0 or NULL.</p>
<p>Effects: reset().</p>
<p>Postcondition: get() == 0</p>
<p>Returns: *this.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><a name="id2904999-bb"></a>~unique_ptr();</pre>
<p>Effects: If get() == 0 there are no effects. Otherwise get_deleter()(get()).</p>
<p>Throws: nothing. </p>
</li>
</ol></div>
</div>
<div class="refsect2" lang="en">
<a name="id3140023"></a><h3>
<a name="id2904674-bb"></a><code class="computeroutput">unique_ptr</code> public member functions</h3>
<div class="orderedlist"><ol type="1">
<li>
<pre class="literallayout"><span class="type"><span class="emphasis"><em>unspecified</em></span></span> <a name="id2904678-bb"></a><span class="bold"><strong>operator</strong></span>*() <span class="bold"><strong>const</strong></span>;</pre>
<p>Requires: get() != 0. Returns: *get(). Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id2904691-bb"></a><span class="bold"><strong>operator</strong></span>-&gt;() <span class="bold"><strong>const</strong></span>;</pre>
<p>Requires: get() != 0. Returns: get(). Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id2904704-bb"></a>get() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns: The stored pointer. Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type">deleter_reference</span> <a name="id2904716-bb"></a>get_deleter() ;</pre>
<p>Returns: A reference to the stored deleter.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type">deleter_const_reference</span> <a name="id2904730-bb"></a>get_deleter() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns: A const reference to the stored deleter.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><a name="id2904745-bb"></a><span class="bold"><strong>operator</strong></span> <span class="bold"><strong>int</strong></span> nat::*() <span class="bold"><strong>const</strong></span>;</pre>
<p>Returns: An unspecified value that, when used in boolean contexts, is equivalent to get() != 0.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type">pointer</span> <a name="id2904761-bb"></a>release() ;</pre>
<p>Postcondition: get() == 0.</p>
<p>Returns: The value get() had at the start of the call to release.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2904778-bb"></a>reset(pointer p = 0) ;</pre>
<p>Effects: If p == get() there are no effects. Otherwise get_deleter()(get()).</p>
<p>Postconditions: get() == p.</p>
<p>Throws: nothing. </p>
</li>
<li>
<pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2904804-bb"></a>swap(<a class="link" href="unique_ptr.html" title="Class template unique_ptr">unique_ptr</a> &amp; u) ;</pre>
<p>Requires: The deleter D is Swappable and will not throw an exception under swap.</p>
<p>Effects: The stored pointers of this and u are exchanged. The stored deleters are swapped (unqualified). Throws: nothing. </p>
</li>
<li><pre class="literallayout"><span class="type"><span class="bold"><strong>void</strong></span></span> <a name="id2904830-bb"></a>swap(<span class="emphasis"><em>unspecified</em></span> mu) ;</pre></li>
</ol></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2005 - 2007 Ion Gaztañaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="make_managed_shared_ptr.html"><img src="../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../../boost_interprocess_reference.html#header.boost.interprocess.smart_ptr.unique_ptr.hpp"><img src="../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="managed_unique_ptr.html"><img src="../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

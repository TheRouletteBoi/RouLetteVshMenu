<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  --
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://opensource.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library  : Class List</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="globals.html">File Members</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.4.4 -->
<h1>Generic Image Library Class List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0380.html">alpha_t</a></td><td class="indexvalue">Alpha </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0018.html">any_image</a></td><td class="indexvalue">Represents a run-time specified image. Note it does NOT model <a class="el" href="g_i_l_0301.html">ImageConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0020.html">any_image_view</a></td><td class="indexvalue">Represents a run-time specified image view. Models <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>, Note that this class does NOT model <a class="el" href="g_i_l_0303.html">ImageViewConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0257.html">Assignable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0382.html">binary_operation_obj</a></td><td class="indexvalue">A generic binary operation on views<p>
Use this class as a convenience superclass when defining an operation for any image views. Many operations have different behavior when the two views are compatible. This class checks for compatibility and invokes apply_compatible(V1,V2) or apply_incompatible(V1,V2) of the subclass. You must provide apply_compatible(V1,V2) method in your subclass, but apply_incompatible(V1,V2) is not required and the default throws std::bad_cast </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0384.html">bit_aligned_image1_type</a></td><td class="indexvalue">Returns the type of a single-channel bit-aligned image given the bit size of its channel and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0386.html">bit_aligned_image2_type</a></td><td class="indexvalue">Returns the type of a two channel bit-aligned image given the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0388.html">bit_aligned_image3_type</a></td><td class="indexvalue">Returns the type of a three channel bit-aligned image given the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0390.html">bit_aligned_image4_type</a></td><td class="indexvalue">Returns the type of a four channel bit-aligned image given the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0392.html">bit_aligned_image5_type</a></td><td class="indexvalue">Returns the type of a five channel bit-aligned image given the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0394.html">bit_aligned_image_type</a></td><td class="indexvalue">Returns the type of a packed image whose pixels may not be byte aligned. For example, an "rgb222" image is bit-aligned because its pixel spans six bits </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0396.html">bit_aligned_pixel_iterator</a></td><td class="indexvalue">An iterator over non-byte-aligned pixels. Models <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0398.html">bit_aligned_pixel_reference</a></td><td class="indexvalue">Heterogeneous pixel reference corresponding to non-byte-aligned bit range. Models <a class="el" href="g_i_l_0269.html">ColorBaseConcept</a>, <a class="el" href="g_i_l_0341.html">PixelConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0399.html">black_t</a></td><td class="indexvalue">Black </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0400.html">blue_t</a></td><td class="indexvalue">Blue </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0401.html">byte_to_memunit</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0403.html">channel_converter</a></td><td class="indexvalue">A unary function object converting between channel types </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0407.html">channel_converter_unsigned&lt; bits32, bits32f &gt;</a></td><td class="indexvalue">32 bit &lt;-&gt; float channel conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0411.html">channel_converter_unsigned&lt; bits32f, bits32 &gt;</a></td><td class="indexvalue">32 bit &lt;-&gt; float channel conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0409.html">channel_converter_unsigned&lt; bits32f, DstChannelV &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0405.html">channel_converter_unsigned&lt; T, T &gt;</a></td><td class="indexvalue">Converting a channel to itself - identity operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0471.html">channel_converter_unsigned_impl</a></td><td class="indexvalue">This is the default implementation. Performance specializatons are provided </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0413.html">channel_mapping_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0415.html">channel_multiplier</a></td><td class="indexvalue">A function object to multiply two channels. result = a * b / max_value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0417.html">channel_multiplier_unsigned</a></td><td class="indexvalue">This is the default implementation. Performance specializatons are provided </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0419.html">channel_multiplier_unsigned&lt; bits16 &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for 16-bit unsigned channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0421.html">channel_multiplier_unsigned&lt; bits32f &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for float 0..1 channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0423.html">channel_multiplier_unsigned&lt; bits8 &gt;</a></td><td class="indexvalue">Specialization of channel_multiply for 8-bit unsigned channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0424.html">channel_traits</a></td><td class="indexvalue">Traits for channels. Contains the following members: </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0426.html">channel_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0259.html">ChannelConcept</a></td><td class="indexvalue">A channel is the building block of a color. Color is defined as a mixture of primary colors and a channel defines the degree to which each primary color is used in the mixture </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0261.html">ChannelConvertibleConcept</a></td><td class="indexvalue">A channel is convertible to another one if the <code>channel_convert</code> algorithm is defined for the two channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0263.html">ChannelMappingConcept</a></td><td class="indexvalue">Channel mapping concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0427.html">channels_are_compatible</a></td><td class="indexvalue">Predicate metafunction returning whether two channels are compatible<p>
Channels are considered compatible if their value types (ignoring constness and references) are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0267.html">ChannelsCompatibleConcept</a></td><td class="indexvalue">Channels are compatible if their associated value types (ignoring constness and references) are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0265.html">ChannelValueConcept</a></td><td class="indexvalue">A channel that supports default construction </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0022.html">color_convert_deref_fn</a></td><td class="indexvalue">Function object that given a source pixel, returns it converted to a given color space and channel depth. Models: <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0428.html">color_converted_view_type</a></td><td class="indexvalue">Returns the type of a view that does color conversion upon dereferencing its pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0432.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP &gt;</a></td><td class="indexvalue">Returns the type of a runtime-specified view, color-converted to a given pixel type with the default coor converter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0430.html">color_converted_view_type&lt; any_image_view&lt; ViewTypes &gt;, DstP, CC &gt;</a></td><td class="indexvalue">Returns the type of a runtime-specified view, color-converted to a given pixel type with user specified color converter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0434.html">color_element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant element accessor by color name, get_color(color_base, Color()); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0436.html">color_element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable element accessor by color name, get_color(color_base, Color()); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0438.html">color_element_type</a></td><td class="indexvalue">Specifies the type of the element associated with a given color tag </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0440.html">color_space_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0269.html">ColorBaseConcept</a></td><td class="indexvalue">A color base is a container of color elements (such as channels, channel references or channel pointers) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0273.html">ColorBasesCompatibleConcept</a></td><td class="indexvalue">Two color bases are compatible if they have the same color space and their elements are compatible, semantic-pairwise </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0271.html">ColorBaseValueConcept</a></td><td class="indexvalue">Color base that also has a default-constructor. Refines <a class="el" href="g_i_l_0371.html">Regular</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0275.html">ColorSpaceConcept</a></td><td class="indexvalue">Color space type concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0277.html">ColorSpacesCompatibleConcept</a></td><td class="indexvalue">Two color spaces are compatible if they are the same </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0441.html">contains_color</a></td><td class="indexvalue">A predicate metafunction determining whether a given color base contains a given color </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0473.html">copier_n</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0475.html">copier_n&lt; I, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">Destination range is delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0479.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="indexvalue">Both source and destination ranges are delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0477.html">copier_n&lt; iterator_from_2d&lt; IL &gt;, O &gt;</a></td><td class="indexvalue">Source range is delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0279.html">CopyConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0442.html">cyan_t</a></td><td class="indexvalue">Cyan </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0481.html">dec</a></td><td class="indexvalue">Operator-- wrapped in a function object </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0444.html">default_channel_converter</a></td><td class="indexvalue">Same as <a class="el" href="g_i_l_0403.html">channel_converter</a>, except it takes the destination channel by reference, which allows us to move the templates from the class level to the method level. This is important when invoking it on heterogeneous pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0446.html">default_color_converter</a></td><td class="indexvalue">Class for color-converting one pixel to another </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0447.html">default_color_converter_impl</a></td><td class="indexvalue">Color Convertion function object. To be specialized for every src/dst color space </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0451.html">default_color_converter_impl&lt; C, C &gt;</a></td><td class="indexvalue">When the color space is the same, color convertion performs channel depth conversion </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0449.html">default_color_converter_impl&lt; C1, rgba_t &gt;</a></td><td class="indexvalue">Converting any pixel type to RGBA. Note: Supports homogeneous pixels only </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0453.html">default_color_converter_impl&lt; cmyk_t, gray_t &gt;</a></td><td class="indexvalue">CMYK to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0455.html">default_color_converter_impl&lt; cmyk_t, rgb_t &gt;</a></td><td class="indexvalue">CMYK to RGB (not the fastest code in the world) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0457.html">default_color_converter_impl&lt; gray_t, cmyk_t &gt;</a></td><td class="indexvalue">Gray to CMYK </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0459.html">default_color_converter_impl&lt; gray_t, rgb_t &gt;</a></td><td class="indexvalue">Gray to RGB </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0461.html">default_color_converter_impl&lt; rgb_t, cmyk_t &gt;</a></td><td class="indexvalue">RGB to CMYK (not the fastest code in the world) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0463.html">default_color_converter_impl&lt; rgb_t, gray_t &gt;</a></td><td class="indexvalue">RGB to Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0465.html">default_color_converter_impl&lt; rgba_t, C2 &gt;</a></td><td class="indexvalue">Converting RGBA to any pixel type. Note: Supports homogeneous pixels only </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0467.html">default_color_converter_impl&lt; rgba_t, rgba_t &gt;</a></td><td class="indexvalue">Unfortunately RGBA to RGBA must be explicitly provided - otherwise we get ambiguous specialization error </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0281.html">DefaultConstructible</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0469.html">deref_base</a></td><td class="indexvalue">Helper base class for pixel dereference adaptors </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0024.html">deref_compose</a></td><td class="indexvalue">Composes two dereference function objects. Similar to std::unary_compose but needs to pull some typedefs from the component types. Models: <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0026.html">dereference_iterator_adaptor</a></td><td class="indexvalue">An adaptor over an existing iterator that provides for custom filter on dereferencing the object. Models: <a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0028.html">derived_image_type</a></td><td class="indexvalue">Constructs a homogeneous image type from a source image type by changing some of the properties.<p>
Use use_default for the properties of the source image that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0030.html">derived_iterator_type</a></td><td class="indexvalue">Constructs a pixel iterator type from a source pixel iterator type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0032.html">derived_pixel_reference_type</a></td><td class="indexvalue">Constructs a pixel reference type from a source pixel reference type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0034.html">derived_view_type</a></td><td class="indexvalue">Constructs an image view type from a source view type by changing some of the properties.<p>
Use use_default for the properties of the source view that you want to keep </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0517.html">devicen_color_t</a></td><td class="indexvalue">Unnamed color </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0519.html">devicen_layout_t</a></td><td class="indexvalue">Unnamed color layout of up to five channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0520.html">devicen_t&lt; 1 &gt;</a></td><td class="indexvalue">Unnamed color space of one channel </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0521.html">devicen_t&lt; 2 &gt;</a></td><td class="indexvalue">Unnamed color space of two channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0522.html">devicen_t&lt; 3 &gt;</a></td><td class="indexvalue">Unnamed color space of three channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0523.html">devicen_t&lt; 4 &gt;</a></td><td class="indexvalue">Unnamed color space of four channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0524.html">devicen_t&lt; 5 &gt;</a></td><td class="indexvalue">Unnamed color space of five channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0525.html">dynamic_xy_step_transposed_type</a></td><td class="indexvalue">Returns the type of a transposed view that has a dynamic step along both X and Y </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0526.html">dynamic_xy_step_type</a></td><td class="indexvalue">Returns the type of a view that has a dynamic step along both X and Y </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0527.html">element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant element accessor at_c of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0528.html">element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable element accessor at_c of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0529.html">element_type</a></td><td class="indexvalue">Specifies the element type of a homogeneous color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0487.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc &gt;, I2 &gt;</a></td><td class="indexvalue">Source range is delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0485.html">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc1 &gt;, boost::gil::iterator_from_2d&lt; Loc2 &gt; &gt;</a></td><td class="indexvalue">Both source and destination ranges are delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0489.html">equal_n_fn&lt; const pixel&lt; T, Cs &gt; *, const pixel&lt; T, Cs &gt; * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0483.html">equal_n_fn&lt; I1, boost::gil::iterator_from_2d&lt; Loc &gt; &gt;</a></td><td class="indexvalue">Destination range is delimited by image iterators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0491.html">equal_n_fn&lt; planar_pixel_iterator&lt; IC, Cs &gt;, planar_pixel_iterator&lt; IC, Cs &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0283.html">EqualityComparable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0530.html">gray_color_t</a></td><td class="indexvalue">Gray </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0531.html">green_t</a></td><td class="indexvalue">Green </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a></td><td class="indexvalue">Concept for iterators, locators and views that can define a type just like the given iterator/locator/view, except it supports runtime specified step along the X navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a></td><td class="indexvalue">Concept for locators and views that can define a type just like the given locator or view, except it supports runtime specified step along the Y navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a></td><td class="indexvalue">Concept for locators and views that can define a type just like the given locator or view, except X and Y is swapped </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0493.html">homogeneous_color_base&lt; Element, Layout, 1 &gt;</a></td><td class="indexvalue">A homogeneous color base holding one color element. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0495.html">homogeneous_color_base&lt; Element, Layout, 2 &gt;</a></td><td class="indexvalue">A homogeneous color base holding two color elements. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0497.html">homogeneous_color_base&lt; Element, Layout, 3 &gt;</a></td><td class="indexvalue">A homogeneous color base holding three color elements. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0499.html">homogeneous_color_base&lt; Element, Layout, 4 &gt;</a></td><td class="indexvalue">A homogeneous color base holding four color elements. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0501.html">homogeneous_color_base&lt; Element, Layout, 5 &gt;</a></td><td class="indexvalue">A homogeneous color base holding five color elements. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a> or <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a></td><td class="indexvalue">Color base whose elements all have the same type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a></td><td class="indexvalue">Homogeneous color base that also has a default constructor. Refines <a class="el" href="g_i_l_0371.html">Regular</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a></td><td class="indexvalue">Concept for homogeneous pixel-based GIL constructs </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0297.html">HomogeneousPixelConcept</a></td><td class="indexvalue">Homogeneous pixel concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0299.html">HomogeneousPixelValueConcept</a></td><td class="indexvalue">Homogeneous pixel concept that is a <a class="el" href="g_i_l_0371.html">Regular</a> type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0503.html">identity</a></td><td class="indexvalue">Identity taken from SGI STL </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0038.html">image</a></td><td class="indexvalue">Container interface over image view. Models <a class="el" href="g_i_l_0301.html">ImageConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0532.html">image_is_basic</a></td><td class="indexvalue">Basic images must use basic views and std::allocator of char </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0534.html">image_type</a></td><td class="indexvalue">Returns the type of a homogeneous image given the channel type, layout, and whether it operates on planar data </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0040.html">image_view</a></td><td class="indexvalue">A lightweight object that interprets memory as a 2D array of pixels. Models <a class="el" href="g_i_l_0303.html">ImageViewConcept</a>,<a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>,<a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0301.html">ImageConcept</a></td><td class="indexvalue">2-dimensional image whose value type models <a class="el" href="g_i_l_0351.html">PixelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0303.html">ImageViewConcept</a></td><td class="indexvalue">GIL's 2-dimensional view over immutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0505.html">inc</a></td><td class="indexvalue">Operator++ wrapped in a function object </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0535.html">is_iterator_adaptor</a></td><td class="indexvalue"><a class="el" href="g_i_l_0309.html">Metafunction</a> predicate determining whether the given iterator is a plain one or an adaptor over another iterator. Examples of adaptors are the step iterator and the dereference iterator adaptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0536.html">is_pixel&lt; bit_aligned_pixel_reference&lt; C, L, M &gt; &gt;</a></td><td class="indexvalue"><a class="el" href="g_i_l_0309.html">Metafunction</a> predicate that flags <a class="el" href="g_i_l_0398.html">bit_aligned_pixel_reference</a> as a model of <a class="el" href="g_i_l_0341.html">PixelConcept</a>. Required by <a class="el" href="g_i_l_0341.html">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0537.html">is_pixel&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue"><a class="el" href="g_i_l_0309.html">Metafunction</a> predicate that flags <a class="el" href="g_i_l_0605.html">planar_pixel_reference</a> as a model of <a class="el" href="g_i_l_0341.html">PixelConcept</a>. Required by <a class="el" href="g_i_l_0341.html">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0538.html">is_planar&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="indexvalue">Specifies that <a class="el" href="g_i_l_0605.html">planar_pixel_reference</a> represents a planar construct. Required by <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0540.html">iterator_add_deref</a></td><td class="indexvalue">Returns the type (and creates an instance) of an iterator that invokes the given dereference adaptor upon dereferencing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0542.html">iterator_add_deref&lt; dereference_iterator_adaptor&lt; Iterator, PREV_DEREF &gt;, Deref &gt;</a></td><td class="indexvalue">For dereference iterator adaptors, compose the new function object after the old one </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0042.html">iterator_from_2d</a></td><td class="indexvalue">Provides 1D random-access navigation to the pixels of the image. Models: <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0543.html">iterator_is_basic</a></td><td class="indexvalue">Determines if a given pixel iterator is basic Basic iterators must use <a class="el" href="g_i_l_0593.html">gil::pixel</a> (if interleaved), <a class="el" href="g_i_l_0603.html">gil::planar_pixel_iterator</a> (if planar) and <a class="el" href="g_i_l_0046.html">gil::memory_based_step_iterator</a> (if step). They must use the standard constness rules </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0544.html">iterator_is_mutable</a></td><td class="indexvalue"><a class="el" href="g_i_l_0309.html">Metafunction</a> predicate returning whether the given iterator allows for changing its values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0545.html">iterator_is_step</a></td><td class="indexvalue">Determines if the given iterator has a step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0546.html">iterator_type</a></td><td class="indexvalue">Returns the type of a homogeneous iterator given the channel type, layout, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0547.html">iterator_type_from_pixel</a></td><td class="indexvalue">Returns the type of a pixel iterator given the pixel type, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a></td><td class="indexvalue">Iterator adaptor is a forward iterator adapting another forward iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0549.html">jpeg_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0551.html">jpeg_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0507.html">kth_channel_deref_fn</a></td><td class="indexvalue">Function object that returns a grayscale reference of the K-th channel (specified as a template parameter) of a given reference. Models: <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a>.<p>
If the input is a pixel value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the k-th channel) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0553.html">kth_channel_view_type</a></td><td class="indexvalue">Given a source image view type View, returns the type of an image view over a given channel of View.<p>
If the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0555.html">kth_semantic_element_const_reference_type</a></td><td class="indexvalue">Specifies the return type of the constant semantic_at_c&lt;K&gt;(color_base); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0557.html">kth_semantic_element_reference_type</a></td><td class="indexvalue">Specifies the return type of the mutable semantic_at_c&lt;K&gt;(color_base); </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0559.html">kth_semantic_element_type</a></td><td class="indexvalue">Specifies the type of the K-th semantic element of a color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0561.html">layout</a></td><td class="indexvalue">Represents a color space and ordering of channels in memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0562.html">locator_is_basic</a></td><td class="indexvalue">Determines if a given locator is basic. A basic locator is memory-based and has basic x_iterator and y_iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0563.html">locator_is_mutable</a></td><td class="indexvalue">Determines if the given locator is mutable (i.e. its pixels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0564.html">locator_is_step_in_x</a></td><td class="indexvalue">Determines if the given locator has a horizontal step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0565.html">locator_is_step_in_y</a></td><td class="indexvalue">Determines if the given locator has a vertical step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0567.html">locator_type</a></td><td class="indexvalue">Returns the type of a homogeneous locator given the channel type, layout, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0568.html">magenta_t</a></td><td class="indexvalue">Magenta </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0044.html">memory_based_2d_locator</a></td><td class="indexvalue">Memory-based pixel locator. Models: <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a>,<a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>,<a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>,<a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a><p>
The class takes a step iterator as a parameter. The step iterator provides navigation along the vertical axis while its base iterator provides horizontal navigation </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0046.html">memory_based_step_iterator</a></td><td class="indexvalue">Iterator with dynamically specified step in memory units (bytes or bits). Models <a class="el" href="g_i_l_0375.html">StepIteratorConcept</a>, <a class="el" href="g_i_l_0305.html">IteratorAdaptorConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a></td><td class="indexvalue">Concept of a random-access iterator that can be advanced in memory units (bytes or bits) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0570.html">memunit_step_fn</a></td><td class="indexvalue">Function object that returns the memory unit distance between two iterators and advances a given iterator a given number of mem units (bytes or bits) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0309.html">Metafunction</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0311.html">MutableChannelConcept</a></td><td class="indexvalue">A channel that allows for modifying its value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0313.html">MutableColorBaseConcept</a></td><td class="indexvalue">Color base which allows for modifying its elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0315.html">MutableHomogeneousColorBaseConcept</a></td><td class="indexvalue">Homogeneous color base that allows for modifying its elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0317.html">MutableHomogeneousPixelConcept</a></td><td class="indexvalue">Homogeneous pixel concept that allows for changing its channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0319.html">MutableImageViewConcept</a></td><td class="indexvalue">GIL's 2-dimensional view over mutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0321.html">MutableIteratorAdaptorConcept</a></td><td class="indexvalue">Iterator adaptor that is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0323.html">MutablePixelConcept</a></td><td class="indexvalue">Pixel concept that allows for changing its channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0325.html">MutablePixelIteratorConcept</a></td><td class="indexvalue">Pixel iterator that allows for changing its pixel </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0327.html">MutablePixelLocatorConcept</a></td><td class="indexvalue">GIL's 2-dimensional locator over mutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0329.html">MutableRandomAccess2DImageViewConcept</a></td><td class="indexvalue">2-dimensional view over mutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0331.html">MutableRandomAccess2DLocatorConcept</a></td><td class="indexvalue">2-dimensional locator over mutable pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0333.html">MutableRandomAccessNDImageViewConcept</a></td><td class="indexvalue">N-dimensional view over mutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0335.html">MutableRandomAccessNDLocatorConcept</a></td><td class="indexvalue">N-dimensional locator over mutable pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0337.html">MutableStepIteratorConcept</a></td><td class="indexvalue">Step iterator that allows for modifying its current value </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0509.html">nth_channel_deref_fn</a></td><td class="indexvalue">Function object that returns a grayscale reference of the N-th channel of a given reference. Models: <a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a>.<p>
If the input is a pixel value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the n-th channel) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0572.html">nth_channel_view_type</a></td><td class="indexvalue">Given a source image view type View, returns the type of an image view over a single channel of View<p>
If the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0574.html">nth_channel_view_type&lt; any_image_view&lt; ViewTypes &gt; &gt;</a></td><td class="indexvalue">Given a runtime source image view, returns the type of a runtime image view over a single channel of the source view </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0575.html">num_channels</a></td><td class="indexvalue">Returns the number of channels of a pixel-based GIL construct </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0048.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, false &gt;</a></td><td class="indexvalue">A constant subbyte channel reference whose bit offset is fixed at compile time. Models <a class="el" href="g_i_l_0259.html">ChannelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0050.html">packed_channel_reference&lt; BitField, FirstBit, NumBits, true &gt;</a></td><td class="indexvalue">A mutable subbyte channel reference whose bit offset is fixed at compile time. Models <a class="el" href="g_i_l_0259.html">ChannelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0052.html">packed_channel_value</a></td><td class="indexvalue">The value of a subbyte channel. Models: <a class="el" href="g_i_l_0265.html">ChannelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0054.html">packed_dynamic_channel_reference&lt; BitField, NumBits, false &gt;</a></td><td class="indexvalue">Models a constant subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="g_i_l_0259.html">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0056.html">packed_dynamic_channel_reference&lt; BitField, NumBits, true &gt;</a></td><td class="indexvalue">Models a mutable subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="g_i_l_0259.html">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0577.html">packed_image1_type</a></td><td class="indexvalue">Returns the type of a single-channel image given its bitfield type, the bit size of its channel and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0579.html">packed_image2_type</a></td><td class="indexvalue">Returns the type of a two channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0581.html">packed_image3_type</a></td><td class="indexvalue">Returns the type of a three channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0583.html">packed_image4_type</a></td><td class="indexvalue">Returns the type of a four channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0585.html">packed_image5_type</a></td><td class="indexvalue">Returns the type of a five channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0587.html">packed_image_type</a></td><td class="indexvalue">Returns the type of an interleaved packed image: an image whose channels may not be byte-aligned, but whose pixels are byte aligned </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0589.html">packed_pixel</a></td><td class="indexvalue">Heterogeneous pixel value whose channel references can be constructed from the pixel bitfield and their index. Models <a class="el" href="g_i_l_0271.html">ColorBaseValueConcept</a>, <a class="el" href="g_i_l_0351.html">PixelValueConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a> Typical use for this is a model of a packed pixel (like 565 RGB) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0591.html">packed_pixel_type</a></td><td class="indexvalue">Returns the type of a packed pixel given its bitfield type, the bit size of its channels and its layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0593.html">pixel</a></td><td class="indexvalue">Represents a pixel value (a container of channels). Models: <a class="el" href="g_i_l_0293.html">HomogeneousColorBaseValueConcept</a>, <a class="el" href="g_i_l_0351.html">PixelValueConcept</a>, <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0058.html">pixel_2d_locator_base</a></td><td class="indexvalue">Base class for models of <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a><p>
Pixel locator is similar to a pixel iterator, but allows for 2D navigation of pixels within an image view. It has a 2D difference_type and supports random access operations like: </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0594.html">pixel_is_reference</a></td><td class="indexvalue">Given a model of a pixel, determines whether the model represents a pixel reference (as opposed to pixel value) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0595.html">pixel_reference_is_basic</a></td><td class="indexvalue">Determines if a given pixel reference is basic Basic references must use <a class="el" href="g_i_l_0593.html">gil::pixel</a>&amp; (if interleaved), <a class="el" href="g_i_l_0605.html">gil::planar_pixel_reference</a> (if planar). They must use the standard constness rules </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0596.html">pixel_reference_is_mutable</a></td><td class="indexvalue">Determines if the given pixel reference is mutable (i.e. its channels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0597.html">pixel_reference_is_proxy</a></td><td class="indexvalue">Determines whether the given pixel reference is a proxy class or a native C++ reference </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0598.html">pixel_reference_type</a></td><td class="indexvalue">Returns the type of a homogeneous pixel reference given the channel type, layout, whether it operates on planar data and whether it is mutable </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0600.html">pixel_value_type</a></td><td class="indexvalue">Returns the type of a homogeneous pixel given the channel type and layout </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0339.html">PixelBasedConcept</a></td><td class="indexvalue">Concept for all pixel-based GIL constructs, such as pixels, iterators, locators, views and images whose value type is a pixel </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0341.html">PixelConcept</a></td><td class="indexvalue">Pixel concept - A color base whose elements are channels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0343.html">PixelConvertibleConcept</a></td><td class="indexvalue">Pixel convertible concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0345.html">PixelDereferenceAdaptorConcept</a></td><td class="indexvalue">Represents a unary function object that can be invoked upon dereferencing a pixel iterator </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a></td><td class="indexvalue">An STL random access traversal iterator over a model of <a class="el" href="g_i_l_0341.html">PixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a></td><td class="indexvalue">GIL's 2-dimensional locator over immutable GIL pixels </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0601.html">pixels_are_compatible</a></td><td class="indexvalue">Returns whether two pixels are compatible </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0353.html">PixelsCompatibleConcept</a></td><td class="indexvalue">Concept for pixel compatibility Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0351.html">PixelValueConcept</a></td><td class="indexvalue">Pixel concept that is a <a class="el" href="g_i_l_0371.html">Regular</a> type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0603.html">planar_pixel_iterator</a></td><td class="indexvalue">An iterator over planar pixels. Models <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0295.html">HomogeneousPixelBasedConcept</a>, <a class="el" href="g_i_l_0307.html">MemoryBasedIteratorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0605.html">planar_pixel_reference</a></td><td class="indexvalue">A reference proxy to a planar pixel. Models: <a class="el" href="g_i_l_0291.html">HomogeneousColorBaseConcept</a>, <a class="el" href="g_i_l_0297.html">HomogeneousPixelConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0511.html">plus_asymmetric</a></td><td class="indexvalue">Plus function object whose arguments may be of different type </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0607.html">png_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0609.html">png_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0060.html">point2</a></td><td class="indexvalue">2D point both axes of which have the same dimension type<p>
Models: <a class="el" href="g_i_l_0355.html">Point2DConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0355.html">Point2DConcept</a></td><td class="indexvalue">2-dimensional point concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0357.html">PointNDConcept</a></td><td class="indexvalue">N-dimensional point concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0611.html">position_iterator</a></td><td class="indexvalue">An iterator that remembers its current X,Y position and invokes a function object with it upon dereferencing. Models <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>. Used to create virtual image views. Models: <a class="el" href="g_i_l_0375.html">StepIteratorConcept</a>, <a class="el" href="g_i_l_0347.html">PixelIteratorConcept</a>, <a class="el" href="g_i_l_0339.html">PixelBasedConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0359.html">RandomAccess2DImageConcept</a></td><td class="indexvalue">2-dimensional container of values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0361.html">RandomAccess2DImageViewConcept</a></td><td class="indexvalue">2-dimensional view over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0363.html">RandomAccess2DLocatorConcept</a></td><td class="indexvalue">2-dimensional locator over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0365.html">RandomAccessNDImageConcept</a></td><td class="indexvalue">N-dimensional container of values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0367.html">RandomAccessNDImageViewConcept</a></td><td class="indexvalue">N-dimensional view over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0369.html">RandomAccessNDLocatorConcept</a></td><td class="indexvalue">N-dimensional locator over immutable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0612.html">red_t</a></td><td class="indexvalue">Red </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0371.html">Regular</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0513.html">rgb_to_luminance_fn</a></td><td class="indexvalue">Red * .3 + green * .59 + blue * .11 + .5 </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0373.html">SameType</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0614.html">scoped_channel_value</a></td><td class="indexvalue">A channel adaptor that modifies the range of the source channel. Models: <a class="el" href="g_i_l_0265.html">ChannelValueConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0615.html">size</a></td><td class="indexvalue">Returns an MPL integral type specifying the number of elements in a color base </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0515.html">std_fill_t</a></td><td class="indexvalue">Struct to do <a class="el" href="g_i_l_0209.html#ga4">std::fill</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0036.html">step_iterator_adaptor</a></td><td class="indexvalue">An adaptor over an existing iterator that changes the step unit </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0375.html">StepIteratorConcept</a></td><td class="indexvalue">Step iterator concept </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0377.html">Swappable</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0617.html">tiff_read_support</a></td><td class="indexvalue">Determines whether the given view type is supported for reading </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0619.html">tiff_write_support</a></td><td class="indexvalue">Determines whether the given view type is supported for writing </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0621.html">type_from_x_iterator</a></td><td class="indexvalue">Given a pixel iterator defining access to pixels along a row, returns the types of the corresponding built-in step_iterator, xy_locator, <a class="el" href="g_i_l_0040.html">image_view</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0516.html">type_to_index</a></td><td class="indexvalue">Returns the index corresponding to the first occurrance of a given given type in </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0062.html">variant</a></td><td class="indexvalue">Represents a concrete instance of a run-time specified type from a set of types<p>
A concept is typically modeled by a collection of different types. They may be instantiations of a templated type with different template parameters or even completely unrelated types </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0622.html">view_is_basic</a></td><td class="indexvalue">Basic views must be over basic locators </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0623.html">view_is_mutable</a></td><td class="indexvalue">Determines if the given view is mutable (i.e. its pixels can be changed) </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0624.html">view_is_step_in_x</a></td><td class="indexvalue">Determines if the given view has a horizontal step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0625.html">view_is_step_in_y</a></td><td class="indexvalue">Determines if the given view has a vertical step that could be set dynamically </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0627.html">view_type</a></td><td class="indexvalue">Returns the type of a homogeneous view given the channel type, layout, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0629.html">view_type_from_pixel</a></td><td class="indexvalue">Returns the type of a view the pixel type, whether it operates on planar data and whether it has a step horizontally </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0630.html">views_are_compatible</a></td><td class="indexvalue">Returns whether two views are compatible </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0379.html">ViewsCompatibleConcept</a></td><td class="indexvalue">Views are compatible if they have the same color spaces and compatible channel values. Constness and layout are not important for compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0064.html">virtual_2d_locator</a></td><td class="indexvalue">A 2D locator over a virtual image. Upon dereferencing, invokes a given function object passing it its coordinates. Models: <a class="el" href="g_i_l_0349.html">PixelLocatorConcept</a>, <a class="el" href="g_i_l_0285.html">HasDynamicXStepTypeConcept</a>, <a class="el" href="g_i_l_0287.html">HasDynamicYStepTypeConcept</a>, <a class="el" href="g_i_l_0289.html">HasTransposedTypeConcept</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="g_i_l_0631.html">yellow_t</a></td><td class="indexvalue">Yellow </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Nov 8 21:53:19 2007 for Generic Image Library   by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>

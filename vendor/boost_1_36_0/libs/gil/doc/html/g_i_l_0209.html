<!-- Copyright 2008 Lubomir Bourdev and Hailin Jin
  --
  -- Distributed under the Boost Software License, Version 1.0.
  -- (See accompanying file LICENSE_1_0.txt or copy at
  -- http://www.boost.org/LICENSE_1_0.txt)
  --
  -->

<!--
    Copyright 2005-2007 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://opensource.adobe.com/licenses.html" for more information.
-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
    <TITLE>Generic Image Library  : Performance overloads of STL algorithms</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
</head>
<body>
<table border="0" cellspacing="0" cellpadding="0" style='width: 100%; margin: 0; padding: 0'><tr>
<td width="100%" valign="top" style='padding-left: 10px; padding-right: 10px; padding-bottom: 10px'>
<div class="qindex"><a class="qindex" href="index.html">Modules</a> 
                  | <a class="qindex" href="classes.html">Alphabetical List</a> 
                  | <a class="qindex" href="annotated.html">Class List</a> 
                  | <a class="qindex" href="dirs.html">Directories</a> 
                  | <a class="qindex" href="files.html">File List</a> 
                  | <a class="qindex" href="globals.html">File Members</a> 
                  | <a class="qindex" href="../index.html">GIL Home Page</a> 
</div>
<!-- End Header -->
<!-- Generated by Doxygen 1.4.4 -->
<h1>Performance overloads of STL algorithms<br>
<small>
[<a class="el" href="g_i_l_0133.html">Algorithms and Utility Functions</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
overloads of STL algorithms allowing more efficient implementation when used with GIL constructs 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga0"></a><!-- doxytag: member="STLOptimizations::copy" ref="ga0" args="(boost::gil::pixel&lt; T, Cs &gt; *first, boost::gil::pixel&lt; T, Cs &gt; *last, boost::gil::pixel&lt; T, Cs &gt; *dst)" -->
template&lt;typename T, typename Cs&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt;<br>
 T, Cs &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga0">std::copy</a> (<a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *first, <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *last, <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga1"></a><!-- doxytag: member="STLOptimizations::copy" ref="ga1" args="(const boost::gil::pixel&lt; T, Cs &gt; *first, const boost::gil::pixel&lt; T, Cs &gt; *last, boost::gil::pixel&lt; T, Cs &gt; *dst)" -->
template&lt;typename T, typename Cs&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt;<br>
 T, Cs &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga1">std::copy</a> (const <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *first, const <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *last, <a class="el" href="g_i_l_0593.html">boost::gil::pixel</a>&lt; T, Cs &gt; *dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga2"></a><!-- doxytag: member="STLOptimizations::copy" ref="ga2" args="(boost::gil::planar_pixel_iterator&lt; IC1, Cs &gt; first, boost::gil::planar_pixel_iterator&lt; IC1, Cs &gt; last, boost::gil::planar_pixel_iterator&lt; IC2, Cs &gt; dst)" -->
template&lt;typename Cs, typename IC1, typename IC2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <a class="el" href="g_i_l_0603.html">boost::gil::planar_pixel_iterator</a>&lt;<br>
 IC2, Cs &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga2">std::copy</a> (<a class="el" href="g_i_l_0603.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, Cs &gt; first, <a class="el" href="g_i_l_0603.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, Cs &gt; last, <a class="el" href="g_i_l_0603.html">boost::gil::planar_pixel_iterator</a>&lt; IC2, Cs &gt; dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy when both src and dst are planar pointers is copy for each channel. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga3"></a><!-- doxytag: member="STLOptimizations::copy1" ref="ga3" args="(boost::gil::iterator_from_2d&lt; IL &gt; first, boost::gil::iterator_from_2d&lt; IL &gt; last, boost::gil::iterator_from_2d&lt; OL &gt; dst)" -->
template&lt;typename IL, typename OL&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt;<br>
 OL &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga3">std::copy1</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; OL &gt; dst)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::copy(I1,I1,I2) with I1 and I2 being a iterator_from_2d <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IL, typename V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga4">std::fill</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, const V &amp;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::fill(I,I,V) with I being a iterator_from_2d  <a href="#ga4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Loc1, typename Loc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GIL_FORCEINLINE bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="g_i_l_0209.html#ga5">std::equal</a> (<a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; first, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; last, <a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt; first2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d  <a href="#ga5"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga5"></a><!-- doxytag: member="std::equal" ref="ga5" args="(boost::gil::iterator_from_2d&lt; Loc1 &gt; first, boost::gil::iterator_from_2d&lt; Loc1 &gt; last, boost::gil::iterator_from_2d&lt; Loc2 &gt; first2)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">GIL_FORCEINLINE bool std::equal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>first2</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d 
<p>
Invoked when one calls std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d (which is a 1D iterator over the pixels in an image). Attempts to demote the source and destination iterators to simpler/faster types if the corresponding range is contiguous. For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. If the underlying pixel iterator happens to be a fundamental planar/interleaved pointer, the call may further resolve to memcmp. Otherwise it resolves to copying each row using the underlying pixel iterator     </td>
  </tr>
</table>
<a class="anchor" name="ga4"></a><!-- doxytag: member="std::fill" ref="ga4" args="(boost::gil::iterator_from_2d&lt; IL &gt; first, boost::gil::iterator_from_2d&lt; IL &gt; last, const V &amp;val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void std::fill           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="g_i_l_0042.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const V &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
std::fill(I,I,V) with I being a iterator_from_2d 
<p>
Invoked when one calls std::fill(I,I,V) with I being a iterator_from_2d (which is a 1D iterator over the pixels in an image). For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. For non-contiguous images fill resolves to fill of each row using the underlying pixel iterator, which is still faster     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Nov 8 21:53:20 2007 for Generic Image Library   by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>

<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_interprocess_reference"><title>Boost.Interprocess Reference</title><header name="boost/interprocess/allocators/adaptive_pool.hpp"><para>Describes adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of adaptive_pool with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains adaptive_pool from adaptive_pool </para></description><typedef name="other"><type><classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related adaptive_pool </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Not assignable from other adaptive_pool Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other adaptive_pool. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related adaptive_pool. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of adaptive_pool </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of adaptive_pool </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/allocation_type.hpp"><namespace name="boost"><namespace name="interprocess"><data-member name="allocate_new" specifiers="static"><type>const allocation_type</type></data-member><data-member name="expand_fwd" specifiers="static"><type>const allocation_type</type></data-member><data-member name="expand_bwd" specifiers="static"><type>const allocation_type</type></data-member><data-member name="shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member><data-member name="try_shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member><data-member name="nothrow_allocation" specifiers="static"><type>const allocation_type</type></data-member><data-member name="zero_memory" specifiers="static"><type>const allocation_type</type></data-member></namespace></namespace></header><header name="boost/interprocess/allocators/allocator.hpp"><para>Describes an allocator that allocates portions of fixed size memory buffer (shared memory, mapped file...) </para><namespace name="boost"><namespace name="interprocess"><class name="allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>An STL compatible allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an allocator that allocates objects of type T2 </para></description><typedef name="other"><type><classname>allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef></struct><typedef name="segment_manager"><type>SegmentManager</type></typedef><typedef name="void_pointer"><type>SegmentManager::void_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_pointer"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="version"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_ptr</paramtype><default>0</default></parameter><description><para>Allocates memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name=""><paramtype>size_type</paramtype></parameter><description><para>Deallocates memory previously allocated. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object Throws if T's copy constructor throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Default construct an object. Throws if T's default constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Constructor from the segment manager. Never throws </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other allocator. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>allocator</classname>&lt; T2, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Constructor from related allocator. Never throws </para></description></constructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of allocator </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of allocator </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/cached_adaptive_pool.hpp"><para>Describes cached_adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="cached_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of cached_adaptive_pool with equal sizeof(T) placed in the same memory segment. But also caches some nodes privately to avoid some synchronization overhead.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains cached_adaptive_pool from cached_adaptive_pool </para></description><typedef name="other"><type><classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related cached_adaptive_pool </para></description></copy-assignment><copy-assignment><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other cached_adaptive_pool </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="set_max_cached_nodes" cv=""><type>void</type><parameter name="newmax"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method><method name="get_max_cached_nodes" cv="const"><type>std::size_t</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other cached_adaptive_pool. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related cached_adaptive_pool. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of cached_adaptive_pool </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of cached_adaptive_pool </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/cached_node_allocator.hpp"><para>Describes cached_cached_node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="cached_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains cached_node_allocator from cached_node_allocator </para></description><typedef name="other"><type><classname>cached_node_allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related cached_node_allocator </para></description></copy-assignment><copy-assignment><parameter name=""><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other cached_node_allocator </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Default construct an object. Throws if T's default constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="set_max_cached_nodes" cv=""><type>void</type><parameter name="newmax"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method><method name="get_max_cached_nodes" cv="const"><type>std::size_t</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other cached_node_allocator. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related cached_node_allocator. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of cached_node_allocator </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of cached_node_allocator </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/node_allocator.hpp"><para>Describes node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This node allocator shares a segregated storage between all instances of node_allocator with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains node_allocator from node_allocator </para></description><typedef name="other"><type><classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related node_allocator </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Not assignable from other node_allocator Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other node_allocator. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related node_allocator. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of node_allocator </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of node_allocator </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/private_adaptive_pool.hpp"><para>Describes private_adaptive_pool_base pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="private_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains private_adaptive_pool from private_adaptive_pool </para></description><typedef name="other"><type><classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related private_adaptive_pool </para></description></copy-assignment><copy-assignment><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other private_adaptive_pool </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other private_adaptive_pool. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related private_adaptive_pool. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of private_adaptive_pool </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of private_adaptive_pool </para></description></function></namespace></namespace></header><header name="boost/interprocess/allocators/private_node_allocator.hpp"><para>Describes private_node_allocator_base pooled shared memory STL compatible allocator </para><namespace name="boost"><namespace name="interprocess"><class name="private_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains private_node_allocator from private_node_allocator </para></description><typedef name="other"><type><classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef></struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef><typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><method-group name="private member functions"/><copy-assignment><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related private_node_allocator </para></description></copy-assignment><copy-assignment><parameter name=""><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other private_node_allocator </para></description></copy-assignment><method-group name="public member functions"><method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method><method name="get_segment_manager" cv="const"><type><classname>segment_manager</classname> *</type><description><para>Returns the segment manager. Never throws </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method><method name="allocate" cv=""><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="deallocate" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method><method name="deallocate_free_blocks" cv=""><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method><method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method><method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method><method name="construct" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method><method name="destroy" cv=""><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method><method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; pointer, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="preferred_size"><paramtype>size_type</paramtype></parameter><parameter name="received_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_many" cv=""><type>multiallocation_iterator</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method><method name="deallocate_many" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method><method name="allocate_one" cv=""><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws boost::interprocess::bad_alloc if there is no enough memory </para></description></method><method name="allocate_individual" cv=""><type>multiallocation_iterator</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method><method name="deallocate_one" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method><method name="deallocate_individual" cv=""><type>void</type><parameter name="it"><paramtype>multiallocation_iterator</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager</classname> *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other private_node_allocator. Increments the reference count of the associated node pool. Never throws </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related private_node_allocator. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw boost::interprocess::bad_alloc </para></description></constructor><destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of private_node_allocator </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of private_node_allocator </para></description></function></namespace></namespace></header><header name="boost/interprocess/anonymous_shared_memory.hpp"><para>Describes a function that creates anonymous shared memory that can be shared between forked processes </para><namespace name="boost"><namespace name="interprocess"><function name="anonymous_shared_memory"><type><emphasis>unspecified</emphasis></type><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="address"><paramtype>void *</paramtype><default>0</default></parameter><description><para>A function that creates an anonymous shared memory segment of size "size". If "address" is passed the function will try to map the segment in that address. Otherwise the operating system will choose the mapping address. The function returns a mapped_region holding that segment or throws interprocess_exception if the function fails. </para></description></function></namespace></namespace></header><header name="boost/interprocess/containers/deque.hpp"><namespace name="boost"><namespace name="interprocess"><class name="deque"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>Deque class </para></description><typedef name="iterator"><type>Base::iterator</type></typedef><typedef name="const_iterator"><type>Base::const_iterator</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><method-group name="public member functions"><method name="get_allocator" cv="const"><type>allocator_type</type></method><method name="begin" cv=""><type>iterator</type></method><method name="end" cv=""><type>iterator</type></method><method name="begin" cv="const"><type>const_iterator</type></method><method name="end" cv="const"><type>const_iterator</type></method><method name="rbegin" cv=""><type>reverse_iterator</type></method><method name="rend" cv=""><type>reverse_iterator</type></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type></method><method name="rend" cv="const"><type>const_reverse_iterator</type></method><method name="operator[]" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method><method name="operator[]" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method><method name="priv_range_check" cv="const"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method><method name="at" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method><method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter></method><method name="front" cv=""><type>reference</type></method><method name="back" cv=""><type>reference</type></method><method name="front" cv="const"><type>const_reference</type></method><method name="back" cv="const"><type>const_reference</type></method><method name="size" cv="const"><type>size_type</type></method><method name="max_size" cv="const"><type>size_type</type></method><method name="empty" cv="const"><type>bool</type></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>deque</classname> &amp;</paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="assign" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter></method><method name="push_back" cv=""><type>void</type><parameter name="t"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="push_back" cv=""><type>void</type><parameter name="mt"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="push_front" cv=""><type>void</type><parameter name="t"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="push_front" cv=""><type>void</type><parameter name="mt"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="pop_back" cv=""><type>void</type></method><method name="pop_front" cv=""><type>void</type></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="insert" cv=""><type>void</type><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="pos"><paramtype>iterator</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter></method><method name="clear" cv=""><type>void</type></method></method-group><constructor><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><constructor><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter></constructor><constructor><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><destructor/><copy-assignment><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>deque</classname>&lt; T, Alloc &gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/flat_map.hpp"><namespace name="boost"><namespace name="interprocess"><class name="flat_map"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A flat_map is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys. The flat_map class supports random-access iterators.</para><para>A flat_map satisfies all of the requirements of a container and of a reversible container and of an associative container. A flat_map also provides most operations described for unique keys. For a flat_map&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;Key,T&gt; (unlike std::map&lt;Key, T&gt; which value_type is std::pair&lt;<emphasis role="bold">const</emphasis> Key, T&gt;).</para><para>Pred is the ordering function for Keys (e.g. std::less&lt;Key&gt;).</para><para>Alloc is the allocator to allocate the value_types (e.g. boost::interprocess:allocator&lt; std::pair&lt;Key, T&gt;).</para><para>flat_map is similar to std::map but it's implemented like an ordered vector. This means that inserting a new element into a flat_map invalidates previous iterators and references</para><para>Erasing an element of a flat_map invalidates iterators and references pointing to elements that come after (their keys are bigger) the erased element. </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="value_compare"><type>tree_t::value_compare</type></typedef><typedef name="mapped_type"><type>T</type></typedef><typedef name="key_compare"><type>tree_t::key_compare</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv=""><type>T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Effects: If there is no key equivalent to x in the flat_map, inserts value_type(detail::move_impl(x), T()) into the flat_map (the key is move-constructed)</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. Effects: If there is no key equivalent to x in the flat_map, inserts value_type(x, T()) into the flat_map.</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. </para></description></method><method name="operator[]" cv=""><type>T &amp;</type><parameter name="mk"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) search time plus N*size() insertion time.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than position</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.s </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "count", iterators and references to to values might be invalidated. </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty flat_map using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty flat_map using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a flat_map.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a flat_map. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a flat_map. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></copy-assignment></class><class name="flat_multimap"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A flat_multimap is a kind of associative container that supports equivalent keys (possibly containing multiple copies of the same key value) and provides for fast retrieval of values of another type T based on the keys. The flat_multimap class supports random-access iterators.</para><para>A flat_multimap satisfies all of the requirements of a container and of a reversible container and of an associative container. For a flat_multimap&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;Key,T&gt; (unlike std::multimap&lt;Key, T&gt; which value_type is std::pair&lt;<emphasis role="bold">const</emphasis> Key, T&gt;).</para><para>Pred is the ordering function for Keys (e.g. std::less&lt;Key&gt;).</para><para>Alloc is the allocator to allocate the value_types (e.g. boost::interprocess:allocator&lt; std::pair&lt;Key, T&gt;). </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="value_compare"><type>tree_t::value_compare</type></typedef><typedef name="mapped_type"><type>T</type></typedef><typedef name="key_compare"><type>tree_t::key_compare</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) search time plus N*size() insertion time.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than position</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "count", iterators and references to to values might be invalidated. </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty flat_multimap using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty flat_multimap using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a flat_multimap.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a flat_multimap. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/flat_set.hpp"><namespace name="boost"><namespace name="interprocess"><class name="flat_set"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>flat_set is a Sorted Associative Container that stores objects of type Key. flat_set is a Simple Associative Container, meaning that its value type, as well as its key type, is Key. It is also a Unique Associative Container, meaning that no two elements are the same.</para><para>flat_set is similar to std::set but it's implemented like an ordered vector. This means that inserting a new element into a flat_set invalidates previous iterators and references</para><para>Erasing an element of a flat_set invalidates iterators and references pointing to elements that come after (their keys are bigger) the erased element. </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="key_compare"><type>tree_t::key_compare</type></typedef><typedef name="value_compare"><type>tree_t::value_compare</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) search time plus N*size() insertion time.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than position</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.s </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "count", iterators and references to to values might be invalidated. </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty flat_map using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a map.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a map. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment></class><class name="flat_multiset"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>flat_multiset is a Sorted Associative Container that stores objects of type Key. flat_multiset is a Simple Associative Container, meaning that its value type, as well as its key type, is Key. flat_Multiset can store multiple copies of the same key value.</para><para>flat_multiset is similar to std::multiset but it's implemented like an ordered vector. This means that inserting a new element into a flat_multiset invalidates previous iterators and references</para><para>Erasing an element of a flat_multiset invalidates iterators and references pointing to elements that come after (their keys are equal or bigger) the erased element. </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="key_compare"><type>tree_t::key_compare</type></typedef><typedef name="value_compare"><type>tree_t::value_compare</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) search time plus N*size() insertion time.</para><para><emphasis role="bold">Note</emphasis>: If an element it's inserted it might invalidate elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than position</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.s </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "count", iterators and references to to values might be invalidated. </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><constructor><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>flat_multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/list.hpp"><namespace name="boost"><namespace name="interprocess"><class name="list"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
    </template><description><para>A list is a doubly linked list. That is, it is a Sequence that supports both forward and backward traversal, and (amortized) constant time insertion and removal of elements at the beginning or the end, or in the middle. Lists have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, list&lt;T&gt;::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit. </para></description><typedef name="value_type"><description><para>The type of object, T, stored in the list </para></description><type>T</type></typedef><typedef name="pointer"><purpose>Pointer to T. </purpose><type>A::pointer</type></typedef><typedef name="const_pointer"><purpose>Const pointer to T. </purpose><type>A::const_pointer</type></typedef><typedef name="reference"><purpose>Reference to T. </purpose><type>A::reference</type></typedef><typedef name="const_reference"><purpose>Const reference to T. </purpose><type>A::const_reference</type></typedef><typedef name="size_type"><purpose>An unsigned integral type. </purpose><type>A::size_type</type></typedef><typedef name="difference_type"><purpose>A signed integral type. </purpose><type>A::difference_type</type></typedef><typedef name="allocator_type"><purpose>The allocator type. </purpose><type>A</type></typedef><typedef name="stored_allocator_type"><purpose>The stored allocator type. </purpose><type>NodeAlloc</type></typedef><typedef name="reverse_iterator"><purpose>Iterator used to iterate backwards through a list. </purpose><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><purpose>Const iterator used to iterate backwards through a list. </purpose><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><method-group name="public member functions"><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list. </para></description></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of t in the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the beginning of the list and moves the resources of t to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="push_back" cv=""><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="push_back" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="pop_front" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="pop_back" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="front" cv=""><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv=""><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default constructed.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype>ThisType &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to std::distance [first, last). </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with mx's resources.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element at p p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last. </para></description></method><method name="assign" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>ThisType &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>ThisType &amp;</paramtype></parameter><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>ThisType &amp;</paramtype></parameter><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>ThisType &amp;</paramtype></parameter><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. n == std::distance(first, last)</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="reverse" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="remove" cv=""><type>void</type><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="binary_pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="merge" cv=""><type>void</type><parameter name="x"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method><method name="merge" cv=""><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function removes all of moved mx's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. <emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method><method name="sort" cv=""><type>void</type><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of moved mx's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. <emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method><method name="sort" cv=""><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method></method-group><constructor><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>A()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const T &amp;</paramtype><default>T()</default></parameter><parameter name="a"><paramtype>const A &amp;</paramtype><default>A()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves mx's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><parameter name="a"><paramtype>const A &amp;</paramtype><default>A()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's constructor taking an dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the list. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor><copy-assignment><parameter name="x"><paramtype>const ThisType &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. <emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All mx's values are transferred to *this.</para><para><emphasis role="bold">Postcondition</emphasis>: x.empty(). *this contains a the elements x had before the function.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>list</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/map.hpp"><namespace name="boost"><namespace name="interprocess"><class name="map"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A map is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys. The map class supports bidirectional iterators.</para><para>A map satisfies all of the requirements of a container and of a reversible container and of an associative container. For a map&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;const Key,T&gt;.</para><para>Pred is the ordering function for Keys (e.g. std::less&lt;Key&gt;).</para><para>Alloc is the allocator to allocate the value_types (e.g. boost::interprocess:allocator&lt; std::pair&lt;const Key, T&gt;). </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="mapped_type"><type>T</type></typedef><typedef name="key_compare"><type>Pred</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><typedef name="value_compare"><type>value_compare_impl</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv=""><type>T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Effects: If there is no key equivalent to x in the map, inserts value_type(x, T()) into the map.</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. </para></description></method><method name="operator[]" cv=""><type>T &amp;</type><parameter name="mk"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If there is no key equivalent to x in the map, inserts value_type(detail::move_impl(x), T()) into the map (the key is move-constructed)</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const std::pair&lt; key_type, mapped_type &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type created from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const std::pair&lt; key_type, mapped_type &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a map.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a map. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><class name="multimap"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A multimap is a kind of associative container that supports equivalent keys (possibly containing multiple copies of the same key value) and provides for fast retrieval of values of another type T based on the keys. The multimap class supports bidirectional iterators.</para><para>A multimap satisfies all of the requirements of a container and of a reversible container and of an associative container. For a map&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;const Key,T&gt;.</para><para>Pred is the ordering function for Keys (e.g. std::less&lt;Key&gt;).</para><para>Alloc is the allocator to allocate the value_types (e.g. boost::interprocess:allocator&lt; std::pair&lt;<emphasis role="bold">const</emphasis> Key, T&gt;). </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="mapped_type"><type>T</type></typedef><typedef name="key_compare"><type>Pred</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><typedef name="value_compare"><type>value_compare_impl</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype>const std::pair&lt; key_type, mapped_type &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const std::pair&lt; key_type, mapped_type &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by position.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a multimap.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a multimap. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>map</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Key"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>multimap</classname>&lt; Key, T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/set.hpp"><namespace name="boost"><namespace name="interprocess"><class name="set"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A set is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. Class set supports bidirectional iterators.</para><para>A set satisfies all of the requirements of a container and of a reversible container , and of an associative container. A set also provides most operations described in for unique keys. </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="key_compare"><type>Pred</type></typedef><typedef name="value_compare"><type>Pred</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a set. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><class name="multiset"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Pred"/>
      <template-type-parameter name="Alloc"/>
    </template><description><para>A multiset is a kind of associative container that supports equivalent keys (possibly contains multiple copies of the same key value) and provides for fast retrieval of the keys themselves. Class multiset supports bidirectional iterators.</para><para>A multiset satisfies all of the requirements of a container and of a reversible container, and of an associative container). multiset also provides most operations described for duplicate keys. </para></description><typedef name="key_type"><type>tree_t::key_type</type></typedef><typedef name="value_type"><type>tree_t::value_type</type></typedef><typedef name="pointer"><type>tree_t::pointer</type></typedef><typedef name="const_pointer"><type>tree_t::const_pointer</type></typedef><typedef name="reference"><type>tree_t::reference</type></typedef><typedef name="const_reference"><type>tree_t::const_reference</type></typedef><typedef name="key_compare"><type>Pred</type></typedef><typedef name="value_compare"><type>Pred</type></typedef><typedef name="iterator"><type>tree_t::iterator</type></typedef><typedef name="const_iterator"><type>tree_t::const_iterator</type></typedef><typedef name="reverse_iterator"><type>tree_t::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>tree_t::const_reverse_iterator</type></typedef><typedef name="size_type"><type>tree_t::size_type</type></typedef><typedef name="difference_type"><type>tree_t::difference_type</type></typedef><typedef name="allocator_type"><type>tree_t::allocator_type</type></typedef><typedef name="stored_allocator_type"><type>tree_t::stored_allocator_type</type></typedef><method-group name="public member functions"><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the Allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i, j are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [i,j) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N) (N is the distance from i to j) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method><method name="erase" cv=""><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method></method-group><constructor><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Pred &amp;</paramtype><default>Pred()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a multiset. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Construct.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment><copy-assignment><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="x"><paramtype><classname>set</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Alloc"/>
        </template><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Pred, Alloc &gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/slist.hpp"><namespace name="boost"><namespace name="interprocess"><class name="slist"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
    </template><description><para>An slist is a singly linked list: a list where each element is linked to the next element, but not to the previous element. That is, it is a Sequence that supports forward but not backward traversal, and (amortized) constant time insertion and removal of elements. Slists, like lists, have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, slist&lt;T&gt;::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit.</para><para>The main difference between slist and list is that list's iterators are bidirectional iterators, while slist's iterators are forward iterators. This means that slist is less versatile than list; frequently, however, bidirectional iterators are unnecessary. You should usually use slist unless you actually need the extra functionality of list, because singly linked lists are smaller and faster than double linked lists.</para><para>Important performance note: like every other Sequence, slist defines the member functions insert and erase. Using these member functions carelessly, however, can result in disastrously slow programs. The problem is that insert's first argument is an iterator p, and that it inserts the new element(s) before p. This means that insert must find the iterator just before p; this is a constant-time operation for list, since list has bidirectional iterators, but for slist it must find that iterator by traversing the list from the beginning up to p. In other words: insert and erase are slow operations anywhere but near the beginning of the slist.</para><para>Slist provides the member functions insert_after and erase_after, which are constant time operations: you should always use insert_after and erase_after whenever possible. If you find that insert_after and erase_after aren't adequate for your needs, and that you often need to use insert and erase in the middle of the list, then you should probably use list instead of slist. </para></description><typedef name="value_type"><description><para>The type of object, T, stored in the list </para></description><type>T</type></typedef><typedef name="pointer"><purpose>Pointer to T. </purpose><type>A::pointer</type></typedef><typedef name="const_pointer"><purpose>Const pointer to T. </purpose><type>A::const_pointer</type></typedef><typedef name="reference"><purpose>Reference to T. </purpose><type>A::reference</type></typedef><typedef name="const_reference"><purpose>Const reference to T. </purpose><type>A::const_reference</type></typedef><typedef name="size_type"><purpose>An unsigned integral type. </purpose><type>A::size_type</type></typedef><typedef name="difference_type"><purpose>A signed integral type. </purpose><type>A::difference_type</type></typedef><typedef name="allocator_type"><purpose>The allocator type. </purpose><type>A</type></typedef><typedef name="stored_allocator_type"><purpose>The stored allocator type. </purpose><type>NodeAlloc</type></typedef><method-group name="public member functions"><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="assign" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="before_begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a non-dereferenceable iterator that, when incremented, yields begin(). This iterator may be used as the argument toinsert_after, erase_after, etc.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="before_begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a non-dereferenceable const_iterator that, when incremented, yields begin(). This iterator may be used as the argument toinsert_after, erase_after, etc.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on *this and x. </para></description></method><method name="front" cv=""><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of t in the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the beginning of the list and moves the resources of t to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="pop_front" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="previous" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The iterator to the element before i in the sequence. Returns the end-iterator, if either i is the begin-iterator or the sequence is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. </para></description></method><method name="previous" cv=""><type>const_iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The const_iterator to the element before i in the sequence. Returns the end-const_iterator, if either i is the begin-const_iterator or the sequence is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. </para></description></method><method name="insert_after" cv=""><type>iterator</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of the value after the p pointed by prev_p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method><method name="insert_after" cv=""><type>iterator</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a move constructed copy object from the value after the p pointed by prev_pos.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method><method name="insert_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x after prev_pos.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method><method name="insert_after" cv=""><type>void</type><template>
          <template-type-parameter name="InIter"/>
        </template><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InIter</paramtype></parameter><parameter name="last"><paramtype>InIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the range pointed by [first, last) after the p prev_pos.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before p. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with mx's resources.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before p. </para></description></method><method name="insert" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n plus linear to the elements before p. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InIter"/>
        </template><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InIter</paramtype></parameter><parameter name="last"><paramtype>InIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to std::distance [first, last) plus linear to the elements before p. </para></description></method><method name="erase_after" cv=""><type>iterator</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev_pos of the list.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not invalidate iterators or references to non erased elements. </para></description></method><method name="erase_after" cv=""><type>iterator</type><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_first, last) from the list.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements.</para><para><emphasis role="bold">Note</emphasis>: Does not invalidate iterators or references to non erased elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element at p p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before p. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last plus linear to the elements before first. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default constructed.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, after the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in x.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="prev"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of this. i must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_pos. If prev_pos == prev or prev_pos == ++prev, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="before_last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_pos must not be contained in [before_first, before_last) range.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_pos.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of transferred elements.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="before_last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_pos must not be contained in [before_first, before_last) range. n == std::distance(before_first, before_last)</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_pos.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and linear in x.size().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and in distance(x.begin(), i).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), in distance(x.begin(), first), and in distance(first, last).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="reverse" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="remove" cv=""><type>void</type><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="merge" cv=""><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method><method name="merge" cv=""><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method><method name="sort" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method><method name="sort" cv=""><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method></method-group><constructor><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype><default>value_type()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor><constructor><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's constructor taking an dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor><constructor><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves mx's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><copy-assignment><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the list. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="sL1"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="sL2"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="sL1"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="sL2"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="sL1"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="sL2"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="sL1"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="sL2"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="sL1"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="sL2"><paramtype>const <classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>slist</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/string.hpp"><namespace name="boost"><namespace name="interprocess"><class name="basic_string"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="A"/>
    </template><description><para>The basic_string class represents a Sequence of characters. It contains all the usual operations of a Sequence, and, additionally, it contains standard string operations such as search and concatenation.</para><para>The basic_string class is parameterized by character type, and by that type's Character Traits.</para><para>This class has performance characteristics very much like vector&lt;&gt;, meaning, for example, that it does not perform reference-count or copy-on-write, and that concatenation of two strings is an O(N) operation.</para><para>Some of basic_string's member functions use an unusual method of specifying positions and ranges. In addition to the conventional method using iterators, many of basic_string's member functions use a single value pos of type size_type to represent a position (in which case the position is begin() + pos, and many of basic_string's member functions use two values, pos and n, to represent a range. In that case pos is the beginning of the range and n is its size. That is, the range is [begin() + pos, begin() + pos + n).</para><para>Note that the C++ standard does not specify the complexity of basic_string operations. In this implementation, basic_string has performance characteristics very similar to those of vector: access to a single character is O(1), while copy and concatenation are O(N).</para><para>In this implementation, begin(), end(), rbegin(), rend(), operator[], c_str(), and data() do not invalidate iterators. In this implementation, iterators are only invalidated by member functions that explicitly change the string's contents. </para></description><typedef name="allocator_type"><description><para>The allocator type </para></description><type>A</type></typedef><typedef name="stored_allocator_type"><purpose>The stored allocator type. </purpose><type>allocator_type</type></typedef><typedef name="value_type"><purpose>The type of object, CharT, stored in the string. </purpose><type>CharT</type></typedef><typedef name="traits_type"><purpose>The second template parameter Traits. </purpose><type>Traits</type></typedef><typedef name="pointer"><purpose>Pointer to CharT. </purpose><type>A::pointer</type></typedef><typedef name="const_pointer"><purpose>Const pointer to CharT. </purpose><type>A::const_pointer</type></typedef><typedef name="reference"><purpose>Reference to CharT. </purpose><type>A::reference</type></typedef><typedef name="const_reference"><purpose>Const reference to CharT. </purpose><type>A::const_reference</type></typedef><typedef name="size_type"><purpose>An unsigned integral type. </purpose><type>A::size_type</type></typedef><typedef name="difference_type"><purpose>A signed integral type. </purpose><type>A::difference_type</type></typedef><typedef name="iterator"><purpose>Iterator used to iterate through a string. It's a Random Access Iterator. </purpose><type>pointer</type></typedef><typedef name="const_iterator"><purpose>Const iterator used to iterate through a string. It's a Random Access Iterator. </purpose><type>const_pointer</type></typedef><typedef name="reverse_iterator"><purpose>Iterator used to iterate backwards through a string. </purpose><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><purpose>Const iterator used to iterate backwards through a string. </purpose><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><data-member name="npos" specifiers="static"><type>const size_type</type><purpose>The largest possible value of type size_type. That is, size_type(-1). </purpose></data-member><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="length" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default constructed.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="res_arg"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws. </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the vector. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the vector contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="at" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator+=" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends string s to *this. </purpose></method><method name="operator+=" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends c-string s to *this. </purpose></method><method name="operator+=" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends character c to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends string s to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends the range [pos, pos + n) from string s to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends the range [s, s + n) from c-string s to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends the c-string s to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends the n times the character c to *this. </purpose></method><method name="append" cv=""><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Appends the range [first, last) *this. </purpose></method><method name="push_back" cv=""><type>void</type><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts a copy of c at the end of the vector. </purpose></method><method name="pop_back" cv=""><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Removes the last element from the vector. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the value s to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Moves the resources from ms *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the range [pos, pos + n) from s to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the range [s, s + n) from s to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the c-string s to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the character c n-times to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the range [first, last) to *this. </purpose></method><method name="assign" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="f"><paramtype>const CharT *</paramtype></parameter><parameter name="l"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assigns the range [f, l) to *this. </purpose></method><method name="insert" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the string s before pos. </purpose></method><method name="insert" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="beg"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the range [pos, pos + n) from string s before pos. </purpose></method><method name="insert" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the range [s, s + n) before pos. </purpose></method><method name="insert" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the c-string s before pos. </purpose></method><method name="insert" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the character c n-times before pos. </purpose></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the character c before position. </purpose></method><method name="insert" cv=""><type>void</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the character c n-times before position. </purpose></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the range [first, last) before position. </purpose></method><method name="erase" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><purpose><emphasis role="bold">Effects</emphasis>: Inserts the range [pos, pos + n). </purpose></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Erases the character pointed by position. </purpose></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Erases the range [first, last). </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with the string s. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with a substring of s. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with the first n1 characters of s. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with a null-terminated character array. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with n1 copies of c. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with the string s. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with the first n characters of s. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with a null-terminated character array. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with n copies of c. </purpose></method><method name="replace" cv=""><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="f"><paramtype>InputIter</paramtype></parameter><parameter name="l"><paramtype>InputIter</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Replaces a substring of *this with the range [f, l) </purpose></method><method name="copy" cv="const"><type>size_type</type><parameter name="s"><paramtype>CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><purpose><emphasis role="bold">Effects</emphasis>: Copies a substring of *this to a buffer. </purpose></method><method name="swap" cv=""><type>void</type><parameter name="s"><paramtype><classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Swaps the contents of two strings. </purpose></method><method name="swap" cv=""><type>void</type><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Swaps the contents of two strings. </purpose></method><method name="c_str" cv="const"><type>const CharT *</type><description><para><emphasis role="bold">Returns</emphasis>: Returns a pointer to a null-terminated array of characters representing the string's contents. For any string s it is guaranteed that the first s.size() characters in the array pointed to by s.c_str() are equal to the character in s, and that s.c_str()[s.size()] is a null character. Note, however, that it not necessarily the first null character. Characters within a string are permitted to be null. </para></description></method><method name="data" cv="const"><type>const CharT *</type><description><para><emphasis role="bold">Returns</emphasis>: Returns a pointer to an array of characters, not necessarily null-terminated, representing the string's contents. data() is permitted, but not required, to be identical to c_str(). The first size() characters of that array are guaranteed to be identical to the characters in *this. The return value of data() is never a null pointer, even if size() is zero. </para></description></method><method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches for s as a substring of *this, beginning at character pos of *this. </para></description></method><method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches for a null-terminated character array as a substring of *this, beginning at character pos of *this. </para></description></method><method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches for the first n characters of s as a substring of *this, beginning at character pos of *this. </para></description></method><method name="find" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches for the character c, beginning at character position pos. </para></description></method><method name="rfind" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward for s as a substring of *this, beginning at character position min(pos, size()) </para></description></method><method name="rfind" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward for a null-terminated character array as a substring of *this, beginning at character min(pos, size()) </para></description></method><method name="rfind" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward for the first n characters of s as a substring of *this, beginning at character position min(pos, size()). </para></description></method><method name="rfind" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward for a null-terminated character array as a substring of *this, beginning at character min(pos, size()). </para></description></method><method name="find_first_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is equal to any character within s. </para></description></method><method name="find_first_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is equal to any character within s. </para></description></method><method name="find_first_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is equal to any character within the first n characters of s. </para></description></method><method name="find_first_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is equal to c. </para></description></method><method name="find_last_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward within *this, beginning at min(pos, size()), for the first character that is equal to any character within s. </para></description></method><method name="find_last_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward *this, beginning at min(pos, size()), for the first character that is equal to any character within s. </para></description></method><method name="find_last_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward within *this, beginning at min(pos, size()), for the first character that is equal to any character within the first n characters of s. </para></description></method><method name="find_last_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward *this, beginning at min(pos, size()), for the first character that is equal to c. </para></description></method><method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is not equal to any character within s. </para></description></method><method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is not equal to any character within s. </para></description></method><method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is not equal to any character within the first n characters of s. </para></description></method><method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches within *this, beginning at pos, for the first character that is not equal to c. </para></description></method><method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward within *this, beginning at min(pos, size()), for the first character that is not equal to any character within s. </para></description></method><method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward *this, beginning at min(pos, size()), for the first character that is not equal to any character within s. </para></description></method><method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward within *this, beginning at min(pos, size()), for the first character that is not equal to any character within the first n characters of s. </para></description></method><method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Searches backward *this, beginning at min(pos, size()), for the first character that is not equal to c. </para></description></method><method name="substr" cv="const"><type><classname>basic_string</classname></type><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><purpose><emphasis role="bold">Effects</emphasis>: Returns a substring of *this. </purpose></method><method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Three-way lexicographical comparison of s and *this. </purpose></method><method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Three-way lexicographical comparison of s and a substring of *this. </para></description></method><method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Three-way lexicographical comparison of a substring of s and a substring of *this. </para></description></method><method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Three-way lexicographical comparison of s and *this. </purpose></method><method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Three-way lexicographical comparison of the first min(len, traits::length(s) characters of s and a substring of *this. </para></description></method></method-group><constructor><parameter name=""><paramtype>reserve_t</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter></constructor><constructor><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws. </para></description></constructor><constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a basic_string.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws. </para></description></constructor><constructor><parameter name="s"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves mx's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter, and is initialized by a specific number of characters of the s string. </para></description></constructor><constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter, and is initialized by a specific number of characters of the s c-string. </para></description></constructor><constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter, and is initialized by the null-terminated s c-string. </para></description></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter, and is initialized by n copies of c. </para></description></constructor><constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="f"><paramtype>InputIterator</paramtype></parameter><parameter name="l"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a basic_string taking the allocator as parameter, and a range of iterators. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the basic_string. All used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></destructor><copy-assignment><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a string.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></copy-assignment><copy-assignment><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves mx's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment><copy-assignment><parameter name="s"><paramtype>const CharT *</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assignment from a null-terminated c-string. </purpose></copy-assignment><copy-assignment><parameter name="c"><paramtype>CharT</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assignment from character. </purpose></copy-assignment></class><function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, A &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="my"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, A &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="my"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, A &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="my"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, A &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, A &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="c"><paramtype>const CharT</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="c"><paramtype>const CharT</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="my"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="operator&gt;&gt;"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::istream &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter><parameter name="delim"><paramtype>CharT</paramtype></parameter></function><function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::istream &amp;</paramtype></parameter><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="delim"><paramtype>CharT</paramtype></parameter></function><function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, A &gt; &amp;</paramtype></parameter></function><function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="A"/>
        </template><parameter name="is"><paramtype>std::istream &amp;</paramtype></parameter><parameter name="ms"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function><function name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="Ch"/>
          <template-type-parameter name="A"/>
        </template><parameter name="v"><paramtype><classname>basic_string</classname>&lt; Ch, std::char_traits&lt; Ch &gt;, A &gt; const &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/containers/vector.hpp"><namespace name="boost"><namespace name="interprocess"><class name="vector"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
    </template><description><para>A vector is a sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a vector may vary dynamically; memory management is automatic. boost::interprocess::vector is similar to std::vector but it's compatible with shared memory and memory mapped files. </para></description><typedef name="value_type"><description><para>The type of object, T, stored in the vector </para></description><type>T</type></typedef><typedef name="pointer"><purpose>Pointer to T. </purpose><type>A::pointer</type></typedef><typedef name="const_pointer"><purpose>Const pointer to T. </purpose><type>A::const_pointer</type></typedef><typedef name="reference"><purpose>Reference to T. </purpose><type>A::reference</type></typedef><typedef name="const_reference"><purpose>Const reference to T. </purpose><type>A::const_reference</type></typedef><typedef name="size_type"><purpose>An unsigned integral type. </purpose><type>A::size_type</type></typedef><typedef name="difference_type"><purpose>A signed integral type. </purpose><type>A::difference_type</type></typedef><typedef name="allocator_type"><purpose>The allocator type. </purpose><type>A</type></typedef><typedef name="iterator"><purpose>The random access iterator. </purpose><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_iterator"><purpose>The random access const_iterator. </purpose><type><emphasis>unspecified</emphasis></type></typedef><typedef name="reverse_iterator"><purpose>Iterator used to iterate backwards through a vector. </purpose><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><purpose>Const iterator used to iterate backwards through a vector. </purpose><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="stored_allocator_type"><purpose>The stored allocator type. </purpose><type>allocator_type</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv=""><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv=""><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="capacity" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the vector contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="operator[]" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="at" cv=""><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &lt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type></method><method name="get_stored_allocator" cv=""><type>stored_allocator_type &amp;</type></method><method name="reserve" cv=""><type>void</type><parameter name="new_cap"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws. </para></description></method><method name="assign" cv=""><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="push_back" cv=""><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="push_back" cv=""><type>void</type><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the end of the vector and moves the resources of mx to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="x"><paramtype><classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x. If this-&gt;allocator_type() != x.allocator_type() allocators are also swapped.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before position.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: If position is begin() or end(), amortized constant time Linear time otherwise. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="position"><paramtype>iterator</paramtype></parameter><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before position with mx's resources.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: If position is begin() or end(), amortized constant time Linear time otherwise. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before pos.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to std::distance [first, last). </para></description></method><method name="insert" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert n copies of x before pos.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method><method name="pop_back" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element at position pos.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements between pos and the last element. Constant if pos is the first or the last element. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="resize" cv=""><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default constructed.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the vector. </para></description></method></method-group><constructor><parameter name="a"><paramtype>const A &amp;</paramtype><default>A()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const T &amp;</paramtype><default>T()</default></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor><constructor><parameter name="x"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a vector.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor><constructor><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves mx's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor><constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts a copy of the range [first, last) in the vector.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws or T's constructor taking an dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the vector. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor><copy-assignment><parameter name="x"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment><copy-assignment><parameter name="mx"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All mx's values are transferred to *this.</para><para><emphasis role="bold">Postcondition</emphasis>: x.empty(). *this contains a the elements x had before the function.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="y"><paramtype><classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
        </template><parameter name="x"><paramtype><classname>vector</classname>&lt; T, A &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></function></namespace></namespace></header><header name="boost/interprocess/creation_tags.hpp"><namespace name="boost"><namespace name="interprocess"><struct name="create_only_t"><description><para>Tag to indicate that the resource must be only created </para></description></struct><struct name="open_only_t"><description><para>Tag to indicate that the resource must be only opened </para></description></struct><struct name="open_read_only_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct name="open_copy_on_write_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct name="open_or_create_t"><description><para>Tag to indicate that the resource must be created. If already created, it must be opened. </para></description></struct><data-member name="create_only" specifiers="static"><type>const <classname>create_only_t</classname></type><description><para>Value to indicate that the resource must be only created </para></description></data-member><data-member name="open_only" specifiers="static"><type>const <classname>open_only_t</classname></type><description><para>Value to indicate that the resource must be only opened </para></description></data-member><data-member name="open_read_only" specifiers="static"><type>const <classname>open_read_only_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member><data-member name="open_or_create" specifiers="static"><type>const <classname>open_or_create_t</classname></type><description><para>Value to indicate that the resource must be created. If already created, it must be opened. </para></description></data-member><data-member name="open_copy_on_write" specifiers="static"><type>const <classname>open_copy_on_write_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member></namespace></namespace></header><header name="boost/interprocess/errors.hpp"><para>Describes the error numbering of interprocess classes </para><namespace name="boost"><namespace name="interprocess"><enum name="error_code_t"><enumvalue name="no_error"><default> 0</default></enumvalue><enumvalue name="system_error"/><enumvalue name="other_error"/><enumvalue name="security_error"/><enumvalue name="read_only_error"/><enumvalue name="io_error"/><enumvalue name="path_error"/><enumvalue name="not_found_error"/><enumvalue name="busy_error"/><enumvalue name="already_exists_error"/><enumvalue name="not_empty_error"/><enumvalue name="is_directory_error"/><enumvalue name="out_of_space_error"/><enumvalue name="out_of_memory_error"/><enumvalue name="out_of_resource_error"/><enumvalue name="lock_error"/><enumvalue name="sem_error"/><enumvalue name="mode_error"/><enumvalue name="size_error"/><enumvalue name="corrupted_error"/></enum><typedef name="native_error_t"><type>int</type></typedef></namespace></namespace></header><header name="boost/interprocess/exceptions.hpp"><para>Describes exceptions thrown by interprocess classes </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_exception"><description><para>This class is the base class of all exceptions thrown by boost::interprocess </para></description><method-group name="public member functions"><method name="what" cv="const"><type>const char *</type></method><method name="get_native_error" cv="const"><type>native_error_t</type></method><method name="get_error_code" cv="const"><type>error_code_t</type></method></method-group><constructor><parameter name="ec"><paramtype>error_code_t</paramtype><default>other_error</default></parameter></constructor><constructor><parameter name="sys_err_code"><paramtype>native_error_t</paramtype></parameter></constructor><constructor><parameter name="err_info"><paramtype>const error_info &amp;</paramtype></parameter></constructor><destructor/></class><class name="lock_exception"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This is the exception thrown by shared interprocess_mutex family when a deadlock situation is detected or when using a interprocess_condition the interprocess_mutex is not locked </para></description><method-group name="public member functions"><method name="what" cv="const"><type>const char *</type></method></method-group><constructor/></class><class name="bad_alloc"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This is the exception thrown by named interprocess_semaphore when a deadlock situation is detected or when an error is detected in the post/wait operation This is the exception thrown by synchronization objects when there is an error in a wait() function This exception is thrown when a named object is created in "open_only" mode and the resource was not already created This exception is thrown when a memory request can't be fulfilled. </para></description><method-group name="public member functions"><method name="what" cv="const"><type>const char *</type></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/file_mapping.hpp"><para>Describes file_mapping and mapped region classes </para><namespace name="boost"><namespace name="interprocess"><class name="file_mapping"><description><para>A class that wraps a file-mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>file_mapping</classname> &amp;</paramtype></parameter><description><para>Swaps to file_mappings. Does not throw. </para></description></method><method name="get_mode" cv="const"><type>mode_t</type><description><para>Returns access mode used in the constructor </para></description></method><method name="get_mapping_handle" cv="const"><type>mapping_handle_t</type><description><para>Obtains the mapping handle to be used with mapped_region </para></description></method><method name="get_name" cv="const"><type>const char *</type><description><para>Returns the name of the file used in the constructor. </para></description></method></method-group><constructor><description><para>Constructs an empty file mapping. Does not throw </para></description></constructor><constructor><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Opens a file mapping of file "filename", starting in offset "file_offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write" modes. Throws interprocess_exception on error. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment><destructor><description><para>Destroys the file mapping. All mapped regions created from this are still valid. Does not throw </para></description></destructor></class><class name="remove_file_on_destroy"><description><para>A class that stores the name of a a file and call std::remove(name) in its destructor Useful to remove temporary files in the presence of exceptions </para></description><method-group name="public member functions"/><constructor><parameter name="name"><paramtype>const char *</paramtype></parameter></constructor><destructor/></class></namespace></namespace></header><header name="boost/interprocess/indexes/flat_map_index.hpp"><para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost"><namespace name="interprocess"><struct name="flat_map_index_aux"><template>
      <template-type-parameter name="MapConfig"/>
    </template><purpose>Helper class to define typedefs from IndexTraits. </purpose><typedef name="key_type"><type>MapConfig::key_type</type></typedef><typedef name="mapped_type"><type>MapConfig::mapped_type</type></typedef><typedef name="segment_manager_base"><type>MapConfig::segment_manager_base</type></typedef><typedef name="key_less"><type>std::less&lt; key_type &gt;</type></typedef><typedef name="value_type"><type>std::pair&lt; key_type, mapped_type &gt;</type></typedef><typedef name="allocator_type"><type><classname>allocator</classname>&lt; value_type,<classname>segment_manager_base</classname> &gt;</type></typedef><typedef name="index_t"><type><classname>flat_map</classname>&lt; key_type, mapped_type, key_less, <classname>allocator_type</classname> &gt;</type></typedef></struct><class name="flat_map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">boost::interprocess::flat_map&lt; key_type, mapped_type, key_less, allocator_type &gt;</inherit><description><para>Index type based in flat_map. Just derives from flat_map and defines the interface needed by managed memory segments. </para></description><method-group name="public member functions"><method name="reserve" cv=""><type>void</type><parameter name="n"><paramtype>std::size_t</paramtype></parameter><purpose>This reserves memory to optimize the insertion of n elements in the index. </purpose></method><method name="shrink_to_fit" cv=""><type>void</type><purpose>This frees all unnecessary memory. </purpose></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor></class></namespace></namespace></header><header name="boost/interprocess/indexes/iset_index.hpp"><para>Describes index adaptor of boost::intrusive::set container, to use it as name/shared memory index </para><namespace name="boost"><namespace name="interprocess"><class name="iset_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments </para></description><typedef name="iterator"><type>index_type::iterator</type></typedef><typedef name="const_iterator"><type>index_type::const_iterator</type></typedef><typedef name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef><typedef name="value_type"><type>index_type::value_type</type></typedef><method-group name="public member functions"><method name="reserve" cv=""><type>void</type><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose>This frees all unnecessary memory. </purpose></method><method name="find" cv=""><type>iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method><method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method></method-group><constructor><parameter name=""><paramtype>typename MapConfig::segment_manager_base *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor></class></namespace></namespace></header><header name="boost/interprocess/indexes/iunordered_set_index.hpp"><para>Describes index adaptor of boost::intrusive::unordered_set container, to use it as name/shared memory index </para><namespace name="boost"><namespace name="interprocess"><class name="iunordered_set_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments </para></description><typedef name="iterator"><type>index_type::iterator</type></typedef><typedef name="const_iterator"><type>index_type::const_iterator</type></typedef><typedef name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef><typedef name="value_type"><type>index_type::value_type</type></typedef><typedef name="bucket_ptr"><type>index_type::bucket_ptr</type></typedef><typedef name="bucket_type"><type>index_type::bucket_type</type></typedef><typedef name="bucket_traits"><type>index_type::bucket_traits</type></typedef><typedef name="size_type"><type>index_type::size_type</type></typedef><method-group name="public member functions"><method name="reserve" cv=""><type>void</type><parameter name="new_n"><paramtype>std::size_t</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><description><para>This tries to free unused memory previously allocated. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method><method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="val"><paramtype>value_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method></method-group><constructor><parameter name="mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor><destructor/></class></namespace></namespace></header><header name="boost/interprocess/indexes/map_index.hpp"><para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost"><namespace name="interprocess"><class name="map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">boost::interprocess::map&lt; key_type, mapped_type, key_less, allocator_type &gt;</inherit><description><para>Index type based in boost::interprocess::map. Just derives from boost::interprocess::map and defines the interface needed by managed memory segments </para></description><method-group name="public member functions"><method name="reserve" cv=""><type>void</type><parameter name=""><paramtype>std::size_t</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><description><para>This tries to free previously allocate unused memory. </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor></class></namespace></namespace></header><header name="boost/interprocess/indexes/null_index.hpp"><para>Describes a null index adaptor, so that if we don't want to construct named objects, we can use this null index type to save resources. </para><namespace name="boost"><namespace name="interprocess"><class name="null_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Null index type used to save compilation time when named indexes are not needed. </para></description><typedef name="iterator"><type>void *</type></typedef><typedef name="const_iterator"><type>const void *</type></typedef><method-group name="public member functions"><method name="begin" cv="const"><type>const_iterator</type><description><para>begin() is equal to end() </para></description></method><method name="begin" cv=""><type>iterator</type><description><para>begin() is equal to end() </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para>begin() is equal to end() </para></description></method><method name="end" cv=""><type>iterator</type><description><para>begin() is equal to end() </para></description></method></method-group><constructor><parameter name=""><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><purpose>Empty constructor. </purpose></constructor></class></namespace></namespace></header><header name="boost/interprocess/indexes/unordered_map_index.hpp"><para>Describes index adaptor of boost::unordered_map container, to use it as name/shared memory index </para><namespace name="boost"><namespace name="interprocess"><class name="unordered_map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Index type based in unordered_map. Just derives from unordered_map and defines the interface needed by managed memory segments </para></description><method-group name="public member functions"><method name="reserve" cv=""><type>void</type><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><description><para>This tries to free previously allocate unused memory. </para></description></method></method-group><constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor></class></namespace></namespace></header><header name="boost/interprocess/interprocess_fwd.hpp"><namespace name="boost"><namespace name="interprocess"><typedef name="managed_external_buffer"><type><classname>basic_managed_external_buffer</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="wmanaged_external_buffer"><type><classname>basic_managed_external_buffer</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="managed_shared_memory"><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="wmanaged_shared_memory"><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="fixed_managed_shared_memory"><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="wfixed_managed_shared_memory"><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="managed_heap_memory"><type><classname>basic_managed_heap_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="wmanaged_heap_memory"><type><classname>basic_managed_heap_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="managed_mapped_file"><type><classname>basic_managed_mapped_file</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="wmanaged_mapped_file"><type><classname>basic_managed_mapped_file</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef><typedef name="string"><type><classname>basic_string</classname>&lt; char,std::char_traits&lt; char &gt;,std::allocator&lt; char &gt; &gt;</type></typedef></namespace></namespace></header><header name="boost/interprocess/ipc/message_queue.hpp"><para>Describes an inter-process message queue. This class allows sending messages between processes and allows blocking, non-blocking and timed sending and receiving. </para><namespace name="boost"><namespace name="interprocess"><class name="message_queue"><description><para>A class that allows sending messages between processes. </para></description><method-group name="public member functions"><method name="send" cv=""><type>*void</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender is blocked. Throws interprocess_error on error. </para></description></method><method name="try_send" cv=""><type>bool</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" through the message queue with priority "priority". If the message queue is full the sender is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method><method name="timed_send" cv=""><type>bool</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method><method name="receive" cv=""><type>void</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="recvd_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is blocked. Throws interprocess_error on error. </para></description></method><method name="try_receive" cv=""><type>bool</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="recvd_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method><method name="timed_receive" cv=""><type>bool</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="recvd_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method><method name="get_max_msg" cv="const"><type>std::size_t</type><description><para>Returns the maximum number of messages allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method><method name="get_max_msg_size" cv="const"><type>std::size_t</type><description><para>Returns the maximum size of message allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method><method name="get_num_msg" cv=""><type>std::size_t</type><description><para>Returns the number of messages currently stored. Never throws </para></description></method></method-group><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>std::size_t</paramtype></parameter><parameter name="max_msg_size"><paramtype>std::size_t</paramtype></parameter><description><para>Creates a process shared message queue with name "name". For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>std::size_t</paramtype></parameter><parameter name="max_msg_size"><paramtype>std::size_t</paramtype></parameter><description><para>Opens or creates a process shared message queue with name "name". If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored. </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a previously created process shared message queue with name "name". If the was not previously created or there are no free resources, the function returns false. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All opened message queues are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the message queue from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Removes the message queue from the system. Returns false on error. Never throws </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/managed_external_buffer.hpp"><para>Describes a named user memory allocation user class. </para><namespace name="boost"><namespace name="interprocess"><class name="basic_managed_external_buffer"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic user memory named object creation class. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><method-group name="public member functions"><method name="grow" cv=""><type>void</type><parameter name="extra_bytes"><paramtype>std::size_t</paramtype></parameter></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>basic_managed_external_buffer</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method></method-group><constructor><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor><constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="addr"><paramtype>void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><purpose>Creates and places the segment manager. This can throw. </purpose></constructor><constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="addr"><paramtype>void *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><purpose>Creates and places the segment manager. This can throw. </purpose></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment></class></namespace></namespace></header><header name="boost/interprocess/managed_heap_memory.hpp"><para>Describes a named heap memory allocation user class. </para><namespace name="boost"><namespace name="interprocess"><class name="basic_managed_heap_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic heap memory named object creation class. Initializes the heap memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><method-group name="public member functions"><method name="grow" cv=""><type>bool</type><parameter name="extra_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Tries to resize internal heap memory so that we have room for more objects. WARNING: If memory is reallocated, all the objects will be binary-copied to the new buffer. To be able to use this function, all pointers constructed in this buffer must be offset pointers. Otherwise, the result is undefined. Returns true if the growth has been successful, so you will have some extra bytes to allocate new objects. If returns false, the heap allocation has failed. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>basic_managed_heap_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method></method-group><constructor><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor><destructor><description><para>Destructor. Liberates the heap memory holding the managed data. Never throws. </para></description></destructor><constructor><parameter name="size"><paramtype>std::size_t</paramtype></parameter><description><para>Creates heap memory and initializes the segment manager. This can throw. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment></class></namespace></namespace></header><header name="boost/interprocess/managed_mapped_file.hpp"><namespace name="boost"><namespace name="interprocess"><class name="basic_managed_mapped_file"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic mapped file named object creation class. Initializes the mapped file. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>basic_managed_mapped_file</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method><method name="flush" cv=""><type>bool</type><description><para>Flushes cached data to file. Never throws </para></description></method></method-group><constructor><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates mapped file and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in copy_on_write mode. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in read-only mode. This can throw. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="grow" cv=""><type>static bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Tries to resize mapped file so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method><method name="shrink_to_fit" cv=""><type>static bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize mapped file to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/managed_shared_memory.hpp"><namespace name="boost"><namespace name="interprocess"><class name="basic_managed_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic shared memory named object creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>basic_managed_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed shared memories managed by *this and other. Never throws. </para></description></method></method-group><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><constructor><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in copy_on_write mode. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw. </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment><method-group name="public static functions"><method name="grow" cv=""><type>static bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Tries to resize the managed shared memory object so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method><method name="shrink_to_fit" cv=""><type>static bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize the managed shared memory to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/managed_windows_shared_memory.hpp"><namespace name="boost"><namespace name="interprocess"><class name="basic_managed_windows_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic managed windows shared memory creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; Unlike basic_managed_shared_memory, it has no kernel persistence and the shared memory is destroyed when all processes destroy all their windows_shared_memory objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: basic_managed_windows_shared_memory and basic_managed_shared_memory can't communicate between them. </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method></method-group><constructor><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in copy_on_write mode. This can throw. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in read-only mode. This can throw. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. When all mapped regions and basic_managed_windows_shared_memory objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor></class></namespace></namespace></header><header name="boost/interprocess/mapped_region.hpp"><para>Describes memory_mappable and mapped region classes </para><namespace name="boost"><namespace name="interprocess"><class name="mapped_region"><description><para>The mapped_region class represents a portion or region created from a memory_mappable object. </para></description><method-group name="public member functions"><method name="get_size" cv="const"><type>std::size_t</type><description><para>Returns the size of the mapping. Note for windows users: If windows_shared_memory is mapped using 0 as the size, it returns 0 because the size is unknown. Never throws. </para></description></method><method name="get_address" cv="const"><type>void *</type><description><para>Returns the base address of the mapping. Never throws. </para></description></method><method name="get_offset" cv="const"><type>offset_t</type><description><para>Returns the offset of the mapping from the beginning of the mapped memory. Never throws. </para></description></method><method name="get_mode" cv="const"><type>mode_t</type><description><para>Returns the mode of the mapping used to contruct the mapped file. Never throws. </para></description></method><method name="flush" cv=""><type>bool</type><parameter name="mapping_offset"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="numbytes"><paramtype>std::size_t</paramtype><default>0</default></parameter><description><para>Flushes to the disk a byte range within the mapped memory. Never throws </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;</paramtype></parameter><description><para>Swaps the mapped_region with another mapped region </para></description></method></method-group><constructor><template>
          <template-type-parameter name="MemoryMappable"/>
        </template><parameter name="mapping"><paramtype>const MemoryMappable &amp;</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="offset"><paramtype>offset_t</paramtype><default>0</default></parameter><parameter name="size"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="address"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Creates a mapping region of the mapped memory "mapping", starting in offset "offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write. </para></description></constructor><constructor><description><para>Default constructor. Address and size and offset will be 0. Does not throw </para></description></constructor><constructor><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Move constructor. *this will be constructed taking ownership of "other"'s region and "other" will be left in default constructor state. </para></description></constructor><destructor><description><para>Destroys the mapped region. Does not throw </para></description></destructor><copy-assignment><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Move assignment. If *this owns a memory mapped region, it will be destroyed and it will take ownership of "other"'s memory mapped region. </para></description></copy-assignment><method-group name="public static functions"><method name="get_page_size" cv=""><type>static std::size_t</type><description><para>Returns the size of the page. This size is the minimum memory that will be used by the system when mapping a memory mappable source. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/mem_algo/rbtree_best_fit.hpp"><para>Describes a best-fit algorithm based in an intrusive red-black tree used to allocate objects in shared memory. This class is intended as a base class for single segment and multi-segment implementations. </para><namespace name="boost"><namespace name="interprocess"><class name="rbtree_best_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
      <template-nontype-parameter name="MemAlignment"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This class implements an algorithm that stores the free nodes in a red-black tree to have logarithmic search/insert times. </para></description><typedef name="mutex_family"><description><para>Shared interprocess_mutex family used for the rest of the Interprocess framework </para></description><type>MutexFamily</type></typedef><typedef name="void_pointer"><purpose>Pointer type to be used with the rest of the Interprocess framework. </purpose><type>VoidPointer</type></typedef><typedef name="multiallocation_iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="multiallocation_chain"><type><emphasis>unspecified</emphasis></type></typedef><data-member name="PayloadPerAllocation" specifiers="static"><type>const std::size_t</type></data-member><method-group name="public member functions"><method name="allocate" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><purpose>Allocates bytes, returns 0 if there is not more memory. </purpose></method><method name="deallocate" cv=""><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><description><para>Deallocates previously allocated bytes </para></description></method><method name="get_size" cv="const"><type>std::size_t</type><purpose>Returns the size of the memory segment. </purpose></method><method name="get_free_memory" cv="const"><type>std::size_t</type><purpose>Returns the number of free bytes of the segment. </purpose></method><method name="zero_free_memory" cv=""><type>void</type><description><para>Initializes to zero all the memory that's not in use. This function is normally used for security reasons. </para></description></method><method name="grow" cv=""><type>void</type><parameter name="extra_size"><paramtype>std::size_t</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><purpose>Decreases managed memory as much as possible. </purpose></method><method name="all_memory_deallocated" cv=""><type>bool</type><purpose>Returns true if all allocated memory has been deallocated. </purpose></method><method name="check_sanity" cv=""><type>bool</type><description><para>Makes an internal sanity check and returns true if success </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; T *, bool &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="preferred_size"><paramtype>std::size_t</paramtype></parameter><parameter name="received_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>T *</paramtype><default>0</default></parameter></method><method name="raw_allocation_command" cv=""><type>std::pair&lt; void *, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_object"><paramtype>std::size_t</paramtype></parameter><parameter name="preferred_object"><paramtype>std::size_t</paramtype></parameter><parameter name="received_object"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>void *</paramtype><default>0</default></parameter><parameter name="sizeof_object"><paramtype>std::size_t</paramtype><default>1</default></parameter></method><method name="size" cv="const"><type>std::size_t</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method><method name="allocate_aligned" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates aligned bytes, returns 0 if there is not more memory. Alignment must be power of 2 </para></description></method></method-group><constructor><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(rbtree_best_fit) offset that the allocator should not use at all. </para></description></constructor><destructor><purpose>Destructor. </purpose></destructor><method-group name="public static functions"><method name="get_min_size" cv=""><type>static std::size_t</type><parameter name="extra_hdr_bytes"><paramtype>std::size_t</paramtype></parameter><purpose>Obtains the minimum size needed by the algorithm. </purpose></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/mem_algo/simple_seq_fit.hpp"><para>Describes sequential fit algorithm used to allocate objects in shared memory. </para><namespace name="boost"><namespace name="interprocess"><class name="simple_seq_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>This class implements the simple sequential fit algorithm with a simply linked list of free buffers. </para></description><method-group name="public member functions"/><constructor><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(simple_seq_fit) offset that the allocator should not use at all. </para></description></constructor></class></namespace></namespace></header><header name="boost/interprocess/offset_ptr.hpp"><para>Describes a smart pointer that stores the offset between this pointer and target pointee, called offset_ptr. </para><namespace name="boost"><namespace name="interprocess"><class name="offset_ptr"><template>
      <template-type-parameter name="PointedType"/>
    </template><description><para>A smart pointer that stores the offset between between the pointer and the the object it points. This allows offset allows special properties, since the pointer is independent from the address address of the pointee, if the pointer and the pointee are still separated by the same offset. This feature converts offset_ptr in a smart pointer that can be placed in shared memory and memory mapped files mapped in different addresses in every process. </para></description><typedef name="pointer"><type>PointedType *</type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="value_type"><type>PointedType</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="iterator_category"><type>std::random_access_iterator_tag</type></typedef><method-group name="public member functions"><method name="get" cv="const"><type>pointer</type><description><para>Obtains raw pointer from offset. Never throws. </para></description></method><method name="get_offset" cv=""><type>std::ptrdiff_t</type></method><method name="operator-&gt;" cv="const"><type>pointer</type><description><para>Pointer-like -&gt; operator. It can return 0 pointer. Never throws. </para></description></method><method name="operator*" cv="const"><type>reference</type><description><para>Dereferencing operator, if it is a null offset_ptr behavior is undefined. Never throws. </para></description></method><method name="operator[]" cv="const"><type>reference</type><parameter name="idx"><paramtype>std::ptrdiff_t</paramtype></parameter><description><para>Indexing operator. Never throws. </para></description></method><method name="operator+" cv="const"><type><classname>offset_ptr</classname></type><parameter name="offset"><paramtype>std::ptrdiff_t</paramtype></parameter><description><para>offset_ptr + std::ptrdiff_t. Never throws. </para></description></method><method name="operator-" cv="const"><type><classname>offset_ptr</classname></type><parameter name="offset"><paramtype>std::ptrdiff_t</paramtype></parameter><description><para>offset_ptr - std::ptrdiff_t. Never throws. </para></description></method><method name="operator+=" cv=""><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>std::ptrdiff_t</paramtype></parameter><description><para>offset_ptr += std::ptrdiff_t. Never throws. </para></description></method><method name="operator-=" cv=""><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>std::ptrdiff_t</paramtype></parameter><description><para>offset_ptr -= std::ptrdiff_t. Never throws. </para></description></method><method name="operator++" cv=""><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>++offset_ptr. Never throws. </para></description></method><method name="operator++" cv=""><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para>offset_ptr++. Never throws. </para></description></method><method name="operator--" cv=""><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>--offset_ptr. Never throws. </para></description></method><method name="operator--" cv=""><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para>offset_ptr--. Never throws. </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>safe bool conversion operator. Never throws. </para></description></method><method name="operator!" cv="const"><type>bool</type><description><para>Not operator. Not needed in theory, but improves portability. Never throws </para></description></method></method-group><constructor><parameter name="ptr"><paramtype>pointer</paramtype><default>0</default></parameter><description><para>Constructor from raw pointer (allows "0" pointer conversion). Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>T *</paramtype></parameter><description><para>Constructor from other pointer. Never throws. </para></description></constructor><constructor><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Constructor from other offset_ptr Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>Constructor from other offset_ptr. If pointers of pointee types are convertible, offset_ptrs will be convertibles. Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates static_cast operator. Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates const_cast operator. Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates dynamic_cast operator. Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates reinterpret_cast operator. Never throws. </para></description></constructor><copy-assignment><parameter name="from"><paramtype>pointer</paramtype></parameter><description><para>Assignment from pointer (saves extra conversion). Never throws. </para></description></copy-assignment><copy-assignment><parameter name="pt"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Assignment from other offset_ptr. Never throws. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>Assignment from related offset_ptr. If pointers of pointee types are assignable, offset_ptrs will be assignable. Never throws. </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; == offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; != offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; &lt; offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; &lt;= offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; &gt; offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt1"><paramtype>const <classname>offset_ptr</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr&lt;T1&gt; &gt;= offset_ptr&lt;T2&gt;. Never throws. </para></description></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; Y &gt; const &amp;</paramtype></parameter><description><para>operator&lt;&lt; for offset ptr </para></description></function><function name="operator&gt;&gt;"><type>std::basic_istream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; Y &gt; &amp;</paramtype></parameter><description><para>operator&gt;&gt; for offset ptr </para></description></function><function name="operator+"><type><classname>offset_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="diff"><paramtype>std::ptrdiff_t</paramtype></parameter><parameter name="right"><paramtype>const <classname>offset_ptr</classname>&lt; T &gt; &amp;</paramtype></parameter><description><para>std::ptrdiff_t + offset_ptr operation </para></description></function><function name="operator-"><type>std::ptrdiff_t</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="pt"><paramtype>const <classname>offset_ptr</classname>&lt; T &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>offset_ptr - offset_ptr operation </para></description></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="pt"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt; &amp;</paramtype></parameter><description><para>swap specialization for offset_ptr </para></description></function><function name="static_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Simulation of static_cast between pointers. Never throws. </purpose></function><function name="const_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Simulation of const_cast between pointers. Never throws. </purpose></function><function name="dynamic_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Simulation of dynamic_cast between pointers. Never throws. </purpose></function><function name="reinterpret_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>boost::interprocess::offset_ptr</classname>&lt; U &gt; const &amp;</paramtype></parameter><purpose>Simulation of reinterpret_cast between pointers. Never throws. </purpose></function></namespace></namespace></header><header name="boost/interprocess/segment_manager.hpp"><para>Describes the object placed in a memory segment that provides named object allocation capabilities for single-segment and multi-segment allocations. </para><namespace name="boost"><namespace name="interprocess"><class name="segment_manager_base"><template>
      <template-type-parameter name="MemoryAlgorithm"/>
    </template><description><para>This object is the public base class of segment manager. This class only depends on the memory allocation algorithm and implements all the allocation features not related to named or unique objects.</para><para>Storing a reference to segment_manager forces the holder class to be dependent on index types and character types. When such dependence is not desirable and only anonymous and raw allocations are needed, segment_manager_base is the correct answer. </para></description><typedef name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef><typedef name="void_pointer"><type>MemoryAlgorithm::void_pointer</type></typedef><typedef name="mutex_family"><type>MemoryAlgorithm::mutex_family</type></typedef><typedef name="memory_algorithm"><type>MemoryAlgorithm</type></typedef><data-member name="PayloadPerAllocation" specifiers="static"><type>const std::size_t</type><description><para>This constant indicates the payload size associated with each allocation of the memory algorithm </para></description></data-member><method-group name="public member functions"><method name="get_size" cv="const"><type>std::size_t</type><description><para>Returns the size of the memory segment </para></description></method><method name="get_free_memory" cv="const"><type>std::size_t</type><description><para>Returns the number of free bytes of the memory segment </para></description></method><method name="allocate" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method><method name="allocate" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates nbytes bytes. Throws boost::interprocess::bad_alloc on failure </para></description></method><method name="allocate_aligned" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method><method name="allocate_aligned" cv=""><type>void *</type><parameter name="nbytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Throws bad_alloc when fails </para></description></method><method name="allocation_command" cv=""><type>std::pair&lt; T *, bool &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="preferred_size"><paramtype>std::size_t</paramtype></parameter><parameter name="received_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>T *</paramtype><default>0</default></parameter></method><method name="raw_allocation_command" cv=""><type>std::pair&lt; void *, bool &gt;</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_objects"><paramtype>std::size_t</paramtype></parameter><parameter name="preferred_objects"><paramtype>std::size_t</paramtype></parameter><parameter name="received_objects"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>void *</paramtype><default>0</default></parameter><parameter name="sizeof_object"><paramtype>std::size_t</paramtype><default>1</default></parameter></method><method name="deallocate" cv=""><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><description><para>Deallocates the bytes allocated with allocate/allocate_many() pointed by addr </para></description></method><method name="grow" cv=""><type>void</type><parameter name="extra_size"><paramtype>std::size_t</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more. This only works with single-segment management. </para></description></method><method name="shrink_to_fit" cv=""><type>void</type><description><para>Decreases managed memory to the minimum. This only works with single-segment management. </para></description></method><method name="all_memory_deallocated" cv=""><type>bool</type><description><para>Returns the result of "all_memory_deallocated()" function of the used memory algorithm </para></description></method><method name="check_sanity" cv=""><type>bool</type><description><para>Returns the result of "check_sanity()" function of the used memory algorithm </para></description></method><method name="zero_free_memory" cv=""><type>void</type><description><para>Writes to zero free memory (memory not yet allocated) of the memory algorithm </para></description></method><method name="size" cv="const"><type>std::size_t</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method></method-group><constructor><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="reserved_bytes"><paramtype>std::size_t</paramtype></parameter><description><para>Constructor of the segment_manager_base</para><para>"size" is the size of the memory segment where the basic segment manager is being constructed.</para><para>"reserved_bytes" is the number of bytes after the end of the memory algorithm object itself that the memory algorithm will exclude from dynamic allocation</para><para>Can throw </para></description></constructor><method-group name="public static functions"><method name="get_min_size" cv=""><type>static std::size_t</type><parameter name="size"><paramtype>std::size_t</paramtype></parameter><description><para>Obtains the minimum size needed by the segment manager </para></description></method></method-group></class><class name="segment_manager"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="MemoryAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><inherit access="public">boost::interprocess::segment_manager_base&lt; MemoryAlgorithm &gt;</inherit><description><para>This object is placed in the beginning of memory segment and implements the allocation (named or anonymous) of portions of the segment. This object contains two indexes that maintain an association between a name and a portion of the segment.</para><para>The first index contains the mappings for normal named objects using the char type specified in the template parameter.</para><para>The second index contains the association for unique instances. The key will be the const char * returned from type_info.name() function for the unique type to be constructed.</para><para>segment_manager&lt;CharType, MemoryAlgorithm, IndexType&gt; inherits publicly from segment_manager_base&lt;MemoryAlgorithm&gt; and inherits from it many public functions related to anonymous object and raw memory allocation. See segment_manager_base reference to know about those functions. </para></description><struct name="allocator"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default allocator to allocate types T from this managed segment </para></description><typedef name="type"><type><classname>boost::interprocess::allocator</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef></struct><struct name="deleter"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default deleter to delete types T from this managed segment. </para></description><typedef name="type"><type><classname>boost::interprocess::deleter</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef></struct><typedef name="memory_algorithm"><type>MemoryAlgorithm</type></typedef><typedef name="void_pointer"><type>Base::void_pointer</type></typedef><typedef name="char_type"><type>CharType</type></typedef><typedef name="multiallocation_iterator"><type>Base::multiallocation_iterator</type></typedef><typedef name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef><typedef name="mutex_family"><type>Base::mutex_family</type></typedef><typedef name="const_named_iterator"><type>transform_iterator&lt; typename named_index_t::const_iterator, named_transform &gt;</type></typedef><typedef name="const_unique_iterator"><type>transform_iterator&lt; typename unique_index_t::const_iterator, unique_transform &gt;</type></typedef><data-member name="PayloadPerAllocation" specifiers="static"><type>const std::size_t</type><description><para>This constant indicates the payload size associated with each allocation of the memory algorithm </para></description></data-member><method-group name="public member functions"><method name="find" cv=""><type>std::pair&lt; T *, std::size_t &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>const CharType *</paramtype></parameter><description><para>Tries to find a previous named allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </para></description></method><method name="find" cv=""><type>std::pair&lt; T *, std::size_t &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Tries to find a previous unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </para></description></method><method name="construct" cv=""><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "construct" proxy object </para></description></method><method name="find_or_construct" cv=""><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct" proxy object </para></description></method><method name="construct" cv=""><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Returns no throwing "construct" proxy object </para></description></method><method name="find_or_construct" cv=""><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Returns no throwing "search or construct" proxy object </para></description></method><method name="construct_it" cv=""><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><purpose>Returns throwing "construct from iterators" proxy object. </purpose></method><method name="find_or_construct_it" cv=""><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct from iterators" proxy object </para></description></method><method name="construct_it" cv=""><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Returns no throwing "construct from iterators" proxy object </para></description></method><method name="find_or_construct_it" cv=""><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>std::nothrow_t</paramtype></parameter><description><para>Returns no throwing "search or construct from iterators" proxy object </para></description></method><method name="atomic_func" cv=""><type>*void</type><template>
          <template-type-parameter name="Func"/>
        </template><parameter name="f"><paramtype>Func &amp;</paramtype></parameter><description><para>Calls object function blocking recursive interprocess_mutex and guarantees that no new named_alloc or destroy will be executed by any process while executing the object function call </para></description></method><method name="destroy" cv=""><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Destroys a previously created unique instance. Returns false if the object was not present. </para></description></method><method name="destroy" cv=""><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>const CharType *</paramtype></parameter><description><para>Destroys the named object with the given name. Returns false if that object can't be found. </para></description></method><method name="destroy_ptr" cv=""><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="p"><paramtype>const T *</paramtype></parameter><description><para>Destroys an anonymous, unique or named object using it's address </para></description></method><method name="reserve_named_objects" cv=""><type>void</type><parameter name="num"><paramtype>std::size_t</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" named objects in the managed memory segment. Can throw boost::interprocess::bad_alloc if there is no enough memory. </para></description></method><method name="reserve_unique_objects" cv=""><type>void</type><parameter name="num"><paramtype>std::size_t</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" unique objects in the managed memory segment. Can throw boost::interprocess::bad_alloc if there is no enough memory. </para></description></method><method name="shrink_to_fit_indexes" cv=""><type>void</type><description><para>Calls shrink_to_fit in both named and unique object indexes to try to free unused memory from those indexes. </para></description></method><method name="get_num_named_objects" cv=""><type>std::size_t</type><description><para>Returns the number of named objects stored in the segment. </para></description></method><method name="get_num_unique_objects" cv=""><type>std::size_t</type><description><para>Returns the number of unique objects stored in the segment. </para></description></method><method name="named_begin" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the named allocations performed in this segment manager </para></description></method><method name="named_end" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the end of the information about the named allocations performed in this segment manager </para></description></method><method name="unique_begin" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the unique allocations performed in this segment manager </para></description></method><method name="unique_end" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the end of the information about the unique allocations performed in this segment manager </para></description></method><method name="get_allocator" cv=""><type><classname>allocator</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </para></description></method><method name="get_deleter" cv=""><type><classname>deleter</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </para></description></method></method-group><constructor><parameter name="size"><paramtype>std::size_t</paramtype></parameter><description><para>Constructor of the segment manager "size" is the size of the memory segment where the segment manager is being constructed. Can throw </para></description></constructor><method-group name="public static functions"><method name="get_instance_name" cv=""><type>static const CharType *</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method><method name="get_instance_length" cv=""><type>static std::size_t</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the length of an object created with construct/find_or_construct functions. Does not throw. </para></description></method><method name="get_instance_type" cv=""><type>static instance_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns is the the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method><method name="get_min_size" cv=""><type>static std::size_t</type><description><para>Obtains the minimum size needed by the segment manager </para></description></method></method-group></class><data-member name="anonymous_instance" specifiers="static"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="unique_instance" specifiers="static"><type><emphasis>unspecified</emphasis></type></data-member></namespace></namespace></header><header name="boost/interprocess/shared_memory_object.hpp"><para>Describes a shared memory object management class. </para><namespace name="boost"><namespace name="interprocess"><class name="shared_memory_object"><description><para>A class that wraps a shared memory mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>shared_memory_object</classname> &amp;</paramtype></parameter><purpose>Swaps the shared_memory_objects. Does not throw. </purpose></method><method name="truncate" cv=""><type>void</type><parameter name="length"><paramtype>offset_t</paramtype></parameter><purpose>Sets the size of the shared memory mapping. </purpose></method><method name="get_name" cv="const"><type>const char *</type><purpose>Returns the name of the file. </purpose></method><method name="get_size" cv="const"><type>bool</type><parameter name="size"><paramtype>offset_t &amp;</paramtype></parameter><description><para>Returns the name of the file used in the constructor </para></description></method><method name="get_mode" cv="const"><type>mode_t</type><purpose>Returns access mode. </purpose></method><method name="get_mapping_handle" cv="const"><type>mapping_handle_t</type><purpose>Returns mapping handle. Never throws. </purpose></method></method-group><constructor><description><para>Default constructor. Represents an empty shared_memory_object. </para></description></constructor><constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Creates a shared memory object with name "name" and mode "mode", with the access mode "mode" If the file previously exists, throws an error. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a shared memory object from the system. Returns false on error. Never throws </para></description></method></method-group></class><class name="remove_shared_memory_on_destroy"><description><para>A class that stores the name of a shared memory and calls shared_memory_object::remove(name) in its destructor Useful to remove temporary shared memory objects in the presence of exceptions </para></description><method-group name="public member functions"/><constructor><parameter name="name"><paramtype>const char *</paramtype></parameter></constructor><destructor/></class></namespace></namespace></header><header name="boost/interprocess/smart_ptr/deleter.hpp"><para>Describes the functor to delete objects from the segment. </para><namespace name="boost"><namespace name="interprocess"><class name="deleter"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>A deleter that uses the segment manager's destroy_ptr function to destroy the passed pointer resource.</para><para>This deleter is used </para></description><typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method></method-group><constructor><parameter name="pmngr"><paramtype>segment_manager_pointer</paramtype></parameter></constructor></class></namespace></namespace></header><header name="boost/interprocess/smart_ptr/enable_shared_from_this.hpp"><para>Describes an utility to form a shared pointer from this </para><namespace name="boost"><namespace name="interprocess"><class name="enable_shared_from_this"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
      <template-type-parameter name="D"/>
    </template><description><para>This class is used as a base class that allows a shared_ptr to the current object to be obtained from within a member function. enable_shared_from_this defines two member functions called shared_from_this that return a shared_ptr&lt;T&gt; and shared_ptr&lt;T const&gt;, depending on constness, to this. </para></description><method-group name="public member functions"><method name="shared_from_this" cv=""><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type></method><method name="shared_from_this" cv="const"><type><classname>shared_ptr</classname>&lt; T const, A, D &gt;</type></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/smart_ptr/intrusive_ptr.hpp"><para>Describes an intrusive ownership pointer. </para><namespace name="boost"><namespace name="interprocess"><class name="intrusive_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>The intrusive_ptr class template stores a pointer to an object with an embedded reference count. intrusive_ptr is parameterized on T (the type of the object pointed to) and VoidPointer(a void pointer type that defines the type of pointer that intrusive_ptr will store). intrusive_ptr&lt;T, void *&gt; defines a class with a T* member whereas intrusive_ptr&lt;T, offset_ptr&lt;void&gt; &gt; defines a class with a offset_ptr&lt;T&gt; member. Relies on unqualified calls to:</para><para>void intrusive_ptr_add_ref(T * p); void intrusive_ptr_release(T * p);</para><para>with (p != 0)</para><para>The object is responsible for destroying itself. </para></description><typedef name="pointer"><purpose>Provides the type of the internal stored pointer. </purpose><type><emphasis>unspecified</emphasis></type></typedef><typedef name="element_type"><purpose>Provides the type of the stored pointer. </purpose><type>T</type></typedef><method-group name="public member functions"><method name="get" cv=""><type>pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method><method name="get" cv="const"><type>const pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method><method name="operator*" cv="const"><type>T &amp;</type><description><para>Returns *get(). Does not throw </para></description></method><method name="operator-&gt;" cv="const"><type>const pointer &amp;</type><description><para>Returns *get(). Does not throw </para></description></method><method name="operator-&gt;" cv=""><type>pointer &amp;</type><description><para>Returns get(). Does not throw </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>Conversion to boolean. Does not throw </para></description></method><method name="operator!" cv="const"><type>bool</type><description><para>Not operator. Does not throw </para></description></method><method name="swap" cv=""><type>void</type><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. Does not throw </para></description></method></method-group><constructor><description><para>Constructor. Initializes internal pointer to 0. Does not throw </para></description></constructor><constructor><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="add_ref"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Constructor. Copies pointer and if "p" is not zero and "add_ref" is true calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw </para></description></constructor><constructor><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw </para></description></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Constructor from related. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw </para></description></constructor><destructor><description><para>Destructor. If internal pointer is not 0, calls intrusive_ptr_release(get_pointer(m_ptr)). Does not throw </para></description></destructor><copy-assignment><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> const &amp;</paramtype></parameter><description><para>Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment><copy-assignment><parameter name="rhs"><paramtype>pointer</paramtype></parameter><description><para>Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment></class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() == b.get(). Does not throw </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() != b.get(). Does not throw </para></description></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() == b. Does not throw </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() != b. Does not throw </para></description></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a == b.get(). Does not throw </para></description></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a != b.get(). Does not throw </para></description></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() &lt; b.get(). Does not throw </para></description></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="lhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two intrusive_ptrs. Does not throw </para></description></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; Y, VP &gt; const &amp;</paramtype></parameter></function><function name="get_pointer"><type><classname>boost::interprocess::intrusive_ptr</classname>&lt; T, VP &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt;</paramtype></parameter><description><para>Returns p.get(). Does not throw </para></description></function></namespace></namespace></header><header name="boost/interprocess/smart_ptr/scoped_ptr.hpp"><para>Describes the smart pointer scoped_ptr </para><namespace name="boost"><namespace name="interprocess"><class name="scoped_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Deleter"/>
    </template><description><para>scoped_ptr stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted, either on destruction of the scoped_ptr, or via an explicit reset. The user can avoid this deletion using release(). scoped_ptr is parameterized on T (the type of the object pointed to) and Deleter (the functor to be executed to delete the internal pointer). The internal pointer will be of the same pointer type as typename Deleter::pointer type (that is, if typename Deleter::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;). </para></description><typedef name="element_type"><type>T</type></typedef><typedef name="deleter_type"><type>Deleter</type></typedef><typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="unspecified_bool_type"><type>pointer this_type::*</type></typedef><method-group name="public member functions"><method name="reset" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p. Never throws </para></description></method><method name="reset" cv=""><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p and a copy of d. </para></description></method><method name="release" cv=""><type>pointer</type><description><para>Assigns internal pointer as 0 and returns previous pointer. This will avoid deletion on destructor </para></description></method><method name="operator*" cv="const"><type>reference</type><description><para>Returns a reference to the object pointed to by the stored pointer. Never throws. </para></description></method><method name="operator-&gt;" cv=""><type>pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method><method name="operator-&gt;" cv="const"><type>const pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method><method name="get" cv=""><type>pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method><method name="get" cv="const"><type>const pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>Conversion to bool Never throws </para></description></method><method name="operator!" cv="const"><type>bool</type><description><para>Returns true if the stored pointer is 0. Never throws. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="b"><paramtype><classname>scoped_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other scoped_ptr Never throws. </para></description></method></method-group><constructor><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><purpose>Provides the type of the internal stored pointer. </purpose><description><para>Constructs a scoped_ptr, storing a copy of p(which can be 0) and d. Does not throw. </para></description></constructor><destructor><description><para>If the stored pointer is not 0, destroys the object pointed to by the stored pointer. calling the operator() of the stored deleter. Never throws </para></description></destructor></class><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other scoped_ptr Never throws. </para></description></function><function name="get_pointer"><type><classname>scoped_ptr</classname>&lt; T, D &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="p"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; const &amp;</paramtype></parameter><description><para>Returns a copy of the stored pointer Never throws </para></description></function></namespace></namespace></header><header name="boost/interprocess/smart_ptr/shared_ptr.hpp"><para>Describes the smart pointer shared_ptr </para><namespace name="boost"><namespace name="interprocess"><class name="shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidAllocator"/>
      <template-type-parameter name="Deleter"/>
    </template><description><para>shared_ptr stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted when the last shared_ptr pointing to it is destroyed or reset.</para><para>shared_ptr is parameterized on T (the type of the object pointed to), VoidAllocator (the void allocator to be used to allocate the auxiliary data) and Deleter (the deleter whose operator() will be used to delete the object.</para><para>The internal pointer will be of the same pointer type as typename VoidAllocator::pointer type (that is, if typename VoidAllocator::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;).</para><para>Because the implementation uses reference counting, cycles of shared_ptr instances will not be reclaimed. For example, if main() holds a shared_ptr to A, which directly or indirectly holds a shared_ptr back to A, A's use count will be 2. Destruction of the original shared_ptr will leave A dangling with a use count of 1. Use weak_ptr to "break cycles." </para></description><typedef name="element_type"><type>T</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_deleter_pointer"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_allocator_pointer"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="reset" cv=""><type>void</type><description><para>This is equivalent to: this_type().swap(*this); </para></description></method><method name="reset" cv=""><type>void</type><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>const Pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>This is equivalent to: this_type(p, a, d).swap(*this); </para></description></method><method name="reset" cv=""><type>void</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method><method name="operator*" cv="const"><type>reference</type><description><para>Returns a reference to the pointed type </para></description></method><method name="operator-&gt;" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method><method name="get" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method><method name="operator!" cv="const"><type>bool</type><description><para>Not operator. Returns true if this-&gt;get() != 0, false otherwise </para></description></method><method name="unique" cv="const"><type>bool</type><description><para>Returns use_count() == 1. unique() might be faster than use_count() </para></description></method><method name="use_count" cv="const"><type>long</type><description><para>Returns the number of shared_ptr objects, *this included, that share ownership with *this, or an unspecified nonnegative value when *this is empty. use_count() is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. </para></description></method></method-group><constructor><description><para>Constructs an empty shared_ptr. Use_count() == 0 &amp;&amp; get()== 0. </para></description></constructor><constructor><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>Constructs a shared_ptr that owns the pointer p. Auxiliary data will be allocated with a copy of a and the object will be deleted with a copy of d. Requirements: Deleter and A's copy constructor must not throw. </para></description></constructor><constructor><parameter name="other"><paramtype>const <classname>shared_ptr</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Constructs a shared_ptr that shares ownership with r and stores p. Postconditions: get() == p &amp;&amp; use_count() == r.use_count(). Throws: nothing. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>If r is empty, constructs an empty shared_ptr. Otherwise, constructs a shared_ptr that shares ownership with r. Never throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Constructs a shared_ptr that shares ownership with r and stores a copy of the pointer stored in r. </para></description></constructor><constructor><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Move-Constructs a shared_ptr that takes ownership of other resource and other is put in default-constructed state. Throws: nothing. </para></description></constructor><copy-assignment><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Equivalent to shared_ptr(r).swap(*this). Never throws </para></description></copy-assignment><copy-assignment><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Move-assignment. Equivalent to shared_ptr(other).swap(*this). Never throws </para></description></copy-assignment></class><struct name="managed_shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a shared pointer of type T with the allocator boost::interprocess::allocator allocator and boost::interprocess::deleter deleter that can be constructed in the given managed segment type. </para></description><typedef name="void_allocator"><type>ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::<classname>type</classname></type></typedef><typedef name="deleter"><type>ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::<classname>type</classname></type></typedef><typedef name="type"><type><classname>shared_ptr</classname>&lt; T, void_allocator, <classname>deleter</classname> &gt;</type></typedef></struct><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter></function><function name="static_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function><function name="const_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function><function name="dynamic_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function><function name="get_pointer"><type>T *</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function><function name="make_managed_shared_ptr"><type><classname>managed_shared_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a shared pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function></namespace></namespace></header><header name="boost/interprocess/smart_ptr/unique_ptr.hpp"><para>Describes the smart pointer unique_ptr </para><namespace name="boost"><namespace name="interprocess"><class name="unique_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="D"/>
    </template><description><para>Template unique_ptr stores a pointer to an object and deletes that object using the associated deleter when it is itself destroyed (such as when leaving block scope.</para><para>The unique_ptr provides a semantics of strict ownership. A unique_ptr owns the object it holds a pointer to.</para><para>A unique_ptr is not CopyConstructible, nor CopyAssignable, however it is MoveConstructible and Move-Assignable.</para><para>The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from a function</para><para>A client-supplied template argument D must be a function pointer or functor for which, given a value d of type D and a pointer ptr to a type T*, the expression d(ptr) is valid and has the effect of deallocating the pointer as appropriate for that deleter. D may also be an lvalue-reference to a deleter.</para><para>If the deleter D maintains state, it is intended that this state stay with the associated pointer as ownership is transferred from unique_ptr to unique_ptr. The deleter state need never be copied, only moved or swapped as pointer ownership is moved around. That is, the deleter need only be MoveConstructible, MoveAssignable, and Swappable, and need not be CopyConstructible (unless copied into the unique_ptr) nor CopyAssignable. </para></description><typedef name="element_type"><type>T</type></typedef><typedef name="deleter_type"><type>D</type></typedef><typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator*" cv="const"><type><emphasis>unspecified</emphasis></type><description><para>Requires: get() != 0. Returns: *get(). Throws: nothing. </para></description></method><method name="operator-&gt;" cv="const"><type>pointer</type><description><para>Requires: get() != 0. Returns: get(). Throws: nothing. </para></description></method><method name="get" cv="const"><type>pointer</type><description><para>Returns: The stored pointer. Throws: nothing. </para></description></method><method name="get_deleter" cv=""><type>deleter_reference</type><description><para>Returns: A reference to the stored deleter.</para><para>Throws: nothing. </para></description></method><method name="get_deleter" cv="const"><type>deleter_const_reference</type><description><para>Returns: A const reference to the stored deleter.</para><para>Throws: nothing. </para></description></method><method name="conversion-operator" cv="const"><type>int nat::*</type><description><para>Returns: An unspecified value that, when used in boolean contexts, is equivalent to get() != 0.</para><para>Throws: nothing. </para></description></method><method name="release" cv=""><type>pointer</type><description><para>Postcondition: get() == 0.</para><para>Returns: The value get() had at the start of the call to release.</para><para>Throws: nothing. </para></description></method><method name="reset" cv=""><type>void</type><parameter name="p"><paramtype>pointer</paramtype><default>0</default></parameter><description><para>Effects: If p == get() there are no effects. Otherwise get_deleter()(get()).</para><para>Postconditions: get() == p.</para><para>Throws: nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="u"><paramtype><classname>unique_ptr</classname> &amp;</paramtype></parameter><description><para>Requires: The deleter D is Swappable and will not throw an exception under swap.</para><para>Effects: The stored pointers of this and u are exchanged. The stored deleters are swapped (unqualified). Throws: nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="mu"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method></method-group><constructor><description><para>Requires: D must be default constructible, and that construction must not throw an exception. D must not be a reference type.</para><para>Effects: Constructs a unique_ptr which owns nothing.</para><para>Postconditions: get() == 0. get_deleter() returns a reference to a default constructed deleter D.</para><para>Throws: nothing. </para></description></constructor><constructor><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Requires: The expression D()(p) must be well formed. The default constructor of D must not throw an exception.</para><para>D must not be a reference type.</para><para>Effects: Constructs a unique_ptr which owns p.</para><para>Postconditions: get() == p. get_deleter() returns a reference to a default constructed deleter D.</para><para>Throws: nothing. </para></description></constructor><constructor><parameter name="p"><paramtype>pointer</paramtype></parameter><parameter name="d"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Requires: The expression d(p) must be well formed.</para><para>Postconditions: get() == p. get_deleter() returns a reference to the internally stored deleter. If D is a reference type then get_deleter() returns a reference to the lvalue d.</para><para>Throws: nothing. </para></description></constructor><constructor><parameter name="u"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Requires: If the deleter is not a reference type, construction of the deleter D from an lvalue D must not throw an exception.</para><para>Effects: Constructs a unique_ptr which owns the pointer which u owns (if any). If the deleter is not a reference type, it is move constructed from u's deleter, otherwise the reference is copy constructed from u's deleter.</para><para>After the construction, u no longer owns a pointer. [ Note: The deleter constructor can be implemented with std::detail::forward_impl&lt;D&gt;. -end note ]</para><para>Postconditions: get() == value u.get() had before the construction. get_deleter() returns a reference to the internally stored deleter which was constructed from u.get_deleter(). If D is a reference type then get_- deleter() and u.get_deleter() both reference the same lvalue deleter.</para><para>Throws: nothing. </para></description></constructor><constructor><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="E"/>
        </template><parameter name="u"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>nat()</default></parameter><description><para>Requires: If D is not a reference type, construction of the deleter D from an rvalue of type E must be well formed and not throw an exception. If D is a reference type, then E must be the same type as D (diagnostic required). unique_ptr&lt;U, E&gt;::pointer must be implicitly convertible to pointer.</para><para>Effects: Constructs a unique_ptr which owns the pointer which u owns (if any). If the deleter is not a reference type, it is move constructed from u's deleter, otherwise the reference is copy constructed from u's deleter.</para><para>After the construction, u no longer owns a pointer.</para><para>postconditions get() == value u.get() had before the construction, modulo any required offset adjustments resulting from the cast from U* to T*. get_deleter() returns a reference to the internally stored deleter which was constructed from u.get_deleter().</para><para>Throws: nothing. </para></description></constructor><destructor><description><para>Effects: If get() == 0 there are no effects. Otherwise get_deleter()(get()).</para><para>Throws: nothing. </para></description></destructor><copy-assignment><parameter name="u"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Requires: Assignment of the deleter D from an rvalue D must not throw an exception.</para><para>Effects: reset(u.release()) followed by a move assignment from u's deleter to this deleter.</para><para>Postconditions: This unique_ptr now owns the pointer which u owned, and u no longer owns it.</para><para>Returns: *this.</para><para>Throws: nothing. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="E"/>
        </template><parameter name="mu"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Requires: Assignment of the deleter D from an rvalue D must not throw an exception. U* must be implicitly convertible to T*.</para><para>Effects: reset(u.release()) followed by a move assignment from u's deleter to this deleter. If either D or E is a reference type, then the referenced lvalue deleter participates in the move assignment.</para><para>Postconditions: This unique_ptr now owns the pointer which u owned, and u no longer owns it.</para><para>Returns: *this.</para><para>Throws: nothing. </para></description></copy-assignment><copy-assignment><parameter name=""><paramtype>int nat::*</paramtype></parameter><description><para>Assigns from the literal 0 or NULL.</para><para>Effects: reset().</para><para>Postcondition: get() == 0</para><para>Returns: *this.</para><para>Throws: nothing. </para></description></copy-assignment></class><struct name="managed_unique_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a unique pointer of type T with boost::interprocess::deleter deleter that can be constructed in the given managed segment type. </para></description><typedef name="type"><type><classname>unique_ptr</classname>&lt; T, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::<classname>type</classname> &gt;</type></typedef></struct><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype><classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter></function><function name="make_managed_unique_ptr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of the a unique pointer constructed with boost::interproces::deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function></namespace></namespace></header><header name="boost/interprocess/smart_ptr/weak_ptr.hpp"><para>Describes the smart pointer weak_ptr. </para><namespace name="boost"><namespace name="interprocess"><class name="weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
      <template-type-parameter name="D"/>
    </template><description><para>The weak_ptr class template stores a "weak reference" to an object that's already managed by a shared_ptr. To access the object, a weak_ptr can be converted to a shared_ptr using the shared_ptr constructor or the member function lock. When the last shared_ptr to the object goes away and the object is deleted, the attempt to obtain a shared_ptr from the weak_ptr instances that refer to the deleted object will fail: the constructor will throw an exception of type bad_weak_ptr, and weak_ptr::lock will return an empty shared_ptr.</para><para>Every weak_ptr meets the CopyConstructible and Assignable requirements of the C++ Standard Library, and so can be used in standard library containers. Comparison operators are supplied so that weak_ptr works with the standard library's associative containers.</para><para>weak_ptr operations never throw exceptions.</para><para>The class template is parameterized on T, the type of the object pointed to. </para></description><typedef name="element_type"><type>T</type></typedef><typedef name="value_type"><type>T</type></typedef><method-group name="public member functions"><method name="lock" cv="const"><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type><description><para>Returns: expired()? shared_ptr&lt;T&gt;(): shared_ptr&lt;T&gt;(*this).</para><para>Throws: nothing. </para></description></method><method name="use_count" cv="const"><type>long</type><description><para>Returns: 0 if *this is empty; otherwise, the number of shared_ptr objects that share ownership with *this.</para><para>Throws: nothing.</para><para>Notes: use_count() is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method><method name="expired" cv="const"><type>bool</type><description><para>Returns: Returns: use_count() == 0.</para><para>Throws: nothing.</para><para>Notes: expired() may be faster than use_count(). </para></description></method><method name="reset" cv=""><type>void</type><description><para>Effects: Equivalent to: weak_ptr().swap(*this). </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype>this_type &amp;</paramtype></parameter><description><para>Effects: Exchanges the contents of the two smart pointers.</para><para>Throws: nothing. </para></description></method></method-group><constructor><description><para>Effects: Constructs an empty weak_ptr. Postconditions: use_count() == 0. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty weak_ptr; otherwise, constructs a weak_ptr that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: use_count() == r.use_count().</para><para>Throws: nothing. </para></description></constructor><constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty weak_ptr; otherwise, constructs a weak_ptr that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: use_count() == r.use_count().</para><para>Throws: nothing. </para></description></constructor><copy-assignment><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment></class><struct name="managed_weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a weak pointer of type T with the allocator boost::interprocess::allocator allocator and boost::interprocess::deleter deleter that can be constructed in the given managed segment type. </para></description><typedef name="type"><type><classname>weak_ptr</classname>&lt; T, typename ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::<classname>type</classname>, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::<classname>type</classname> &gt;</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; U, A2, D2 &gt; const &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter></function><function name="make_managed_weak_ptr"><type><classname>managed_weak_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of the a weak pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function></namespace></namespace></header><header name="boost/interprocess/streams/bufferstream.hpp"><para>This file defines basic_bufferbuf, basic_ibufferstream, basic_obufferstream, and basic_bufferstream classes. These classes represent streamsbufs and streams whose sources or destinations are fixed size character buffers. </para><namespace name="boost"><namespace name="interprocess"><class name="basic_bufferbuf"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A streambuf class that controls the transmission of elements to and from a basic_xbufferstream. The elements are transmitted from a to a fixed size buffer </para></description><typedef name="char_type"><type>CharT</type></typedef><typedef name="int_type"><type>CharTraits::int_type</type></typedef><typedef name="pos_type"><type>CharTraits::pos_type</type></typedef><typedef name="off_type"><type>CharTraits::off_type</type></typedef><typedef name="traits_type"><type>CharTraits</type></typedef><typedef name="base_t"><type>std::basic_streambuf&lt; char_type, traits_type &gt;</type></typedef><method-group name="public member functions"><method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method><method name="buffer" cv=""><type>void</type><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value Does not throw. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor><constructor><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor><destructor/></class><class name="basic_ibufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_istream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method><method name="buffer" cv="const"><type>std::pair&lt; const CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method><method name="buffer" cv=""><type>void</type><parameter name="buffer"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor><constructor><parameter name="buffer"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor><destructor/></class><class name="basic_obufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_ostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method><method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method><method name="buffer" cv=""><type>void</type><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor><constructor><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor><destructor/></class><class name="basic_bufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_iostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method><method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method><method name="buffer" cv=""><type>void</type><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor><constructor><parameter name="buffer"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor><destructor/></class><typedef name="bufferbuf"><type><classname>basic_bufferbuf</classname>&lt; char &gt;</type></typedef><typedef name="bufferstream"><type><classname>basic_bufferstream</classname>&lt; char &gt;</type></typedef><typedef name="ibufferstream"><type><classname>basic_ibufferstream</classname>&lt; char &gt;</type></typedef><typedef name="obufferstream"><type><classname>basic_obufferstream</classname>&lt; char &gt;</type></typedef><typedef name="wbufferbuf"><type><classname>basic_bufferbuf</classname>&lt; wchar_t &gt;</type></typedef><typedef name="wbufferstream"><type><classname>basic_bufferstream</classname>&lt; wchar_t &gt;</type></typedef><typedef name="wibufferstream"><type><classname>basic_ibufferstream</classname>&lt; wchar_t &gt;</type></typedef><typedef name="wobufferstream"><type><classname>basic_obufferstream</classname>&lt; wchar_t &gt;</type></typedef></namespace></namespace></header><header name="boost/interprocess/streams/vectorstream.hpp"><para>This file defines basic_vectorbuf, basic_ivectorstream, basic_ovectorstream, and basic_vectorstreamclasses. These classes represent streamsbufs and streams whose sources or destinations are STL-like vectors that can be swapped with external vectors to avoid unnecessary allocations/copies. </para><namespace name="boost"><namespace name="interprocess"><class name="basic_vectorbuf"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A streambuf class that controls the transmission of elements to and from a basic_ivectorstream, basic_ovectorstream or basic_vectorstream. It holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef><typedef name="char_type"><type>CharVector::value_type</type></typedef><typedef name="int_type"><type>CharTraits::int_type</type></typedef><typedef name="pos_type"><type>CharTraits::pos_type</type></typedef><typedef name="off_type"><type>CharTraits::off_type</type></typedef><typedef name="traits_type"><type>CharTraits</type></typedef><method-group name="public member functions"><method name="swap_vector" cv=""><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method><method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Preallocates memory from the internal vector. Resets the stream to the first position. Throws if the internals vector's memory allocation throws. </para></description></method><method name="clear" cv=""><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor><destructor/></class><class name="basic_ivectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_istream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef><typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method><method name="swap_vector" cv=""><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read position in the stream. Does not throw. </para></description></method><method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method><method name="clear" cv=""><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor><destructor/></class><class name="basic_ovectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_ostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef><typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method><method name="swap_vector" cv=""><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the write position in the stream. Does not throw. </para></description></method><method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor><destructor/></class><class name="basic_vectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><description><para>A basic_iostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef><typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef><typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef><typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef><typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef><typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef><method-group name="public member functions"><method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type></method><method name="swap_vector" cv=""><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method><method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method><method name="reserve" cv=""><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method><method name="clear" cv=""><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method></method-group><constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor><destructor/></class></namespace></namespace></header><header name="boost/interprocess/sync/file_lock.hpp"><para>Describes a class that wraps file locking capabilities. </para><namespace name="boost"><namespace name="interprocess"><class name="file_lock"><description><para>A file lock, is a mutual exclusion utility similar to a mutex using a file. A file lock has sharable and exclusive locking capabilities and can be used with scoped_lock and sharable_lock classes. A file lock can't guarantee synchronization between threads of the same process so just use file locks to synchronize threads from different processes. </para></description><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has has exclusive, or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="lock_sharable" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock_sharable" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock_sharable" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method></method-group><constructor><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a file lock. Throws interprocess_exception if the file does not exist or there are no operating system resources. </para></description></constructor><destructor><purpose>Closes a file lock. Does not throw. </purpose></destructor></class></namespace></namespace></header><header name="boost/interprocess/sync/interprocess_barrier.hpp"><namespace name="boost"><namespace name="interprocess"><class name="barrier"><description><para>An object of class barrier is a synchronization primitive that can be placed in shared memory used to cause a set of threads from different processes to wait until they each perform a certain function or each reach a particular point in their execution. </para></description><method-group name="public member functions"><method name="wait" cv=""><type>bool</type><description><para>Effects: Wait until N threads call wait(), where N equals the count provided to the constructor for the barrier object. Note that if the barrier is destroyed before wait() can return, the behavior is undefined. Returns: Exactly one of the N threads will receive a return value of true, the others will receive a value of false. Precisely which thread receives the return value of true will be implementation-defined. Applications can use this value to designate one thread as a leader that will take a certain action, and the other threads emerging from the barrier can wait for that action to take place. </para></description></method></method-group><constructor><parameter name="count"><paramtype>unsigned int</paramtype></parameter><description><para>Constructs a barrier object that will cause count threads to block on a call to wait(). </para></description></constructor><destructor><description><para>Destroys *this. If threads are still executing their wait() operations, the behavior for these threads is undefined. </para></description></destructor></class></namespace></namespace><macro name="BOOST_INTERPROCESS_USE_GENERIC_EMULATION"/></header><header name="boost/interprocess/sync/interprocess_condition.hpp"><para>Describes process-shared variables interprocess_condition class </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_condition"><description><para>This class is a condition variable that can be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions"><method name="notify_one" cv=""><type>void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method><method name="notify_all" cv=""><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method><method name="wait" cv=""><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the interprocess_mutex object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method><method name="wait" cv=""><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method><method name="timed_wait" cv=""><type>bool</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Releases the lock on the interprocess_mutex object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method><method name="timed_wait" cv=""><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method></method-group><constructor><description><para>Constructs a interprocess_condition. On error throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this liberating system resources. </para></description></destructor></class></namespace><namespace name="posix_time"/></namespace><macro name="BOOST_INTERPROCESS_USE_GENERIC_EMULATION"/></header><header name="boost/interprocess/sync/interprocess_mutex.hpp"><para>Describes a mutex class that can be placed in memory shared by several processes. </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_mutex"><description><para>Wraps a interprocess_mutex that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. Throws: interprocess_exception on error. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex returns immediately. Returns: If the thread acquires ownership of the mutex, returns true, if the another thread has ownership of the mutex, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread will try to obtain exclusive ownership of the mutex if it can do so in until the specified time is reached. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Returns: If the thread acquires ownership of the mutex, returns true, if the timeout expires returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. Throws: interprocess_exception on error. </para></description></method></method-group><constructor><description><para>Constructor. Throws interprocess_exception on error. </para></description></constructor><destructor><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor></class></namespace></namespace><macro name="BOOST_INTERPROCESS_USE_GENERIC_EMULATION"/></header><header name="boost/interprocess/sync/interprocess_recursive_mutex.hpp"><para>Describes interprocess_recursive_mutex and shared_recursive_try_mutex classes </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_recursive_mutex"><description><para>Wraps a interprocess_mutex that can be placed in shared memory and can be shared between processes. Allows several locking calls by the same process. Allows timed lock tries </para></description><method-group name="public member functions"><method name="lock" cv=""><type>void</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. The mutex must be unlocked the same number of times it is locked. Throws: interprocess_exception on error. </para></description></method><method name="try_lock" cv=""><type>bool</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>Tries to lock the interprocess_mutex, returns false when interprocess_mutex is already locked, returns true when success. The mutex must be unlocked the same number of times it is locked. Throws: interprocess_exception if a severe error is found </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Tries to lock the interprocess_mutex, if interprocess_mutex can't be locked before abs_time time, returns false. The mutex must be unlocked the same number of times it is locked. Throws: interprocess_exception if a severe error is found </para></description></method><method name="unlock" cv=""><type>void</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Throws: interprocess_exception on error. </para></description></method></method-group><constructor><description><para>Constructor. Throws interprocess_exception on error. </para></description></constructor><destructor><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor></class></namespace></namespace><macro name="BOOST_INTERPROCESS_USE_GENERIC_EMULATION"/></header><header name="boost/interprocess/sync/interprocess_semaphore.hpp"><para>Describes a interprocess_semaphore class for inter-process synchronization </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_semaphore"><description><para>Wraps a interprocess_semaphore that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions"><method name="post" cv=""><type>void</type><description><para>Increments the interprocess_semaphore count. If there are processes/threads blocked waiting for the interprocess_semaphore, then one of these processes will return successfully from its wait function. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="wait" cv=""><type>void</type><description><para>Decrements the interprocess_semaphore. If the interprocess_semaphore value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="try_wait" cv=""><type>bool</type><description><para>Decrements the interprocess_semaphore if the interprocess_semaphore's value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="timed_wait" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Decrements the interprocess_semaphore if the interprocess_semaphore's value is greater than zero and returns true. Otherwise, waits for the interprocess_semaphore to the posted or the timeout expires. If the timeout expires, the function returns false. If the interprocess_semaphore is posted the function returns true. If there is an error throws sem_exception </para></description></method></method-group><constructor><parameter name="initialCount"><paramtype>int</paramtype></parameter><description><para>Creates a interprocess_semaphore with the given initial count. interprocess_exception if there is an error. </para></description></constructor><destructor><description><para>Destroys the interprocess_semaphore. Does not throw </para></description></destructor></class></namespace></namespace><macro name="BOOST_INTERPROCESS_USE_GENERIC_EMULATION"/></header><header name="boost/interprocess/sync/interprocess_upgradable_mutex.hpp"><para>Describes interprocess_upgradable_mutex class </para><namespace name="boost"><namespace name="interprocess"><class name="interprocess_upgradable_mutex"><description><para>Wraps a interprocess_upgradable_mutex that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="private member functions"/><constructor><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></constructor><copy-assignment><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></copy-assignment><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="lock_sharable" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock_sharable" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock_sharable" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="lock_upgradable" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock_upgradable" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock_upgradable" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock_upgradable" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_and_lock_upgradable" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_and_lock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_upgradable_and_lock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_upgradable_and_lock" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership release their sharable lock. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_upgradable_and_lock" cv=""><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="timed_unlock_upgradable_and_lock" cv=""><type>*bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_sharable_and_lock" cv=""><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_sharable_and_lock_upgradable" cv=""><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method></method-group><constructor><description><para>Constructs the upgradable lock. Throws interprocess_exception on error. </para></description></constructor><destructor><description><para>Destroys the upgradable lock. Does not throw. </para></description></destructor></class></namespace></namespace></header><header name="boost/interprocess/sync/lock_options.hpp"><para>Describes the lock options with associated with interprocess_mutex lock constructors. </para><namespace name="boost"><namespace name="interprocess"><data-member name="defer_lock" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>An object indicating that the locking must be deferred. </para></description></data-member><data-member name="try_to_lock" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>An object indicating that the a try_lock() operation must be executed. </para></description></data-member><data-member name="accept_ownership" specifiers="static"><type><emphasis>unspecified</emphasis></type><description><para>An object indicating that the ownership of lockable object must be accepted by the new owner. </para></description></data-member></namespace><namespace name="posix_time"/></namespace></header><header name="boost/interprocess/sync/mutex_family.hpp"><para>Describes a shared interprocess_mutex family fit algorithm used to allocate objects in shared memory. </para><namespace name="boost"><namespace name="interprocess"><struct name="mutex_family"><description><para>Describes interprocess_mutex family to use with Interprocess framework based on boost::interprocess synchronization objects. </para></description><typedef name="mutex_type"><type><classname>boost::interprocess::interprocess_mutex</classname></type></typedef><typedef name="recursive_mutex_type"><type><classname>boost::interprocess::interprocess_recursive_mutex</classname></type></typedef></struct><struct name="null_mutex_family"><description><para>Describes interprocess_mutex family to use with Interprocess frameworks based on null operation synchronization objects. </para></description><typedef name="mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef><typedef name="recursive_mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef></struct></namespace></namespace></header><header name="boost/interprocess/sync/named_condition.hpp"><para>Describes process-shared variables interprocess_condition class </para><namespace name="boost"><namespace name="interprocess"><class name="named_condition"><description><para>A global condition variable that can be created by name. This condition variable is designed to work with named_mutex and can't be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions"><method name="notify_one" cv=""><type>*void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method><method name="notify_all" cv=""><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method><method name="wait" cv=""><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the interprocess_mutex object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method><method name="wait" cv=""><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method><method name="timed_wait" cv=""><type>bool</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Releases the lock on the interprocess_mutex object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method><method name="timed_wait" cv=""><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method></method-group><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws interprocess_exception </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition(open_only_t, ... ) Does not throw </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/sync/named_mutex.hpp"><para>Describes a named mutex class for inter-process synchronization </para><namespace name="boost"><namespace name="interprocess"><class name="named_mutex"><description><para>A mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named_mutex. </para></description><method-group name="public member functions"><method name="unlock" cv=""><type>void</type><description><para>Unlocks a previously locked interprocess_mutex. </para></description></method><method name="lock" cv=""><type>void</type><description><para>Locks interprocess_mutex, sleeps when interprocess_mutex is already locked. Throws interprocess_exception if a severe error is found </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Tries to lock the interprocess_mutex, returns false when interprocess_mutex is already locked, returns true when success. Throws interprocess_exception if a severe error is found </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Tries to lock the interprocess_mutex until time abs_time, Returns false when timeout expires, returns true when locks. Throws interprocess_exception if a severe error is found </para></description></method></method-group><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Creates a global interprocess_mutex with a name. Throws interprocess_exception on error. </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens or creates a global mutex with a name. If the mutex is created, this call is equivalent to named_mutex(create_only_t, ... ) If the mutex is already created, this call is equivalent named_mutex(open_only_t, ... ) Does not throw </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global mutex with a name if that mutex is previously created. If it is not previously created this function throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named mutex from the system. Returns false on error. Never throws. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/sync/named_recursive_mutex.hpp"><para>Describes a named named_recursive_mutex class for inter-process synchronization </para><namespace name="boost"><namespace name="interprocess"><class name="named_recursive_mutex"><description><para>A recursive mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named_recursive_mutex. </para></description><method-group name="public member functions"><method name="unlock" cv=""><type>void</type><description><para>Unlocks a previously locked named_recursive_mutex. </para></description></method><method name="lock" cv=""><type>void</type><description><para>Locks named_recursive_mutex, sleeps when named_recursive_mutex is already locked. Throws interprocess_exception if a severe error is found. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Tries to lock the named_recursive_mutex, returns false when named_recursive_mutex is already locked, returns true when success. Throws interprocess_exception if a severe error is found. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Tries to lock the named_recursive_mutex until time abs_time, Returns false when timeout expires, returns true when locks. Throws interprocess_exception if a severe error is found </para></description></method></method-group><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Creates a global recursive_mutex with a name. If the recursive_mutex can't be created throws interprocess_exception </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens or creates a global recursive_mutex with a name. If the recursive_mutex is created, this call is equivalent to named_recursive_mutex(create_only_t, ... ) If the recursive_mutex is already created, this call is equivalent named_recursive_mutex(open_only_t, ... ) Does not throw </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global recursive_mutex with a name if that recursive_mutex is previously created. If it is not previously created this function throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named recursive mutex from the system </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/sync/named_semaphore.hpp"><para>Describes a named semaphore class for inter-process synchronization </para><namespace name="boost"><namespace name="interprocess"><class name="named_semaphore"><description><para>A semaphore with a global name, so it can be found from different processes. Allows several resource sharing patterns and efficient acknowledgment mechanisms. </para></description><method-group name="public member functions"><method name="post" cv=""><type>void</type><description><para>Increments the semaphore count. If there are processes/threads blocked waiting for the semaphore, then one of these processes will return successfully from its wait function. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="wait" cv=""><type>void</type><description><para>Decrements the semaphore. If the semaphore value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="try_wait" cv=""><type>bool</type><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an interprocess_exception exception is thrown. </para></description></method><method name="timed_wait" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. Otherwise, waits for the semaphore to the posted or the timeout expires. If the timeout expires, the function returns false. If the semaphore is posted the function returns true. If there is an error throws sem_exception </para></description></method></method-group><constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>int</paramtype></parameter><description><para>Creates a global semaphore with a name, and an initial count. If the semaphore can't be created throws interprocess_exception </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>int</paramtype></parameter><description><para>Opens or creates a global semaphore with a name, and an initial count. If the semaphore is created, this call is equivalent to named_semaphore(create_only_t, ...) If the semaphore is already created, this call is equivalent to named_semaphore(open_only_t, ... ) and initialCount is ignored. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global semaphore with a name if that semaphore is previously. created. If it is not previously created this function throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named semaphore from the system. Returns false on error. Never throws. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/sync/named_upgradable_mutex.hpp"><para>Describes a named upgradable mutex class for inter-process synchronization </para><namespace name="boost"><namespace name="interprocess"><class name="named_upgradable_mutex"><description><para>A upgradable mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named upgradable mutex. </para></description><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="lock_sharable" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock_sharable" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock_sharable" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="lock_upgradable" cv=""><type>void</type><description><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: interprocess_exception on error. </para></description></method><method name="try_lock_upgradable" cv=""><type>bool</type><description><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: interprocess_exception on error. </para></description></method><method name="timed_lock_upgradable" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: interprocess_exception on error. </para></description></method><method name="unlock_upgradable" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_and_lock_upgradable" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_and_lock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_upgradable_and_lock_sharable" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="unlock_upgradable_and_lock" cv=""><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership releas it. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_upgradable_and_lock" cv=""><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="timed_unlock_upgradable_and_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_sharable_and_lock" cv=""><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from interprocess_exception on error. </para></description></method><method name="try_unlock_sharable_and_lock_upgradable" cv=""><type>bool</type></method></method-group><constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Creates a global upgradable mutex with a name. If the upgradable mutex can't be created throws interprocess_exception </para></description></constructor><constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens or creates a global upgradable mutex with a name, and an initial count. If the upgradable mutex is created, this call is equivalent to named_upgradable_mutex(create_only_t, ...) If the upgradable mutex is already created, this call is equivalent to named_upgradable_mutex(open_only_t, ... ). </para></description></constructor><constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global upgradable mutex with a name if that upgradable mutex is previously. created. If it is not previously created this function throws interprocess_exception. </para></description></constructor><destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor><method-group name="public static functions"><method name="remove" cv=""><type>static bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named upgradable mutex from the system. Returns false on error. Never throws. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/interprocess/sync/null_mutex.hpp"><para>Describes null_mutex classes </para><namespace name="boost"><namespace name="interprocess"><class name="null_mutex"><description><para>Implements a mutex that simulates a mutex without doing any operation and simulates a successful operation. </para></description><method-group name="public member functions"><method name="lock" cv=""><type>void</type><purpose>Simulates a mutex lock() operation. Empty function. </purpose></method><method name="try_lock" cv=""><type>bool</type><description><para>Simulates a mutex try_lock() operation. Equivalent to "return true;" </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name=""><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock() operation. Equivalent to "return true;" </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Simulates a mutex unlock() operation. Empty function. </para></description></method><method name="lock_sharable" cv=""><type>void</type><description><para>Simulates a mutex lock_sharable() operation. Empty function. </para></description></method><method name="try_lock_sharable" cv=""><type>bool</type><description><para>Simulates a mutex try_lock_sharable() operation. Equivalent to "return true;" </para></description></method><method name="timed_lock_sharable" cv=""><type>bool</type><parameter name=""><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock_sharable() operation. Equivalent to "return true;" </para></description></method><method name="unlock_sharable" cv=""><type>void</type><description><para>Simulates a mutex unlock_sharable() operation. Empty function. </para></description></method><method name="lock_upgradable" cv=""><type>void</type><description><para>Simulates a mutex lock_upgradable() operation. Empty function. </para></description></method><method name="try_lock_upgradable" cv=""><type>bool</type><description><para>Simulates a mutex try_lock_upgradable() operation. Equivalent to "return true;" </para></description></method><method name="timed_lock_upgradable" cv=""><type>bool</type><parameter name=""><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock_upgradable() operation. Equivalent to "return true;" </para></description></method><method name="unlock_upgradable" cv=""><type>void</type><description><para>Simulates a mutex unlock_upgradable() operation. Empty function. </para></description></method><method name="unlock_and_lock_upgradable" cv=""><type>void</type><description><para>Simulates unlock_and_lock_upgradable(). Empty function. </para></description></method><method name="unlock_and_lock_sharable" cv=""><type>void</type><description><para>Simulates unlock_and_lock_sharable(). Empty function. </para></description></method><method name="unlock_upgradable_and_lock_sharable" cv=""><type>void</type><description><para>Simulates unlock_upgradable_and_lock_sharable(). Empty function. </para></description></method><method name="unlock_upgradable_and_lock" cv=""><type>void</type><description><para>Simulates unlock_upgradable_and_lock(). Empty function. </para></description></method><method name="try_unlock_upgradable_and_lock" cv=""><type>bool</type><description><para>Simulates try_unlock_upgradable_and_lock(). Equivalent to "return true;" </para></description></method><method name="timed_unlock_upgradable_and_lock" cv=""><type>bool</type><parameter name=""><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Simulates timed_unlock_upgradable_and_lock(). Equivalent to "return true;" </para></description></method><method name="try_unlock_sharable_and_lock" cv=""><type>bool</type><description><para>Simulates try_unlock_sharable_and_lock(). Equivalent to "return true;" </para></description></method><method name="try_unlock_sharable_and_lock_upgradable" cv=""><type>bool</type><description><para>Simulates try_unlock_sharable_and_lock_upgradable(). Equivalent to "return true;" </para></description></method></method-group><constructor><description><para>Constructor. Empty. </para></description></constructor><destructor><description><para>Destructor. Empty. </para></description></destructor></class></namespace><namespace name="posix_time"/></namespace></header><header name="boost/interprocess/sync/scoped_lock.hpp"><para>Describes the scoped_lock class. </para><namespace name="boost"><namespace name="interprocess"><class name="scoped_lock"><template>
      <template-type-parameter name="Mutex"/>
    </template><description><para>scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of scoped_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership transfer is supported through the syntax of move semantics. Ownership transfer is allowed both by construction and assignment. The scoped_lock does not support copy semantics. A compile time error results if copy construction or copy assignment is attempted. Mutex ownership can also be moved from an upgradable_lock and sharable_lock via constructor. In this role, scoped_lock shares the same functionality as a write_lock. </para></description><typedef name="mutex_type"><type>Mutex</type></typedef><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls lock() on the referenced mutex. Postconditions: owns() == true. Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method><method name="try_lock" cv=""><type>*bool</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock(). Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="timed_lock" cv=""><type>*bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt; timed_lock(abs_time). Notes: The scoped_lock changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="unlock" cv=""><type>*void</type><description><para>Effects: If mutex() == 0 or if not locked, throws a lock_exception() exception. Calls unlock() on the referenced mutex. Postconditions: owns() == false. Notes: The scoped_lock changes from a state of owning the mutex, to not owning the mutex. </para></description></method><method name="owns" cv="const"><type>bool</type><description><para>Effects: Returns true if this scoped_lock has acquired the referenced mutex. </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method><method name="mutex" cv="const"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method><method name="release" cv=""><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method></method-group><constructor><description><para>Effects: Default constructs a scoped_lock. Postconditions: owns() == false and mutex() == 0. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock(). Postconditions: owns() == true and mutex() == &amp;m. Notes: The constructor will take ownership of the mutex. If another thread already owns the mutex, this thread will block until the mutex is released. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already locked. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: m.try_lock(). Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock() executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: m.timed_lock(abs_time). Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock(abs_time) executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do it until abs_time is reached. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="scop"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: mutex() == the value scop.mutex() had before the constructor executes. s1.mutex() == 0. owns() == the value of scop.owns() before the constructor executes. scop.owns(). Notes: If the scop scoped_lock owns the mutex, ownership is moved to thisscoped_lock with no blocking. If the scop scoped_lock does not own the mutex, then neither will this scoped_lock. Only a moved scoped_lock's will match this signature. An non-moved scoped_lock can be moved with the expression: "detail::move_impl(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock() on the referenced mutex. upgr.release() is called. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0. owns() == upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this scoped_lock while unlocking upgr. If upgr is unlocked, then this scoped_lock will be unlocked as well. Only a moved upgradable_lock's will match this signature. An non-moved upgradable_lock can be moved with the expression: "detail::move_impl(lock);" This constructor may block if other threads hold a sharable_lock on this mutex (sharable_lock's can share ownership with an upgradable_lock). </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If upgr.owns() then calls try_unlock_upgradable_and_lock() on the referenced mutex: a)if try_unlock_upgradable_and_lock() returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if try_unlock_upgradable_and_lock() returns false then upgr is unaffected and this scoped_lock construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="abs_time"><paramtype>boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: If upgr.owns() then calls timed_unlock_upgradable_and_lock(abs_time) on the referenced mutex: a)if timed_unlock_upgradable_and_lock(abs_time) returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if timed_unlock_upgradable_and_lock(abs_time) returns false then upgr is unaffected and this scoped_lock construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor><constructor><parameter name="shar"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock() on the referenced mutex. a)if try_unlock_sharable_and_lock() returns true then mutex() obtains the value from shar.release() and owns() is set to true. b)if try_unlock_sharable_and_lock() returns false then shar is unaffected and this scoped_lock construction has the same effects as a default construction. c)Else shar.owns() is false. mutex() obtains the value from shar.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor><destructor><description><para>Effects: if (owns()) mp_mutex-&gt;unlock(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor><copy-assignment><parameter name="scop"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If owns() before the call, then unlock() is called on mutex(). this gets the state of scop and scop gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and scop own the same mutex before the assignment. In this case, this will own the mutex after the assignment (and scop will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment></class></namespace></namespace></header><header name="boost/interprocess/sync/sharable_lock.hpp"><para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost"><namespace name="interprocess"><class name="sharable_lock"><template>
      <template-type-parameter name="SharableMutex"/>
    </template><description><para>sharable_lock is meant to carry out the tasks for sharable-locking (such as read-locking), unlocking, try-sharable-locking and timed-sharable-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of sharable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among sharable_locks, and a single upgradable_lock. sharable_lock does not support copy semantics. But sharable_lock supports ownership transfer from an sharable_lock, upgradable_lock and scoped_lock via trasfer_lock syntax. </para></description><typedef name="mutex_type"><type>SharableMutex</type></typedef><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls lock_sharable() on the referenced mutex. Postconditions: owns() == true. Notes: The sharable_lock changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls try_lock_sharable() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock_sharable(). Notes: The sharable_lock changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls timed_lock_sharable(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_sharable(elps_time). Notes: The sharable_lock changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Effects: If mutex() == 0 or not locked, throws a lock_exception() exception. Calls unlock_sharable() on the referenced mutex. Postconditions: owns() == false. Notes: The sharable_lock changes from a state of owning the mutex, to not owning the mutex. </para></description></method><method name="owns" cv="const"><type>bool</type><description><para>Effects: Returns true if this scoped_lock has acquired the referenced mutex. </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method><method name="mutex" cv="const"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method><method name="release" cv=""><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method></method-group><constructor><description><para>Effects: Default constructs a sharable_lock. Postconditions: owns() == false and mutex() == 0. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock_sharable(). Postconditions: owns() == true and mutex() == &amp;m. Notes: The constructor will take sharable-ownership of the mutex. If another thread already owns the mutex with exclusive ownership (scoped_lock), this thread will block until the mutex is released. If another thread owns the mutex with sharable or upgradable ownership, then no blocking will occur. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already sharable locked. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: m.try_lock_sharable() Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_sharable(abs_time) Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: mutex() == upgr.mutex(). owns() == the value of upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If the upgr sharable_lock owns the mutex, ownership is moved to this sharable_lock with no blocking. If the upgr sharable_lock does not own the mutex, then neither will this sharable_lock. Only a moved sharable_lock's will match this signature. An non-moved sharable_lock can be moved with the expression: "detail::move_impl(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock_sharable() on the referenced mutex. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0 owns() == the value of upgr.owns() before construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this sharable_lock while unlocking upgr. Only a moved sharable_lock's will match this signature. An non-moved upgradable_lock can be moved with the expression: "detail::move_impl(lock);". </para></description></constructor><constructor><parameter name="scop"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If scop.owns() then calls unlock_and_lock_sharable() on the referenced mutex. Postconditions: mutex() == the value scop.mutex() had before the construction. scop.mutex() == 0 owns() == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive ownership to a sharable-ownership of this sharable_lock. Only a moved scoped_lock's will match this signature. An non-moved scoped_lock can be moved with the expression: "detail::move_impl(lock);". </para></description></constructor><destructor><description><para>Effects: if (owns()) mp_mutex-&gt;unlock_sharable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor><copy-assignment><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If owns() before the call, then unlock_sharable() is called on mutex(). this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment></class></namespace></namespace></header><header name="boost/interprocess/sync/upgradable_lock.hpp"><para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost"><namespace name="interprocess"><class name="upgradable_lock"><template>
      <template-type-parameter name="UpgradableMutex"/>
    </template><description><para>upgradable_lock is meant to carry out the tasks for read-locking, unlocking, try-read-locking and timed-read-locking (recursive or not) for the Mutex. Additionally the upgradable_lock can transfer ownership to a scoped_lock using trasfer_lock syntax. The Mutex need not supply all of the functionality. If the client of upgradable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among read_locks, and a single upgradable_lock. upgradable_lock does not support copy semantics. However upgradable_lock supports ownership transfer from a upgradable_locks or scoped_locks via trasfer_lock syntax. </para></description><typedef name="mutex_type"><type>UpgradableMutex</type></typedef><method-group name="public member functions"><method name="lock" cv=""><type>void</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls lock_upgradable() on the referenced mutex. Postconditions: owns() == true. Notes: The sharable_lock changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method><method name="try_lock" cv=""><type>bool</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_upgradable() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock_upgradable(). Notes: The upgradable_lock changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_upgradable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="timed_lock" cv=""><type>bool</type><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock_upgradable(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_upgradable(abs_time). Notes: The upgradable_lock changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time. If the mutex_type does not support timed_lock_upgradable(abs_time), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method><method name="unlock" cv=""><type>void</type><description><para>Effects: If mutex() == 0 or if not locked, throws a lock_exception() exception. Calls unlock_upgradable() on the referenced mutex. Postconditions: owns() == false. Notes: The upgradable_lock changes from a state of owning the mutex, to not owning the mutex. </para></description></method><method name="owns" cv="const"><type>bool</type><description><para>Effects: Returns true if this scoped_lock has acquired the referenced mutex. </para></description></method><method name="conversion-operator" cv="const"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method><method name="mutex" cv="const"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method><method name="release" cv=""><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method></method-group><constructor><description><para>Effects: Default constructs a upgradable_lock. Postconditions: owns() == false and mutex() == 0. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already upgradable locked. There is no effect required on the referenced mutex. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: m.try_lock_upgradable(). Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const boost::posix_time::ptime &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_upgradable(abs_time) Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor><constructor><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: No effects on the underlying mutex. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0. owns() == upgr.owns() before the construction. upgr.owns() == false. Notes: If upgr is locked, this constructor will lock this upgradable_lock while unlocking upgr. If upgr is unlocked, then this upgradable_lock will be unlocked as well. Only a moved upgradable_lock's will match this signature. An non-moved upgradable_lock can be moved with the expression: "detail::move_impl(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor><constructor><parameter name="scop"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If scop.owns(), m_.unlock_and_lock_upgradable(). Postconditions: mutex() == the value scop.mutex() had before the construction. scop.mutex() == 0. owns() == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive-ownership to an upgradable-ownership of this upgradable_lock. Only a moved sharable_lock's will match this signature. An non-moved sharable_lock can be moved with the expression: "detail::move_impl(lock);". </para></description></constructor><constructor><parameter name="shar"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock_upgradable() on the referenced mutex. a)if try_unlock_sharable_and_lock_upgradable() returns true then mutex() obtains the value from shar.release() and owns() is set to true. b)if try_unlock_sharable_and_lock_upgradable() returns false then shar is unaffected and this upgradable_lock construction has the same effects as a default construction. c)Else shar.owns() is false. mutex() obtains the value from shar.release() and owns() is set to false. Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to an "upgradable lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "upgradable lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor><destructor><description><para>Effects: if (owns()) m_-&gt;unlock_upgradable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor><copy-assignment><parameter name="upgr"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Effects: If owns(), then unlock_upgradable() is called on mutex(). this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's upgradable lock count will be decremented by one. </para></description></copy-assignment></class></namespace></namespace></header><header name="boost/interprocess/windows_shared_memory.hpp"><para>Describes a class representing a native windows shared memory. </para><namespace name="boost"><namespace name="interprocess"><class name="windows_shared_memory"><description><para>A class that wraps the native Windows shared memory that is implemented as a file mapping of the paging file. Unlike shared_memory_object, windows_shared_memory has no kernel persistence and the shared memory is destroyed when all processes destroy all their windows_shared_memory objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: Windows native shared memory and interprocess portable shared memory (boost::interprocess::shared_memory_object) can't communicate between them. </para></description><method-group name="public member functions"><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>windows_shared_memory</classname> &amp;</paramtype></parameter><purpose>Swaps to shared_memory_objects. Does not throw. </purpose></method><method name="get_name" cv="const"><type>const char *</type><purpose>Returns the name of the shared memory. </purpose></method><method name="get_mode" cv="const"><type>mode_t</type><purpose>Returns access mode. </purpose></method><method name="get_mapping_handle" cv="const"><type>mapping_handle_t</type><purpose>Returns the mapping handle. Never throws. </purpose></method></method-group><constructor><description><para>Default constructor. Represents an empty windows_shared_memory. </para></description></constructor><constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><description><para>Creates a new native shared memory with name "name" and mode "mode", with the access mode "mode". If the file previously exists, throws an error. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor><constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor><constructor><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor><copy-assignment><parameter name="moved"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment><destructor><description><para>Destroys *this. All mapped regions are still valid after destruction. When all mapped regions and windows_shared_memory objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor></class></namespace></namespace></header></library-reference>

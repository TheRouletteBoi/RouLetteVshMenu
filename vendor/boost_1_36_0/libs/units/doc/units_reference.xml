<?xml version="1.0" standalone="yes"?>
<library-reference id="units_reference"><title>Units Reference</title><header name="boost/units/absolute.hpp"><namespace name="boost"><namespace name="units"><class name="absolute"><template>
      <template-type-parameter name="Y"/>
    </template><description><para>A wrapper to represent absolute units (points rather than vectors). Intended originally for temperatures, this class implements operators for absolute units so that addition of a relative unit to an absolute unit results in another absolute unit : absolute&lt;T&gt; +/- T -&gt; absolute&lt;T&gt; and subtraction of one absolute unit from another results in a relative unit : absolute&lt;T&gt; - absolute&lt;T&gt; -&gt; T </para></description><typedef name="this_type"><type><classname>absolute</classname>&lt; Y &gt;</type></typedef><typedef name="value_type"><type>Y</type></typedef><method-group name="public member functions"><method name="value" cv="const"><type>const value_type &amp;</type></method><method name="operator+=" cv=""><type>const <classname>this_type</classname> &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="operator-=" cv=""><type>const <classname>this_type</classname> &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></constructor><constructor><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></constructor><copy-assignment><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></copy-assignment></class><function name="operator+"><type><classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><purpose>add a relative value to an absolute one </purpose></function><function name="operator+"><type><classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>add a relative value to an absolute one </purpose></function><function name="operator-"><type><classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><purpose>subtract a relative value from an absolute one </purpose></function><function name="operator-"><type>Y</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval1"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="aval2"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>subtracting two absolutes gives a difference </purpose></function><function name="operator*"><type><classname>quantity</classname>&lt; <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt;, T &gt;</type><template>
          <template-type-parameter name="D"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt; &amp;</paramtype></parameter><purpose>creates a quantity from an absolute unit and a raw value </purpose></function><function name="operator*"><type><classname>quantity</classname>&lt; <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt;, T &gt;</type><template>
          <template-type-parameter name="D"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>const <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt; &amp;</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><purpose>creates a quantity from an absolute unit and a raw value </purpose></function><function name="operator&lt;&lt;"><type>std::ostream &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="os"><paramtype>std::ostream &amp;</paramtype></parameter><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>Print an absolute unit. </purpose></function></namespace></namespace><macro name="BOOST_UNITS_DEFINE_CONVERSION_OFFSET" kind="functionlike"><macro-parameter name="From"/><macro-parameter name="To"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Macro to define the offset between two absolute units. Requires the value to be in the destination units e.g <programlisting> BOOST_UNITS_DEFINE_CONVERSION_OFFSET(celsius_base_unit, fahrenheit_base_unit, double, 32.0);
</programlisting> <computeroutput>BOOST_UNITS_DEFINE_CONVERSION_FACTOR</computeroutput> is also necessary to specify the conversion factor. Like <computeroutput>BOOST_UNITS_DEFINE_CONVERSION_FACTOR</computeroutput> this macro defines both forward and reverse conversions so defining, e.g., the conversion from celsius to fahrenheit as above will also define the inverse conversion from fahrenheit to celsius. </para></description></macro></header><header name="boost/units/base_dimension.hpp"><namespace name="boost"><namespace name="units"><class name="base_dimension"><template>
      <template-type-parameter name="Derived"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><description><para>Defines a base dimension. To define a dimension you need to provide the derived class (CRTP) and a unique integer. <programlisting> struct my_dimension : boost::units::base_dimension&lt;my_dimension, 1&gt; {};
</programlisting> It is designed so that you will get an error message if you try to use the same value in multiple definitions. </para></description><typedef name="dimension_type"><purpose>A convenience typedef. Equivalent to boost::units::derived_dimension&lt;Derived,1&gt;::type. </purpose><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><purpose>Provided for mpl compatability. </purpose><type>Derived</type></typedef></class></namespace></namespace></header><header name="boost/units/base_unit.hpp"><namespace name="boost"><namespace name="units"><class name="base_unit"><template>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Dim"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><description><para>Defines a base unit. To define a unit you need to provide the derived class (CRTP), a dimension list and a unique integer. <programlisting> struct my_unit : boost::units::base_unit&lt;my_unit, length_dimension, 1&gt; {};
</programlisting> It is designed so that you will get an error message if you try to use the same value in multiple definitions. </para></description><typedef name="dimension_type"><purpose>The dimensions of this base unit. </purpose><type>Dim</type></typedef><typedef name="type"><purpose>Provided for mpl compatability. </purpose><type>Derived</type></typedef><typedef name="unit_type"><purpose>The unit corresponding to this base unit. </purpose><type><emphasis>unspecified</emphasis></type></typedef></class></namespace></namespace></header><header name="boost/units/cmath.hpp"><para>Overloads of functions in &lt;cmath&gt; for quantities. </para><para>Only functions for which a dimensionally-correct result type can be determined are overloaded. All functions work with dimensionless quantities. </para><namespace name="boost"><namespace name="units"><function name="isfinite"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isinf"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isnan"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isnormal"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isgreater"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isgreaterequal"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isless"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="islessequal"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="islessgreater"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="isunordered"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="abs"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="ceil"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="copysign"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fabs"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="floor"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fdim"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fmax"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fmin"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fpclassify"><type>int</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="hypot"><type><classname>root_typeof_helper</classname>&lt; typename <classname>add_typeof_helper</classname>&lt; typename <classname>power_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type, typename <classname>power_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type &gt;::type, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="signbit"><type>int</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="trunc"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="fmod"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="modf"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; *</paramtype></parameter></function><function name="frexp"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Int"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="ex"><paramtype>Int *</paramtype></parameter></function><function name="pow"><type><classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter><description><para>For non-dimensionless quantities, integral and rational powers and roots can be computed by <computeroutput>pow&lt;Ex&gt;</computeroutput> and <computeroutput>root&lt;Rt&gt;</computeroutput> respectively. </para></description></function><function name="exp"><type><classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function><function name="ldexp"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Int"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="ex"><paramtype>const Int &amp;</paramtype></parameter></function><function name="log"><type><classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function><function name="log10"><type><classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function><function name="sqrt"><type><classname>root_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function><function name="cos"><type><classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>cos of theta in radians </purpose></function><function name="sin"><type><classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>sin of theta in radians </purpose></function><function name="tan"><type><classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>tan of theta in radians </purpose></function><function name="cos"><type><classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>cos of theta in other angular units </purpose></function><function name="sin"><type><classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>sin of theta in other angular units </purpose></function><function name="tan"><type><classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>tan of theta in other angular units </purpose></function><function name="acos"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>acos of dimensionless quantity returning angle in same system </purpose></function><function name="asin"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>asin of dimensionless quantity returning angle in same system </purpose></function><function name="atan"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan of dimensionless quantity returning angle in same system </purpose></function><function name="atan2"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="y"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><parameter name="x"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan2 of <computeroutput>value_type</computeroutput> returning angle in radians </purpose></function></namespace></namespace></header><header name="boost/units/config.hpp"><macro name="BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY"><description><para>If defined will trigger a static assertion if quantity&lt;Unit, T&gt; is not layout compatible with T </para></description></macro><macro name="BOOST_UNITS_NO_COMPILER_CHECK"><description><para>If defined will diasable a preprocessor check that the compiler is able to handle the library. </para></description></macro><macro name="BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS"><description><para>Enable checking to verify that a homogeneous system is actually capable of representing all the dimensions that it is used with. Off by default. </para></description></macro></header><header name="boost/units/conversion.hpp"><namespace name="boost"><namespace name="units"><struct name="conversion_helper"><template>
      <template-type-parameter name="From"/>
      <template-type-parameter name="To"/>
    </template><description><para>Template for defining conversions between quantities. This template should be specialized for every quantity that allows conversions. For example, if you have a two units called pair and dozen you would write <programlisting> namespace boost {
 namespace units {
 template&lt;class T0, class T1&gt;
 struct conversion_helper&lt;quantity&lt;dozen, T0&gt;, quantity&lt;pair, T1&gt; &gt;
 {
     static quantity&lt;pair, T1&gt; convert(const quantity&lt;dozen, T0&gt;&amp; source)
     {
         return(quantity&lt;pair, T1&gt;::from_value(6 * source.value()));
     }
 };
 }
 }
</programlisting> </para></description><method-group name="public static functions"><method name="convert" cv=""><type>static To</type><parameter name=""><paramtype>const From &amp;</paramtype></parameter></method></method-group></struct><function name="conversion_factor"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FromUnit"/>
          <template-type-parameter name="ToUnit"/>
        </template><parameter name=""><paramtype>const FromUnit &amp;</paramtype></parameter><parameter name=""><paramtype>const ToUnit &amp;</paramtype></parameter><purpose>Find the conversion factor between two units. </purpose></function></namespace></namespace><macro name="BOOST_UNITS_DEFINE_CONVERSION_FACTOR" kind="functionlike"><macro-parameter name="Source"/><macro-parameter name="Destination"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Defines the conversion factor from a base unit to any unit or to another base unit with the correct dimensions. Uses of this macro must appear at global scope. If the destination unit is a base unit or a unit that contains only one base unit which is raised to the first power (e.g. feet-&gt;meters) the reverse (meters-&gt;feet in this example) need not be defined. </para></description></macro><macro name="BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE" kind="functionlike"><macro-parameter name="Params"/><macro-parameter name="Source"/><macro-parameter name="Destination"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Defines the conversion factor from a base unit to any other base unit with the same dimensions. Params should be a Boost.Preprocessor Seq of template parameters, such as (class T1)(class T2) All uses of must appear at global scope. The reverse conversion will be defined automatically. This macro is a little dangerous, because, unlike the non-template form, it will silently fail if either base unit is scaled. This is probably not an issue if both the source and destination types depend on the template parameters, but be aware that a generic conversion to kilograms is not going to work. </para></description></macro><macro name="BOOST_UNITS_DEFAULT_CONVERSION" kind="functionlike"><macro-parameter name="Source"/><macro-parameter name="Dest"/><description><para>Specifies the default conversion to be applied when no direct conversion is available. Source is a base unit. Dest is any unit with the same dimensions. </para></description></macro><macro name="BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE" kind="functionlike"><macro-parameter name="Params"/><macro-parameter name="Source"/><macro-parameter name="Dest"/><description><para>Specifies the default conversion to be applied when no direct conversion is available. Params is a PP Sequence of template arguments. Source is a base unit. Dest is any unit with the same dimensions. The source must not be a scaled base unit. </para></description></macro></header><header name="boost/units/derived_dimension.hpp"><namespace name="boost"><namespace name="units"><struct name="derived_dimension"><template>
      <template-type-parameter name="DT1"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E1"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT2"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E2"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT3"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E3"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT4"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E4"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT5"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E5"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT6"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E6"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT7"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E7"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT8"><default>dimensionless_type</default></template-type-parameter>
      <template-nontype-parameter name="E8"><type>long</type><default>0</default></template-nontype-parameter>
    </template><purpose>A utility class for defining composite dimensions with integer powers. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace></namespace></header><header name="boost/units/dim.hpp"><para>Handling of fundamental dimension/exponent pairs. </para><namespace name="boost"><namespace name="units"><struct name="dim"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="V"/>
    </template><purpose>Dimension tag/exponent pair for a single fundamental dimension. </purpose><description><para>The dim class represents a single dimension tag/dimension exponent pair. That is, <computeroutput>dim&lt;tag_type,value_type&gt;</computeroutput> is a pair where <computeroutput>tag_type</computeroutput> represents the fundamental dimension being represented and <computeroutput>value_type</computeroutput> represents the exponent of that fundamental dimension as a <computeroutput>static_rational</computeroutput>. <computeroutput>tag_type</computeroutput> must be a derived from a specialization of <computeroutput>base_dimension</computeroutput>. Specialization of the following Boost.MPL metafunctions are provided</para><para><itemizedlist>
<listitem><para><computeroutput>mpl::plus</computeroutput> for two <computeroutput>dims</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::minus</computeroutput> for two <computeroutput>dims</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::negate</computeroutput> for a <computeroutput>dim</computeroutput> </para></listitem></itemizedlist>
</para><para>These metafunctions all operate on the exponent, and require that the <computeroutput>dim</computeroutput> operands have the same base dimension tag. In addition, multiplication and division by <computeroutput>static_rational</computeroutput> is supported.</para><para><itemizedlist>
<listitem><para><computeroutput>mpl::times</computeroutput> for a <computeroutput>static_rational</computeroutput> and a <computeroutput>dim</computeroutput> in either order</para></listitem><listitem><para><computeroutput>mpl::divides</computeroutput> for a <computeroutput>static_rational</computeroutput> and a <computeroutput>dim</computeroutput> in either order</para></listitem></itemizedlist>
</para><para>These metafunctions likewise operate on the exponent only. </para></description><typedef name="type"><type><classname>dim</classname></type></typedef><typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="tag_type"><type>T</type></typedef><typedef name="value_type"><type>V</type></typedef></struct></namespace></namespace></header><header name="boost/units/dimension.hpp"><para>Core metaprogramming utilities for compile-time dimensional analysis. </para><namespace name="boost"><namespace name="units"><struct name="make_dimension_list"><template>
      <template-type-parameter name="Seq"/>
    </template><description><para>Reduce dimension list to cardinal form. This algorithm collapses duplicate base dimension tags and sorts the resulting list by the tag ordinal value. Dimension lists that resolve to the same dimension are guaranteed to be represented by an identical type.</para><para>The argument should be an MPL forward sequence containing instances of the <computeroutput>dim</computeroutput> template.</para><para>The result is also an MPL forward sequence. It also supports the following metafunctions to allow use as a dimension.</para><para><itemizedlist>
<listitem><para><computeroutput>mpl::plus</computeroutput> is defined only on two equal dimensions and returns the argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::minus</computeroutput> is defined only for two equal dimensions and returns the argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::negate</computeroutput> will return its argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::times</computeroutput> is defined for any dimensions and adds corresponding exponents.</para></listitem><listitem><para><computeroutput>mpl::divides</computeroutput> is defined for any dimensions and subtracts the exponents of the right had argument from the corresponding exponents of the left had argument. Missing base dimension tags are assumed to have an exponent of zero.</para></listitem><listitem><para><computeroutput>static_power</computeroutput> takes a dimension and a static_rational and multiplies all the exponents of the dimension by the static_rational.</para></listitem><listitem><para><computeroutput>static_root</computeroutput> takes a dimension and a static_rational and divides all the exponents of the dimension by the static_rational. </para></listitem></itemizedlist>
</para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct><struct name="static_power"><template>
      <template-type-parameter name="DL"/>
      <template-type-parameter name="Ex"/>
    </template><purpose>Raise a dimension list to a scalar power. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct><struct name="static_root"><template>
      <template-type-parameter name="DL"/>
      <template-type-parameter name="Rt"/>
    </template><purpose>Take a scalar root of a dimension list. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace></namespace></header><header name="boost/units/dimensionless_quantity.hpp"><namespace name="boost"><namespace name="units"><struct name="dimensionless_quantity"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Y"/>
    </template><purpose>utility class to simplify construction of dimensionless quantities </purpose><typedef name="type"><type><classname>quantity</classname>&lt; typename <classname>dimensionless_unit</classname>&lt; System &gt;::<classname>type</classname>, Y &gt;</type></typedef></struct></namespace></namespace></header><header name="boost/units/dimensionless_type.hpp"><namespace name="boost"><namespace name="units"><struct name="dimensionless_type"><purpose>Dimension lists in which all exponents resolve to zero reduce to <computeroutput>dimensionless_type</computeroutput>. </purpose><typedef name="type"><type><classname>dimensionless_type</classname></type></typedef><typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size"><type>mpl::long_&lt; 0 &gt;</type></typedef></struct></namespace></namespace></header><header name="boost/units/dimensionless_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="dimensionless_unit"><template>
      <template-type-parameter name="System"/>
    </template><purpose>utility class to simplify construction of dimensionless units in a system </purpose><typedef name="type"><type><classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System &gt;</type></typedef></struct></namespace></namespace></header><header name="boost/units/get_dimension.hpp"><namespace name="boost"><namespace name="units"><struct name="get_dimension"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>get the dimension of a unit </purpose><typedef name="type"><type>Dim</type></typedef></struct-specialization><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Unit"/>
    </template><specialization><template-arg>absolute&lt; Unit &gt;</template-arg></specialization><purpose>get the dimension of an absolute unit </purpose><typedef name="type"><type><classname>get_dimension</classname>&lt; Unit &gt;::type</type></typedef></struct-specialization><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><purpose>get the dimension of a quantity </purpose><typedef name="type"><type><classname>get_dimension</classname>&lt; Unit &gt;::type</type></typedef></struct-specialization></namespace></namespace></header><header name="boost/units/get_system.hpp"><namespace name="boost"><namespace name="units"><struct name="get_system"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="get_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>get the system of a unit </purpose><typedef name="type"><type>System</type></typedef></struct-specialization><struct-specialization name="get_system"><template>
      <template-type-parameter name="Unit"/>
    </template><specialization><template-arg>absolute&lt; Unit &gt;</template-arg></specialization><purpose>get the system of an absolute unit </purpose><typedef name="type"><type><classname>get_system</classname>&lt; Unit &gt;::type</type></typedef></struct-specialization><struct-specialization name="get_system"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><purpose>get the system of a quantity </purpose><typedef name="type"><type><classname>get_system</classname>&lt; Unit &gt;::type</type></typedef></struct-specialization></namespace></namespace></header><header name="boost/units/heterogeneous_system.hpp"><namespace name="boost"><namespace name="mpl"/><namespace name="units"><struct name="heterogeneous_system"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A system that can represent any possible combination of units at the expense of not preserving information about how it was created. Do not create specializations of this template directly. Instead use <computeroutput>reduce_unit</computeroutput> and <computeroutput>base_unit&lt;</computeroutput>...&gt;unit_type. </para></description></struct></namespace></namespace></header><header name="boost/units/homogeneous_system.hpp"><namespace name="boost"><namespace name="units"><struct name="homogeneous_system"><template>
      <template-type-parameter name="L"/>
    </template><description><para>A system that can uniquely represent any unit which can be composed from a linearly independent set of base units. It is safe to rebind a unit with such a system to different dimensions.</para><para>Do not construct this template directly. Use make_system instead. </para></description></struct></namespace></namespace></header><header name="boost/units/io.hpp"><namespace name="boost"><namespace name="serialization"><function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype><classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="int"><paramtype>const unsigned</paramtype></parameter><purpose>Boost Serialization library support for units. </purpose></function><function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="q"><paramtype><classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="int"><paramtype>const unsigned</paramtype></parameter><purpose>Boost Serialization library support for quantities. </purpose></function></namespace><namespace name="units"><struct name="base_unit_info"><template>
      <template-type-parameter name="BaseUnit"/>
    </template><purpose>traits template for unit names </purpose><method-group name="public static functions"><method name="name" cv=""><type>static std::string</type><purpose>The full name of the unit (returns BaseUnit::name() by default). </purpose></method><method name="symbol" cv=""><type>static std::string</type><purpose>The symbol for the base unit (Returns BaseUnit::symbol() by default). </purpose></method></method-group></struct><enum name="format_mode"><enumvalue name="symbol_fmt"><default> 0</default></enumvalue><enumvalue name="name_fmt"/><enumvalue name="raw_fmt"/><enumvalue name="typename_fmt"/></enum><function name="to_string"><type>std::string</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter></function><function name="to_string"><type>std::string</type><template>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N &gt; &amp;</paramtype></parameter></function><function name="to_string"><type>std::string</type><template>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="r"><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter><purpose>Write <computeroutput>static_rational</computeroutput> to <computeroutput>std::basic_ostream</computeroutput>. </purpose></function><function name="get_format"><type>format_mode</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter></function><function name="set_format"><type>void</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><parameter name="new_mode"><paramtype>format_mode</paramtype></parameter></function><function name="typename_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter></function><function name="raw_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter></function><function name="symbol_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter></function><function name="name_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter></function><function name="typename_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function><function name="symbol_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function><function name="name_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="u"><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter><description><para>Print an <computeroutput>unit</computeroutput> as a list of base units and exponents</para><para>for <computeroutput>symbol_format</computeroutput> this gives e.g. "m s^-1" or "J" for <computeroutput>name_format</computeroutput> this gives e.g. "meter second^-1" or "joule" for <computeroutput>raw_format</computeroutput> this gives e.g. "m s^-1" or "meter kilogram^2 second^-2" for <computeroutput>typename_format</computeroutput> this gives the typename itself (currently demangled only on GCC) </para></description></function></namespace></namespace></header><header name="boost/units/is_dim.hpp"><namespace name="boost"><namespace name="units"><struct name="is_dim"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Check that a type is a valid <computeroutput>dim</computeroutput>. </purpose></struct><struct-specialization name="is_dim"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="V"/>
    </template><specialization><template-arg>dim&lt; T</template-arg><template-arg>V &gt;</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/is_dimension_list.hpp"><namespace name="boost"><namespace name="units"><struct name="is_dimension_list"><template>
      <template-type-parameter name="Seq"/>
    </template><purpose>Check that a type is a valid dimension list. </purpose></struct><struct-specialization name="is_dimension_list"><template>
      <template-type-parameter name="Item"/>
      <template-type-parameter name="Next"/>
    </template><specialization><template-arg>list&lt; Item</template-arg><template-arg>Next &gt;</template-arg></specialization></struct-specialization><struct-specialization name="is_dimension_list"><template>
    </template><specialization><template-arg>dimensionless_type</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/is_dimensionless.hpp"><namespace name="boost"><namespace name="units"><struct name="is_dimensionless"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="is_dimensionless"><template>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; dimensionless_type</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>check if a unit is dimensionless </purpose></struct-specialization><struct-specialization name="is_dimensionless"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><inherit access="public">boost::units::is_dimensionless&lt; Unit &gt;</inherit><purpose>check if a quantity is dimensionless </purpose></struct-specialization></namespace></namespace></header><header name="boost/units/is_dimensionless_quantity.hpp"><namespace name="boost"><namespace name="units"><struct name="is_dimensionless_quantity"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::units::is_quantity_of_dimension&lt; T, Dim &gt;</inherit><purpose>check that a type is a dimensionless quantity </purpose></struct></namespace></namespace></header><header name="boost/units/is_dimensionless_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="is_dimensionless_unit"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::units::is_unit_of_dimension&lt; T, Dim &gt;</inherit><purpose>check that a type is a dimensionless unit </purpose></struct></namespace></namespace></header><header name="boost/units/is_quantity.hpp"><namespace name="boost"><namespace name="units"><struct name="is_quantity"><template>
      <template-type-parameter name="T"/>
    </template><purpose>check that a type is a quantity </purpose></struct><struct-specialization name="is_quantity"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/is_quantity_of_dimension.hpp"><namespace name="boost"><namespace name="units"><struct name="is_quantity_of_dimension"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Dim"/>
    </template><purpose>check that a type is a quantity of the specified dimension </purpose></struct><struct-specialization name="is_quantity_of_dimension"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="Dim"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg><template-arg>Dim</template-arg></specialization><inherit access="public">boost::units::is_unit_of_dimension&lt; Unit, Dim &gt;</inherit></struct-specialization></namespace></namespace></header><header name="boost/units/is_quantity_of_system.hpp"><namespace name="boost"><namespace name="units"><struct name="is_quantity_of_system"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="System"/>
    </template><purpose>check that a type is a quantity in a specified system </purpose></struct><struct-specialization name="is_quantity_of_system"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg><template-arg>System</template-arg></specialization><inherit access="public">boost::units::is_unit_of_system&lt; Unit, System &gt;</inherit></struct-specialization></namespace></namespace></header><header name="boost/units/is_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="is_unit"><template>
      <template-type-parameter name="T"/>
    </template><purpose>check that a type is a unit </purpose></struct><struct-specialization name="is_unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/is_unit_of_dimension.hpp"><namespace name="boost"><namespace name="units"><struct name="is_unit_of_dimension"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Dim"/>
    </template><purpose>check that a type is a unit of the specified dimension </purpose></struct><struct-specialization name="is_unit_of_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Dim</template-arg></specialization></struct-specialization><struct-specialization name="is_unit_of_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>absolute&lt; unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>Dim</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/is_unit_of_system.hpp"><namespace name="boost"><namespace name="units"><struct name="is_unit_of_system"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="System"/>
    </template><purpose>check that a type is a unit in a specified system </purpose></struct><struct-specialization name="is_unit_of_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>System</template-arg></specialization></struct-specialization><struct-specialization name="is_unit_of_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>absolute&lt; unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>System</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/units/lambda.hpp"><para>Definitions to ease the usage of Boost.Units' quantity, unit, and absolute types in functors created with the Boost.Lambda library. </para><para><para>Torsten Maehne </para>
<para>2008-06-16</para>
Boost.Lambda's return type deduction system is extented to make use of Boost.Units' typeof_helper trait classes for Boost.Units' quantity, absolute, and unit template classes. </para><namespace name="boost"><namespace name="lambda"><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim, System&gt; * Y. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim, System&gt; / Y. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y * unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; Y, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y / unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; Y, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg><template-arg>X</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit, X&gt; * X. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X * quantity&lt;Unit, X&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; Unit, X &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg><template-arg>X</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit, X&gt; / X. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X / quantity&lt;Unit, X&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; Unit, X &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; * quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; / quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="Dim2"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>Y &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, Y&gt; * unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, Y &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="Dim2"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>Y &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, Y&gt; / unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, Y &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action +quantity&lt;Unit, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_plus_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action -quantity&lt;Unit, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_minus_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; + quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; - quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; * quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; / quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action +unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_plus_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action -unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_minus_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; + unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; - unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; * unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; / unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; + Y. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y + absolute&lt;Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; - Y. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; - absolute&lt;Y&gt;. </para></description><typedef name="type"><type>Y</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="D"/>
      <template-type-parameter name="S"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>T</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; D</template-arg><template-arg>S &gt; &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action T * absolute&lt;unit&lt;D, S&gt; &gt;. </para></description><typedef name="type"><type><classname>boost::units::quantity</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; D, S &gt; &gt;, T &gt;</type></typedef></struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="D"/>
      <template-type-parameter name="S"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; D</template-arg><template-arg>S &gt; &gt;</template-arg><template-arg>T</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;unit&lt;D, S&gt; &gt; * T. </para></description><typedef name="type"><type><classname>boost::units::quantity</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; D, S &gt; &gt;, T &gt;</type></typedef></struct-specialization></namespace><namespace name="units"><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="divide_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::divide_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="divide_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::divide_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::absolute&lt; boost::units::unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef></struct-specialization><function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action unit&lt;Dim, System&gt; * lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function><function name="operator/"><type>const <classname>divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action unit&lt;Dim, System&gt; / lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function><function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; * unit&lt;Dim, System&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function><function name="operator/"><type>const <classname>divide_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; / unit&lt;Dim, System&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function><function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; * absolute&lt;unit&lt;Dim, System&gt; &gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function><function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action absolute&lt;unit&lt;Dim, System&gt; &gt; * lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function></namespace></namespace></header><header name="boost/units/limits.hpp"><namespace name="std"><class-specialization name="numeric_limits"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>::boost::units::quantity&lt; Unit</template-arg><template-arg>T &gt;</template-arg></specialization><typedef name="quantity_type"><type>::<classname>boost::units::quantity</classname>&lt; Unit, T &gt;</type></typedef><data-member name="is_specialized" specifiers="static"><type>const bool</type></data-member><data-member name="digits" specifiers="static"><type>const int</type></data-member><data-member name="digits10" specifiers="static"><type>const int</type></data-member><data-member name="is_signed" specifiers="static"><type>const bool</type></data-member><data-member name="is_integer" specifiers="static"><type>const bool</type></data-member><data-member name="is_exact" specifiers="static"><type>const bool</type></data-member><data-member name="radix" specifiers="static"><type>const int</type></data-member><data-member name="min_exponent" specifiers="static"><type>const int</type></data-member><data-member name="min_exponent10" specifiers="static"><type>const int</type></data-member><data-member name="max_exponent" specifiers="static"><type>const int</type></data-member><data-member name="max_exponent10" specifiers="static"><type>const int</type></data-member><data-member name="has_infinity" specifiers="static"><type>const bool</type></data-member><data-member name="has_quiet_NaN" specifiers="static"><type>const bool</type></data-member><data-member name="has_signaling_NaN" specifiers="static"><type>const bool</type></data-member><data-member name="has_denorm_loss" specifiers="static"><type>const bool</type></data-member><data-member name="is_iec559" specifiers="static"><type>const bool</type></data-member><data-member name="is_bounded" specifiers="static"><type>const bool</type></data-member><data-member name="is_modulo" specifiers="static"><type>const bool</type></data-member><data-member name="traps" specifiers="static"><type>const bool</type></data-member><data-member name="tinyness_before" specifiers="static"><type>const bool</type></data-member><data-member name="has_denorm" specifiers="static"><type>const float_denorm_style</type></data-member><data-member name="round_style" specifiers="static"><type>const float_round_style</type></data-member><method-group name="public static functions"><method name="min" cv=""><type>static <classname>quantity_type</classname>()</type></method><method name="max" cv=""><type>static <classname>quantity_type</classname>()</type></method><method name="epsilon" cv=""><type>static <classname>quantity_type</classname></type></method><method name="round_error" cv=""><type>static <classname>quantity_type</classname></type></method><method name="infinity" cv=""><type>static <classname>quantity_type</classname></type></method><method name="quiet_NaN" cv=""><type>static <classname>quantity_type</classname></type></method><method name="signaling_NaN" cv=""><type>static <classname>quantity_type</classname></type></method><method name="denorm_min" cv=""><type>static <classname>quantity_type</classname></type></method></method-group></class-specialization></namespace></header><header name="boost/units/make_scaled_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="make_scaled_unit"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Scale"/>
    </template><typedef name="type"><type><classname>make_scaled_unit</classname>&lt; typename <classname>reduce_unit</classname>&lt; Unit &gt;::type, Scale &gt;::type</type></typedef></struct><struct-specialization name="make_scaled_unit"><template>
      <template-type-parameter name="Dimension"/>
      <template-type-parameter name="UnitList"/>
      <template-type-parameter name="OldScale"/>
      <template-type-parameter name="Scale"/>
    </template><specialization><template-arg>unit&lt; Dimension</template-arg><template-arg>heterogeneous_system&lt; heterogeneous_system_impl&lt; UnitList</template-arg><template-arg>Dimension</template-arg><template-arg>OldScale &gt; &gt; &gt;</template-arg><template-arg>Scale</template-arg></specialization><typedef name="type"><type><classname>unit</classname>&lt; Dimension, <classname>heterogeneous_system</classname>&lt; <classname>heterogeneous_system_impl</classname>&lt; UnitList, Dimension, typename mpl::times&lt; OldScale, list&lt; scale_list_dim&lt; Scale &gt;, <classname>dimensionless_type</classname> &gt; &gt;::<classname>type</classname> &gt; &gt; &gt;</type></typedef></struct-specialization></namespace></namespace></header><header name="boost/units/make_system.hpp"><namespace name="boost"><namespace name="units"><struct name="make_system"><template>
      <template-type-parameter name="BaseUnit0"/>
      <template-type-parameter name="BaseUnit1"/>
      <template-type-parameter name="BaseUnit2"/>
      <template-nontype-parameter name=""><type>...</type></template-nontype-parameter>
      <template-type-parameter name="BaseUnitN"/>
    </template><description><para>Metafunction returning a homogeneous system that can represent any combination of the base units. There must be no way to represent any of the base units in terms of the others. make_system&lt;foot_base_unit, meter_base_unit&gt;::type is not allowed, for example. </para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace></namespace></header><header name="boost/units/operators.hpp"><para>Compile time operators and typeof helper classes. </para><para>These operators declare the compile-time operators needed to support dimensional analysis algebra. They require the use of Boost.Typeof. Typeof helper classes define result type for heterogeneous operators on value types. These must be defined through specialization for powers and roots. </para><namespace name="boost"><namespace name="units"><struct name="unary_plus_typeof_helper"><template>
      <template-type-parameter name="X"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(+typeof_::make&lt; X &gt;())</paramtype></parameter></method></method-group></struct><struct name="unary_minus_typeof_helper"><template>
      <template-type-parameter name="X"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(-typeof_::make&lt; X &gt;())</paramtype></parameter></method></method-group></struct><struct name="add_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()+typeof_::make&lt; Y &gt;())</paramtype></parameter></method></method-group></struct><struct name="subtract_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()-typeof_::make&lt; Y &gt;())</paramtype></parameter></method></method-group></struct><struct name="multiply_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()*typeof_::make&lt; Y &gt;())</paramtype></parameter></method></method-group></struct><struct name="divide_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions"><method name="typeof" cv=""><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()/typeof_::make&lt; Y &gt;())</paramtype></parameter></method></method-group></struct><struct name="power_typeof_helper"><template>
      <template-type-parameter name="BaseType"/>
      <template-type-parameter name="Exponent"/>
    </template><description><para>A helper for computing the result of raising a runtime object to a compile time known exponent. This template is intended to be specialized. All specializations must conform to the interface shown here. </para></description><typedef name="type"><purpose>specifies the result type </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="value" cv=""><type>static <classname>type</classname></type><parameter name="base"><paramtype>const BaseType &amp;</paramtype></parameter><purpose>Carries out the runtime calculation. </purpose></method></method-group></struct><struct name="root_typeof_helper"><template>
      <template-type-parameter name="Radicand"/>
      <template-type-parameter name="Index"/>
    </template><description><para>A helper for computing taking a root of a runtime object using a compile time known index. This template is intended to be specialized. All specializations must conform to the interface shown here. </para></description><typedef name="type"><purpose>specifies the result type </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="value" cv=""><type>static <classname>type</classname></type><parameter name="base"><paramtype>const BaseType &amp;</paramtype></parameter><purpose>Carries out the runtime calculation. </purpose></method></method-group></struct></namespace></namespace></header><header name="boost/units/physical_dimensions.hpp"/><header name="boost/units/pow.hpp"><para>Raise values to exponents known at compile-time. </para><namespace name="boost"><namespace name="units"><function name="pow"><type><classname>power_typeof_helper</classname>&lt; Y, Rat &gt;::type</type><template>
          <template-type-parameter name="Rat"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>raise a value to a <computeroutput>static_rational</computeroutput> power </purpose><description><para>raise a value to an integer power </para></description></function><function name="root"><type><classname>root_typeof_helper</classname>&lt; Y, Rat &gt;::type</type><template>
          <template-type-parameter name="Rat"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>take the <computeroutput>static_rational</computeroutput> root of a value </purpose><description><para>take the integer root of a value </para></description></function></namespace></namespace></header><header name="boost/units/quantity.hpp"><namespace name="boost"><namespace name="units"><class name="quantity"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"><default>double</default></template-type-parameter>
    </template><purpose>class declaration </purpose><typedef name="this_type"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type></typedef><typedef name="value_type"><type>Y</type></typedef><typedef name="unit_type"><type>Unit</type></typedef><method-group name="private member functions"><method name="BOOST_MPL_ASSERT_NOT" cv=""><type/><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method></method-group><method-group name="public member functions"><method name="value" cv="const"><type>const value_type &amp;</type><purpose>constant accessor to value </purpose><description><para>can add a quantity of the same type if add_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </para></description></method><method name="operator+=" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>can subtract a quantity of the same type if subtract_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator-=" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter></method><method name="operator*=" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter></method><method name="operator/=" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>can multiply a quantity by a scalar value_type if multiply_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator*=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="source"><paramtype>const value_type &amp;</paramtype></parameter><purpose>can divide a quantity by a scalar value_type if divide_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator/=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="source"><paramtype>const value_type &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></constructor><copy-assignment><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></copy-assignment><constructor><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is allowed if allowed for value types themselves </purpose></constructor><constructor><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is not allowed if not allowed for value types themselves </purpose></constructor><copy-assignment><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between value types is allowed if allowed for value types themselves </purpose></copy-assignment><constructor><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>explicit conversion between different unit systems is allowed if implicit conversion is disallowed </purpose></constructor><constructor><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed if each fundamental dimension is implicitly convertible </purpose></constructor><copy-assignment><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between different unit systems is allowed if each fundamental dimension is implicitly convertible </purpose></copy-assignment><method-group name="public static functions"><method name="from_value" cv=""><type>static <classname>this_type</classname></type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Construct quantity directly from <computeroutput>value_type</computeroutput> (potentially dangerous). </purpose></method></method-group><method-group name="protected member functions"/><constructor><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></constructor></class><class-specialization name="quantity"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>Y</template-arg></specialization><description><para>Specialization for dimensionless quantities. Implicit conversions between unit systems are allowed because all dimensionless quantities are equivalent. Implicit construction and assignment from and conversion to <computeroutput>value_type</computeroutput> is also allowed. </para></description><typedef name="this_type"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System &gt;, Y &gt;</type></typedef><typedef name="value_type"><type>Y</type></typedef><typedef name="system_type"><type>System</type></typedef><typedef name="dimension_type"><type><classname>dimensionless_type</classname></type></typedef><typedef name="unit_type"><type><classname>unit</classname>&lt; <classname>dimension_type</classname>, system_type &gt;</type></typedef><method-group name="public member functions"><method name="quantity" cv=""><type/></method><method name="quantity" cv=""><type/><parameter name="val"><paramtype>value_type</paramtype></parameter><purpose>construction from raw <computeroutput>value_type</computeroutput> is allowed </purpose></method><method name="quantity" cv=""><type/><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></method><method name="quantity" cv=""><type/><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimension_type</classname>, system_type &gt;, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is allowed if allowed for value types themselves </purpose></method><method name="quantity" cv=""><type/><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimension_type</classname>, system_type &gt;, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is not allowed if not allowed for value types themselves </purpose></method><method name="quantity" cv=""><type/><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed </purpose></method><method name="quantity" cv=""><type/><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed </purpose></method><method name="quantity" cv=""><type/><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>conversion between different unit systems is explicit when the units are not equivalent. </para></description></method><method name="conversion-operator" cv="const"><type>value_type</type><purpose>implicit conversion to <computeroutput>value_type</computeroutput> is allowed </purpose></method><method name="value" cv="const"><type>const value_type &amp;</type><purpose>constant accessor to value </purpose><description><para>can add a quantity of the same type if add_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </para></description></method><method name="operator+=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter><purpose>can subtract a quantity of the same type if subtract_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator-=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter><purpose>can multiply a quantity by a scalar value_type if multiply_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator*=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>can divide a quantity by a scalar value_type if divide_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method><method name="operator/=" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method></method-group><copy-assignment><parameter name="source"><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimension_type</classname>, system_type &gt;, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between value types is allowed if allowed for value types themselves </purpose></copy-assignment><copy-assignment><template>
          <template-type-parameter name="System2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System2), Y &gt; &amp;</paramtype></parameter><purpose>implicit assignment between different unit systems is allowed </purpose></copy-assignment><method-group name="public static functions"><method name="from_value" cv=""><type>static <classname>this_type</classname></type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Construct quantity directly from <computeroutput>value_type</computeroutput>. </purpose></method></method-group></class-specialization><struct-specialization name="add_typeof_helper"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>for sun CC we need to invoke SFINAE at the top level, otherwise it will silently return int. </para></description></struct-specialization><struct-specialization name="add_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><typedef name="value_type"><type><classname>add_typeof_helper</classname>&lt; X, Y &gt;::<classname>type</classname></type></typedef><typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef><typedef name="type"><type><classname>quantity</classname>&lt; <classname>unit_type</classname>, value_type &gt;</type></typedef></struct-specialization><struct-specialization name="subtract_typeof_helper"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization></struct-specialization><struct-specialization name="subtract_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><typedef name="value_type"><type><classname>subtract_typeof_helper</classname>&lt; X, Y &gt;::<classname>type</classname></type></typedef><typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef><typedef name="type"><type><classname>quantity</classname>&lt; <classname>unit_type</classname>, value_type &gt;</type></typedef></struct-specialization><function name="quantity_cast"><type>X</type><template>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="source"><paramtype>Y &amp;</paramtype></parameter><purpose>quantity_cast provides mutating access to underlying quantity value_type </purpose></function><function name="quantity_cast"><type>X</type><template>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="source"><paramtype>const Y &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>swap quantities </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const Y &amp;</paramtype></parameter><purpose>runtime unit divided by scalar </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; Y, <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const Y &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>runtime scalar times unit </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; Y, <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const Y &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>runtime scalar divided by unit </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const X &amp;</paramtype></parameter><purpose>runtime quantity times scalar </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; X, <classname>quantity</classname>&lt; Unit, X &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const X &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><purpose>runtime scalar times quantity </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const X &amp;</paramtype></parameter><purpose>runtime quantity divided by scalar </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; X, <classname>quantity</classname>&lt; Unit, X &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const X &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><purpose>runtime scalar divided by quantity </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime unit times quantity </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime unit divided by quantity </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, Y &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime quantity times unit </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, Y &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime quantity divided by unit </purpose></function><function name="operator+"><type><classname>unary_plus_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime unary plus quantity </purpose></function><function name="operator-"><type><classname>unary_minus_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime unary minus quantity </purpose></function><function name="operator+"><type><classname>add_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity plus quantity </purpose></function><function name="operator-"><type><classname>subtract_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity minus quantity </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity times quantity </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity divided by quantity </purpose></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator== </purpose></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator!= </purpose></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&lt; </purpose></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&lt;= </purpose></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&gt; </purpose></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&gt;= </purpose></function></namespace></namespace></header><header name="boost/units/reduce_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="reduce_unit"><template>
      <template-type-parameter name="Unit"/>
    </template><purpose>Returns a unique type for every unit. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace></namespace></header><header name="boost/units/scale.hpp"><namespace name="boost"><namespace name="units"><struct name="scale"><template>
      <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
      <template-type-parameter name="Exponent"/>
    </template><description><para>class representing a scaling factor such as 10^3 The exponent should be a static rational. </para></description><data-member name="base" specifiers="static"><type>const long</type></data-member><typedef name="exponent"><type>Exponent</type></typedef><typedef name="value_type"><type>double</type></typedef><method-group name="public static functions"><method name="value" cv=""><type>static value_type</type></method><method name="name" cv=""><type>static std::string</type></method><method name="symbol" cv=""><type>static std::string</type></method></method-group></struct><function name="symbol_string"><type>std::string</type><template>
          <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Exponent"/>
        </template><parameter name=""><paramtype>const <classname>scale</classname>&lt; Base, Exponent &gt; &amp;</paramtype></parameter></function><function name="name_string"><type>std::string</type><template>
          <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Exponent"/>
        </template><parameter name=""><paramtype>const <classname>scale</classname>&lt; Base, Exponent &gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/units/scaled_base_unit.hpp"><namespace name="boost"><namespace name="units"><struct name="scaled_base_unit"><template>
      <template-type-parameter name="S"/>
      <template-type-parameter name="Scale"/>
    </template><typedef name="type"><type><classname>scaled_base_unit</classname></type></typedef><typedef name="tag"><type><classname>scaled_base_unit_tag</classname></type></typedef><typedef name="system_type"><type>S</type></typedef><typedef name="scale_type"><type>Scale</type></typedef><typedef name="dimension_type"><type>S::dimension_type</type></typedef><typedef name="unit_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="symbol" cv=""><type>static std::string</type></method><method name="name" cv=""><type>static std::string</type></method></method-group></struct></namespace></namespace></header><header name="boost/units/static_constant.hpp"><macro name="BOOST_UNITS_STATIC_CONSTANT" kind="functionlike"><macro-parameter name="name"/><macro-parameter name="type"/><description><para>A convenience macro that allows definition of static constants in headers in an ODR-safe way. </para></description></macro></header><header name="boost/units/static_rational.hpp"><para>Compile-time rational numbers and operators. </para><namespace name="boost"><namespace name="units"><struct name="static_abs"><template>
      <template-nontype-parameter name="Value"><type>integer_type</type></template-nontype-parameter>
    </template><purpose>Compile time absolute value. </purpose><method-group name="public member functions"><method name="BOOST_STATIC_CONSTANT" cv=""><type/><parameter name=""><paramtype>integer_type</paramtype></parameter><parameter name=""><paramtype>value</paramtype></parameter></method></method-group></struct><class name="static_rational"><template>
      <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>integer_type</type><default>1</default></template-nontype-parameter>
    </template><purpose>Compile time rational number. </purpose><description><para>This is an implementation of a compile time rational number, where <computeroutput>static_rational&lt;N,D&gt;</computeroutput> represents a rational number with numerator <computeroutput>N</computeroutput> and denominator <computeroutput>D</computeroutput>. Because of the potential for ambiguity arising from multiple equivalent values of <computeroutput>static_rational</computeroutput> (e.g. <computeroutput>static_rational&lt;6,2&gt;==static_rational&lt;3&gt;</computeroutput>), static rationals should always be accessed through <computeroutput>static_rational&lt;N,D&gt;::type</computeroutput>. Template specialization prevents instantiation of zero denominators (i.e. <computeroutput>static_rational&lt;N,0&gt;</computeroutput>). The following compile-time arithmetic operators are provided for static_rational variables only (no operators are defined between long and static_rational):<itemizedlist>
<listitem><para><computeroutput>mpl::negate</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::plus</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::minus</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::times</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::divides</computeroutput> </para></listitem></itemizedlist>
</para><para>Neither <computeroutput>static_power</computeroutput> nor <computeroutput>static_root</computeroutput> are defined for <computeroutput>static_rational</computeroutput>. This is because template types may not be floating point values, while powers and roots of rational numbers can produce floating point values. </para></description><typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><purpose>static_rational&lt;N,D&gt; reduced by GCD </purpose><type><classname>static_rational</classname>&lt; Numerator, Denominator &gt;</type></typedef><data-member name="Numerator" specifiers="static"><type>const integer_type</type></data-member><data-member name="Denominator" specifiers="static"><type>const integer_type</type></data-member><method-group name="public static functions"><method name="numerator" cv=""><type>static integer_type</type></method><method name="denominator" cv=""><type>static integer_type</type></method></method-group><method-group name="public member functions"/><constructor/></class><typedef name="integer_type"><type>long</type></typedef><function name="value"><type><classname>divide_typeof_helper</classname>&lt; T, T &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter><purpose>get decimal value of <computeroutput>static_rational</computeroutput> </purpose></function></namespace></namespace></header><header name="boost/units/unit.hpp"><namespace name="boost"><namespace name="units"><class name="unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Enable"/>
    </template><purpose>class representing a model-dependent unit with no associated value </purpose><description><para>(e.g. meters, Kelvin, feet, etc...) </para></description><typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef><typedef name="this_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef><typedef name="dimension_type"><type>Dim</type></typedef><typedef name="system_type"><type>System</type></typedef><method-group name="public member functions"/><constructor/><constructor><parameter name=""><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></constructor><copy-assignment><parameter name=""><paramtype>const <classname>this_type</classname> &amp;</paramtype></parameter></copy-assignment><method-group name="private member functions"><method name="BOOST_MPL_ASSERT" cv=""><type/><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="BOOST_MPL_ASSERT" cv=""><type/><parameter name=""><paramtype>(<classname>is_dimension_list</classname>&lt; Dim &gt;)</paramtype></parameter></method></method-group></class><struct-specialization name="reduce_unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>Returns a unique type for every unit. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="power_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>static_rational&lt; N</template-arg><template-arg>D &gt;</template-arg></specialization><purpose>raise unit to a <computeroutput>static_rational</computeroutput> power </purpose><typedef name="type"><type><classname>unit</classname>&lt; typename <classname>static_power</classname>&lt; Dim, <classname>static_rational</classname>&lt; N, D &gt; &gt;::<classname>type</classname>, typename <classname>static_power</classname>&lt; System, <classname>static_rational</classname>&lt; N, D &gt; &gt;::<classname>type</classname> &gt;</type></typedef><method-group name="public static functions"><method name="value" cv=""><type>static <classname>type</classname></type><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="root_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>static_rational&lt; N</template-arg><template-arg>D &gt;</template-arg></specialization><purpose>take the <computeroutput>static_rational</computeroutput> root of a unit </purpose><typedef name="type"><type><classname>unit</classname>&lt; typename <classname>static_root</classname>&lt; Dim, <classname>static_rational</classname>&lt; N, D &gt; &gt;::<classname>type</classname>, typename <classname>static_root</classname>&lt; System, <classname>static_rational</classname>&lt; N, D &gt; &gt;::<classname>type</classname> &gt;</type></typedef><method-group name="public static functions"><method name="value" cv=""><type>static <classname>type</classname></type><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter></method></method-group></struct-specialization><function name="operator+"><type><classname>unary_plus_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>unit runtime unary plus </purpose></function><function name="operator-"><type><classname>unary_minus_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>unit runtime unary minus </purpose></function><function name="operator+"><type><classname>add_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime add two units </purpose></function><function name="operator-"><type><classname>subtract_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime subtract two units </purpose></function><function name="operator*"><type><classname>multiply_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime multiply two units </purpose></function><function name="operator/"><type><classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime divide two units </purpose></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>unit runtime <computeroutput>operator==</computeroutput> </purpose></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>unit runtime <computeroutput>operator!=</computeroutput> </purpose></function></namespace></namespace></header><header name="boost/units/units_fwd.hpp"><para>Forward declarations of library components. </para></header></library-reference>

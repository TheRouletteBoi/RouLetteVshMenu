<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/intrusive/any_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_any_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput>any_base_hook</computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="any_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from this hook in order to store objects of that class in an intrusive container.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>any_base_hook</computeroutput>, then each <computeroutput>any_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="public member functions"><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>container::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>any_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>any_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a container an assertion is raised.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_any_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput>any_member_hook</computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="any_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Store this hook in a class to be inserted in an intrusive container.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="public member functions"><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>container::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>any_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>any_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a container an assertion is raised.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="any_to_slist_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an slist hook </para></description></struct><struct name="any_to_list_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an list hook </para></description></struct><struct name="any_to_set_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as a set hook </para></description></struct><struct name="any_to_avl_set_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as a set hook </para></description></struct><struct name="any_to_bs_set_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as a set hook </para></description></struct><struct name="any_to_unordered_set_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that any hook should behave as an unordered set hook </para></description></struct></namespace></namespace></header><header name="boost/intrusive/avl_set.hpp"><namespace name="boost"><namespace name="intrusive"><class name="avl_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template avl_set is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>avl_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two sets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avl_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the avl_set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to to insert x into the avl_set, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted into the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an aavlitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the avl_set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the avl_set. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an aavlitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the avl_set, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the avl_set. </para></description></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the avl_set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the avl_set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size()) + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)). Basic guarantee.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the avl_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the avl_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty avl_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty avl_set and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is std::distance(last, first).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the avl_set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>avl_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of avl_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the avl_set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>avl_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of avl_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>avl_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>avl_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the avl_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the avl_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a avl_set/avl_multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_avl_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avl_set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="avl_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template avl_multiset is an intrusive container, that mimics most of the interface of std::avl_multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>avl_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two avl_multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avl_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the avl_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the avl_multiset, using pos as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the avl_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the avl_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the avl_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty avl_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty avl_multiset and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the avl_multiset are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>avl_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of avl_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the avl_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>avl_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of avl_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the avl_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>avl_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>avl_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the avl_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a avl_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the avl_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a avl_multiset/avl_multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_avl_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avl_multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>avl_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>avl_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/avl_set_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_avl_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avl_set_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="avl_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from avl_set_base_hook in order to store objects in in an avl_set/avl_multiset. avl_set_base_hook holds the data necessary to maintain the avl_set/avl_multiset and provides an appropriate value_traits class for avl_set/avl_multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>avl_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_avl_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avl_set_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="avl_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member avl_set_member_hook in order to store objects of this class in an avl_set/avl_multiset. avl_set_member_hook holds the data necessary for maintaining the avl_set/avl_multiset and provides an appropriate value_traits class for avl_set/avl_multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>avl_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/avltree.hpp"><namespace name="boost"><namespace name="intrusive"><class name="avltree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template avltree is an intrusive AVL tree container, that is used to construct intrusive avl_set and avl_multiset containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="key_type"><type>value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="value_compare"><type>Config::compare</type></typedef><typedef name="key_compare"><type>value_compare</type></typedef><typedef name="iterator"><type>tree_iterator&lt; <classname>avltree</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>tree_iterator&lt; <classname>avltree</classname>, true &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; node_ptr, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type><classname>avltree_algorithms</classname>&lt; node_traits &gt;</type></typedef><typedef name="insert_commit_data"><type>node_algorithms::insert_commit_data</type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>avltree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the tree before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the tree, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>avltree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the value_traits template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>avltree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of avltree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the avltree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>avltree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of avltree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the avltree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>avltree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>avltree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid end const_iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a tree.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group><method-group name="private static functions"><method name="priv_container_from_end_iterator" cv=""><type>static <classname>avltree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method><method name="priv_container_from_iterator" cv=""><type>static <classname>avltree</classname> &amp;</type><parameter name="it"><paramtype>const const_iterator &amp;</paramtype></parameter></method></method-group></class><struct name="make_avltree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>avltree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>avltree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/avltree_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="avltree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>avltree_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><computeroutput>balance</computeroutput>: The type of the balance factor</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput></para><para><computeroutput>static balance get_balance(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_balance(node_ptr n, balance b);</computeroutput></para><para><computeroutput>static balance negative();</computeroutput></para><para><computeroutput>static balance zero();</computeroutput></para><para><computeroutput>static balance positive();</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="balance"><type>NodeTraits::balance</type></typedef><typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>tree_algorithms::insert_commit_data</type></typedef><method-group name="public static functions"><method name="begin_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="end_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="swap_tree" cv=""><type>static void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed.</para><para>Experimental function </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree or an node initialized by init(...).</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv=""><type>static std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header node of the tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes above the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="next_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="prev_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="erase" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone" cv=""><type>static void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(node_ptr)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(node_ptr)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="clear_and_dispose" cv=""><type>static void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="find" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="equal_range" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if they there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_commit" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="get_header" cv=""><type>static node_ptr</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "n" must be a node inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a pointer to the header node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/bs_set_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_bs_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>bs_set_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="bs_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from bs_set_base_hook in order to store objects in in a bs_set/bs_multiset. bs_set_base_hook holds the data necessary to maintain the bs_set/bs_multiset and provides an appropriate value_traits class for bs_set/bs_multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>bs_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_bs_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>bs_set_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="bs_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member bs_set_member_hook in order to store objects of this class in a bs_set/bs_multiset. bs_set_member_hook holds the data necessary for maintaining the bs_set/bs_multiset and provides an appropriate value_traits class for bs_set/bs_multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>bs_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/circular_list_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="circular_list_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>circular_list_algorithms provides basic algorithms to manipulate nodes forming a circular doubly linked list. An empty circular list is formed by a node whose pointers point to itself.</para><para>circular_list_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_previous(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_previous(node_ptr n, node_ptr prev);</computeroutput></para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><method-group name="public static functions"><method name="init" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, so that inited(this_node) == true</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="inited" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is in a non-used state as if it was initialized by the "init" function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == NodeTraits::get_previous(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: <computeroutput>return NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a circular list. If the circular list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink" cv=""><type>static node_ptr</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node [b, e) from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="link_before" cv=""><type>static void</type><parameter name="nxt_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nxt_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node before nxt_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="link_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter></method><method name="transfer" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range. and p must be a node of a different circular list or may not be an iterator in <emphasis role="bold">Effects</emphasis>: Removes the nodes from [b, e) range from their circular list and inserts them before p in p's circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="transfer" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="i"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must a node of a circular list and p must be a node of a different circular list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the node i from its circular list and inserts it before p in p's circular list. If p == i or p == NodeTraits::get_next(i), this function is a null operation.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="reverse" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time. </para></description></method><method name="move_backwards" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of moved positions. </para></description></method><method name="move_forward" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of moved positions. </para></description></method></method-group><method-group name="private static functions"><method name="swap_prev" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in circular lists or be empty circular lists.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node's position in the first circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_next" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/circular_slist_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="circular_slist_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>circular_slist_algorithms provides basic algorithms to manipulate nodes forming a circular singly linked list. An empty circular list is formed by a node whose pointer to the next node points to itself.</para><para>circular_slist_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><method-group name="public static functions"><method name="init" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, putting the next pointer to null: <computeroutput>NodeTraits::get_next(this_node) == 0</computeroutput></para><para><computeroutput> <emphasis role="bold">Complexity</emphasis>: Constant</computeroutput></para><para><computeroutput> <emphasis role="bold">Throws</emphasis>: Nothing. </computeroutput></para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: or it's a not inserted node: <computeroutput>return !NodeTraitsget_next(this_node) || NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="inited" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the next node of prev_node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="last_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node and last_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the range (prev_node, last_node) from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="link_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="transfer_after" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same circular list or an empty range. and p must be a node of a different circular list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the nodes from (b, e] range from their circular list and inserts them after p in p's circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="get_previous_node" cv=""><type>static node_ptr</type><parameter name="prev_init_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and prev_init_node must be in the same circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the circular list starting. the search from prev_init_node. The first node checked for equality is NodeTraits::get_next(prev_init_node).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements between prev_init_node and this_node.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="get_previous_node" cv=""><type>static node_ptr</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="get_previous_previous_node" cv=""><type>static node_ptr</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the previous node of this_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="get_previous_previous_node" cv=""><type>static node_ptr</type><parameter name="prev_prev_init_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and prev_prev_init_node must be in the same circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the previous node of this_node in the circular list starting. the search from prev_init_node. The first node checked for equality is NodeTraits::get_next((NodeTraits::get_next(prev_prev_init_node)).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a circular list. If the circular list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list, be an empty circular list or be inited.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="link_before" cv=""><type>static void</type><parameter name="nxt_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nxt_node must be a node of a circular list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node before nxt_node in the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the circular list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in circular lists or be empty circular lists.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node's position in the first circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to number of elements of both lists</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="reverse" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements. </para></description></method><method name="move_backwards" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the end of the list.</para><para><emphasis role="bold">Returns</emphasis>: The previous node of p after the function if there has been any movement, Null if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method><method name="move_forward" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the node p n positions towards the beginning of the list.</para><para><emphasis role="bold">Returns</emphasis>: The previous node of p after the function if there has been any movement, Null if n leads equals to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/derivation_value_traits.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="derivation_value_traits"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>safe_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type will derive from node_traits::node </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef><typedef name="pointer"><type>boost::pointer_to_other&lt; node_ptr, T &gt;::type</type></typedef><typedef name="const_pointer"><type>boost::pointer_to_other&lt; node_ptr, const T &gt;::type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member><method-group name="public static functions"><method name="to_node_ptr" cv=""><type>static node_ptr</type><parameter name="value"><paramtype>reference</paramtype></parameter></method><method name="to_node_ptr" cv=""><type>static const_node_ptr</type><parameter name="value"><paramtype>const_reference</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static pointer</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static const_pointer</type><parameter name="n"><paramtype>const_node_ptr</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/intrusive/hashtable.hpp"><namespace name="boost"><namespace name="intrusive"><class name="hashtable"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template hashtable is an intrusive hash table container, that is used to construct intrusive unordered_set and unordered_multiset containers. The no-throw guarantee holds only, if the Equal object and Hasher don't throw.</para><para>hashtable is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: hashtable needs a pointer to an array of type `bucket_type` to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of hashtable more complicated than purely intrusive containers. `bucket_type` is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, power_2_buckets&lt;&gt; and cache_begin&lt;&gt;.</para><para>hashtable only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size hashtables because several key functions, like "empty()", become non-constant time functions. Non constant_time size hashtables are mainly provided to support auto-unlink hooks.</para><para>hashtables, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehashing. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="key_type"><type>value_type</type></typedef><typedef name="key_equal"><type>Config::equal</type></typedef><typedef name="hasher"><type>Config::hash</type></typedef><typedef name="bucket_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="bucket_ptr"><type>boost::pointer_to_other&lt; pointer, bucket_type &gt;::type</type></typedef><typedef name="siterator"><type>slist::iterator</type></typedef><typedef name="const_siterator"><type>slist::const_iterator</type></typedef><typedef name="iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; node_ptr, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type>slist::node_algorithms</type></typedef><typedef name="insert_commit_data"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="local_iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_local_iterator"><type><emphasis>unspecified</emphasis></type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><data-member name="store_hash" specifiers="static"><type>const bool</type></data-member><data-member name="unique_keys" specifiers="static"><type>const bool</type></data-member><data-member name="optimize_multikey" specifiers="static"><type>const bool</type></data-member><data-member name="power_2_buckets" specifiers="static"><type>const bool</type></data-member><data-member name="cache_begin" specifiers="static"><type>const bool</type></data-member><data-member name="compare_hash" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty unordered_set): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty unordered_set): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. Worst case (empty unordered_set): O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method><method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and cache_last options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant_time_size is false. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>hashtable</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: the hasher and the equality function unqualified swap call should not throw.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two unordered_sets. Swaps also the contained bucket array and equality and hasher functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison or hash functors found using ADL throw. Basic guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>hashtable</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter></method><method name="insert_equal" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter></method><method name="insert_unique" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the unordered_set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is std::distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the unordered_set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the unordered_set.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method><method name="insert_unique_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the unordered_set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the unordered_set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const KeyHasher &amp;</paramtype></parameter><parameter name="equal_func"><paramtype>const KeyValueEqual &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal throw. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element is equal to "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or the equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hasher or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method><method name="local_iterator_to" cv=""><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_count" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_size" cv="const"><type><classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const KeyHasher &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hash_func throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="rehash" cv=""><type>void</type><parameter name="new_bucket_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_buckets must be a pointer to a new bucket array or the same as the old bucket array. new_size is the length of the the array pointed by new_buckets. If new_buckets == this-&gt;bucket_pointer() n can be bigger or smaller than this-&gt;bucket_count().</para><para><emphasis role="bold">Effects</emphasis>: Updates the internal reference with the new bucket erases the values from the old bucket and inserts then in the new one.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method></method-group><constructor><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty unordered_set, storing a reference to the bucket array and copies of the key_hasher and equal_func functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after this is disposed. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the unordered_set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the unordered_set, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="s_local_iterator_to" cv=""><type>static local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_local_iterator_to" cv=""><type>static const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="suggested_upper_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="suggested_lower_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lower possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class><struct name="make_hashtable"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>hashtable</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct></namespace></namespace></header><header name="boost/intrusive/intrusive_fwd.hpp"/><header name="boost/intrusive/linear_slist_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="linear_slist_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>linear_slist_algorithms provides basic algorithms to manipulate nodes forming a linear singly linked list.</para><para>linear_slist_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the linear list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_next(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_next(node_ptr n, node_ptr next);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><method-group name="public static functions"><method name="init" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an non-used list element, putting the next pointer to null: <computeroutput>NodeTraits::get_next(this_node) == 0</computeroutput></para><para><computeroutput> <emphasis role="bold">Complexity</emphasis>: Constant</computeroutput></para><para><computeroutput> <emphasis role="bold">Throws</emphasis>: Nothing. </computeroutput></para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" is the only node of a circular list: or it's a not inserted node: <computeroutput>return !NodeTraitsget_next(this_node) || NodeTraits::get_next(this_node) == this_node</computeroutput></para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="inited" cv=""><type>static bool</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the next node of prev_node from the circular list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="last_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node and last_node must be in a circular list or be an empty circular list.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the range (prev_node, last_node) from the linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="link_after" cv=""><type>static void</type><parameter name="prev_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_node must be a node of a linear list.</para><para><emphasis role="bold">Effects</emphasis>: Links this_node after prev_node in the linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="transfer_after" cv=""><type>static void</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="b"><paramtype>node_ptr</paramtype></parameter><parameter name="e"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be nodes of the same linear list or an empty range. and p must be a node of a different linear list.</para><para><emphasis role="bold">Effects</emphasis>: Removes the nodes from (b, e] range from their linear list and inserts them after p in p's linear list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty list, making this_node the only node of the circular list: <computeroutput>NodeTraits::get_next(this_node) == this_node</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="get_previous_node" cv=""><type>static node_ptr</type><parameter name="prev_init_node"><paramtype>node_ptr</paramtype></parameter><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and prev_init_node must be in the same linear list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of this_node in the linear list starting. the search from prev_init_node. The first node checked for equality is NodeTraits::get_next(prev_init_node).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements between prev_init_node and this_node.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="this_node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node must be in a linear list or be an empty linear list.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes in a linear list. If the linear list is empty, returns 1.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_trailing_nodes" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this_node and other_node must be nodes inserted in linear lists or be empty linear lists.</para><para><emphasis role="bold">Effects</emphasis>: Moves all the nodes previously chained after this_node after other_node and vice-versa.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="reverse" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Returns</emphasis>: The new first node of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements. </para></description></method><method name="move_first_n_backwards" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the first n nodes starting at p to the end of the list.</para><para><emphasis role="bold">Returns</emphasis>: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method><method name="move_first_n_forward" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves the first n nodes starting at p to the beginning of the list.</para><para><emphasis role="bold">Returns</emphasis>: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number moved positions. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/link_mode.hpp"><namespace name="boost"><namespace name="intrusive"><enum name="link_mode_type"><enumvalue name="normal_link"><description><para>If this linking policy is specified in a value_traits class as the link_mode, containers configured with such value_traits won't set the hooks of the erased values to a default state. Containers also won't check that the hooks of the new values are default initialized. </para></description></enumvalue><enumvalue name="safe_link"><description><para>If this linking policy is specified in a value_traits class as the link_mode, containers configured with such value_traits will set the hooks of the erased values to a default state. Containers also will check that the hooks of the new values are default initialized. </para></description></enumvalue><enumvalue name="auto_unlink"><description><para>Same as "safe_link" but the user type is an auto-unlink type, so the containers with constant-time size features won't be compatible with value_traits configured with this policy. Containers also know that the a value can be silently erased from the container without using any function provided by the containers. </para></description></enumvalue><description><para>This enumeration defines the type of value_traits that can be defined for Boost.Intrusive containers </para></description></enum></namespace></namespace></header><header name="boost/intrusive/list.hpp"><namespace name="boost"><namespace name="intrusive"><class name="list"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template list is an intrusive container that mimics most of the interface of std::list as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput> and <computeroutput>size_type&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="iterator"><type>list_iterator&lt; <classname>list</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>list_iterator&lt; <classname>list</classname>, true &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef><typedef name="node_algorithms"><type><classname>circular_list_algorithms</classname>&lt; node_traits &gt;</type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="push_back" cv=""><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the back of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the front of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="pop_back" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the last element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="pop_back_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the last element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="pop_front" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="pop_front_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="front" cv=""><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv=""><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a constant iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements contained in the list. if constant-time size option is disabled. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the elements of x and *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="shift_backwards" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="shift_forward" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be valid iterators to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value, or constant-time size is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: b and e must be valid iterators to elements in *this. n must be std::distance(b, e).</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode or auto-unlink value is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element range pointed by b and e No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements erased.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value before the position pointed by p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. No copy constructors are called.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the range pointed by b and e before the position p. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="dispose_and_assign" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="new_ele"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. new_ele must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by new_ele, from list x to this list, before the the element pointed by p. No destructors or copy constructors are called. If p == new_ele or p == ++new_ele, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="start"><paramtype>iterator</paramtype></parameter><parameter name="end"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. start and end must point to elements contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by start and end from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred if constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="start"><paramtype>iterator</paramtype></parameter><parameter name="end"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. start and end must point to elements contained in list x. n == std::distance(start, end)</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by start and end from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="sort" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method><method name="sort" cv=""><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering</para><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to p. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This won't throw if list_base_hook&lt;&gt; or list_member_hook are used. Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method><method name="merge" cv=""><type>void</type><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="merge" cv=""><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="reverse" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="remove" cv=""><type>void</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_and_dispose_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method></method-group><constructor><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a list equal to the range [first,last).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in std::distance(b, e). No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If real_value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: If it's not a safe-mode or an auto-unlink value_type the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the ValueTraits template parameter are set to their default value.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value . Otherwise constant. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>list</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of list.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the list associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>list</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of list.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the list associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </para></description></method></method-group></class><struct name="make_list"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>list</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>list</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/list_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_list_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput>list_base_hook</computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="list_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from this hook in order to store objects of that class in an list.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>list::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>list_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an list an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_list_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput><computeroutput>list_member_hook</computeroutput> that</computeroutput> yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="list_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Store this hook in a class to be inserted in an list.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>list::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>list_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an list an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/member_value_traits.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="member_value_traits"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="PtrToMember"><type>typename NodeTraits::node T::*</type></template-nontype-parameter>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>safe_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type will store a node_traits::node </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="value_type"><type>T</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef><typedef name="pointer"><type>boost::pointer_to_other&lt; node_ptr, T &gt;::type</type></typedef><typedef name="const_pointer"><type>boost::pointer_to_other&lt; node_ptr, const T &gt;::type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member><method-group name="public static functions"><method name="to_node_ptr" cv=""><type>static node_ptr</type><parameter name="value"><paramtype>reference</paramtype></parameter></method><method name="to_node_ptr" cv=""><type>static const_node_ptr</type><parameter name="value"><paramtype>const_reference</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static pointer</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static const_pointer</type><parameter name="n"><paramtype>const_node_ptr</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/intrusive/options.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="constant_time_size"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the intrusive container stores its size as a member to obtain constant-time size() member. </para></description></struct><struct name="size_type"><template>
      <template-type-parameter name="SizeType"/>
    </template><description><para>This option setter specifies the type that the container will use to store its size. </para></description></struct><struct name="compare"><template>
      <template-type-parameter name="Compare"/>
    </template><description><para>This option setter specifies the strict weak ordering comparison functor for the value type </para></description></struct><struct name="floating_point"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter for scapegoat containers specifies if the intrusive scapegoat container should use a non-variable alpha value that does not need floating-point operations.</para><para>If activated, the fixed alpha value is 1/sqrt(2). This option also saves some space in the container since the alpha value and some additional data does not need to be stored in the container.</para><para>If the user only needs an alpha value near 1/sqrt(2), this option also improves performance since avoids logarithm and division operations when rebalancing the tree. </para></description></struct><struct name="equal"><template>
      <template-type-parameter name="Equal"/>
    </template><description><para>This option setter specifies the equality functor for the value type </para></description></struct><struct name="hash"><template>
      <template-type-parameter name="Hash"/>
    </template><description><para>This option setter specifies the hash functor for the value type </para></description></struct><struct name="value_traits"><template>
      <template-type-parameter name="ValueTraits"/>
    </template><description><para>This option setter specifies the relationship between the type to be managed by the container (the value type) and the node to be used in the node algorithms. It also specifies the linking policy. </para></description></struct><struct name="member_hook"><template>
      <template-type-parameter name="Parent"/>
      <template-type-parameter name="MemberHook"/>
      <template-nontype-parameter name="PtrToMember"><type>MemberHook Parent::*</type></template-nontype-parameter>
    </template><description><para>This option setter specifies the member hook the container must use. </para></description></struct><struct name="base_hook"><template>
      <template-type-parameter name="BaseHook"/>
    </template><description><para>This option setter specifies that the container must use the specified base hook </para></description></struct><struct name="void_pointer"><template>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>This option setter specifies the type of a void pointer. This will instruct the hook to use this type of pointer instead of the default one </para></description></struct><struct name="tag"><template>
      <template-type-parameter name="Tag"/>
    </template><description><para>This option setter specifies the type of the tag of a base hook. A type can not have two base hooks of the same type, so a tag can be used to differentiate two base hooks with otherwise same type </para></description></struct><struct name="link_mode"><template>
      <template-nontype-parameter name="LinkType"><type>link_mode_type</type></template-nontype-parameter>
    </template><description><para>This option setter specifies the link mode (normal_link, safe_link or auto_unlink) </para></description></struct><struct name="optimize_size"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the hook should be optimized for size instead of for speed. </para></description></struct><struct name="linear"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the list container should use a linear implementation instead of a circular one. </para></description></struct><struct name="cache_last"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the list container should use a linear implementation instead of a circular one. </para></description></struct><struct name="bucket_traits"><template>
      <template-type-parameter name="BucketTraits"/>
    </template><description><para>This option setter specifies the bucket traits class for unordered associative containers. When this option is specified, instead of using the default bucket traits, a user defined holder will be defined </para></description></struct><struct name="store_hash"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the unordered hook should offer room to store the hash value. Storing the hash in the hook will speed up rehashing processes in applications where rehashing is frequent, rehashing might throw or the value is heavy to hash. </para></description></struct><struct name="optimize_multikey"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the unordered hook should offer room to store another link to another node with the same key. Storing this link will speed up lookups and insertions on unordered_multiset containers with a great number of elements with the same key. </para></description></struct><struct name="power_2_buckets"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the bucket array will be always power of two. This allows using masks instead of the default modulo operation to determine the bucket number from the hash value, leading to better performance. In debug mode, if power of two buckets mode is activated, the bucket length will be checked to through assertions to assure the bucket length is power of two. </para></description></struct><struct name="cache_begin"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the container will cache a pointer to the first non-empty bucket so that begin() is always constant-time. This is specially helpful when we can have containers with a few elements but with big bucket arrays (that is, hashtables with low load factors). </para></description></struct><struct name="compare_hash"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if the container will compare the hash value before comparing objects. This option can't be specified if store_hash&lt;&gt; is not true. This is specially helpful when we have containers with a high load factor. and the comparison function is much more expensive that comparing already stored hash values. </para></description></struct></namespace></namespace></header><header name="boost/intrusive/pointer_plus_bits.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="max_pointer_plus_bits"><template>
      <template-type-parameter name="VoidPointer"/>
      <template-nontype-parameter name="Alignment"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This trait class is used to know if a pointer can embed extra bits of information if it's going to be used to point to objects with an alignment of "Alignment" bytes. </para></description><data-member name="value" specifiers="static"><type>const std::size_t</type></data-member></struct><struct-specialization name="max_pointer_plus_bits"><template>
      <template-nontype-parameter name="Alignment"><type>std::size_t</type></template-nontype-parameter>
    </template><specialization><template-arg>void *</template-arg><template-arg>Alignment</template-arg></specialization><description><para>This is an specialization for raw pointers. Raw pointers can embed extra bits in the lower bits if the alignment is multiple of 2pow(NumBits). </para></description><data-member name="value" specifiers="static"><type>const std::size_t</type></data-member></struct-specialization><struct-specialization name="pointer_plus_bits"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="NumBits"><type>std::size_t</type></template-nontype-parameter>
    </template><specialization><template-arg>T *</template-arg><template-arg>NumBits</template-arg></specialization><description><para>This is the specialization to embed extra bits of information in a raw pointer. The extra bits are stored in the lower bit of the pointer. </para></description><data-member name="Mask" specifiers="static"><type>const std::size_t</type></data-member><typedef name="pointer"><type>T *</type></typedef><method-group name="public static functions"><method name="get_pointer" cv=""><type>static pointer</type><parameter name="n"><paramtype>pointer</paramtype></parameter></method><method name="set_pointer" cv=""><type>static void</type><parameter name="n"><paramtype>pointer &amp;</paramtype></parameter><parameter name="p"><paramtype>pointer</paramtype></parameter></method><method name="get_bits" cv=""><type>static std::size_t</type><parameter name="n"><paramtype>pointer</paramtype></parameter></method><method name="set_bits" cv=""><type>static void</type><parameter name="n"><paramtype>pointer &amp;</paramtype></parameter><parameter name="c"><paramtype>std::size_t</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></header><header name="boost/intrusive/rbtree.hpp"><namespace name="boost"><namespace name="intrusive"><class name="rbtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template rbtree is an intrusive red-black tree container, that is used to construct intrusive set and multiset containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="key_type"><type>value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="value_compare"><type>Config::compare</type></typedef><typedef name="key_compare"><type>value_compare</type></typedef><typedef name="iterator"><type>tree_iterator&lt; <classname>rbtree</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>tree_iterator&lt; <classname>rbtree</classname>, true &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; node_ptr, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type><classname>rbtree_algorithms</classname>&lt; node_traits &gt;</type></typedef><typedef name="insert_commit_data"><type>node_algorithms::insert_commit_data</type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>rbtree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the tree before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the tree, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>rbtree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the value_traits template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>rbtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the rbtree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>rbtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the rbtree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>rbtree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>rbtree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid end const_iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a tree.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method><method name="remove_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method></method-group><method-group name="private static functions"><method name="priv_container_from_end_iterator" cv=""><type>static <classname>rbtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method><method name="priv_container_from_iterator" cv=""><type>static <classname>rbtree</classname> &amp;</type><parameter name="it"><paramtype>const const_iterator &amp;</paramtype></parameter></method></method-group></class><struct name="make_rbtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>rbtree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>rbtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/rbtree_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="rbtree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>rbtree_algorithms provides basic algorithms to manipulate nodes forming a red-black tree. The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990), except that</para><para>(1) the header node is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin(), and to the rightmost node of the tree, to enable linear time performance when used with the generic set algorithms (set_union, etc.);</para><para>(2) when a node being deleted has two children its successor node is relinked into its place, rather than copied, so that the only pointers invalidated are those referring to the deleted node.</para><para>rbtree_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><computeroutput>color</computeroutput>: The type that can store the color of a node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput></para><para><computeroutput>static color get_color(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_color(node_ptr n, color c);</computeroutput></para><para><computeroutput>static color black();</computeroutput></para><para><computeroutput>static color red();</computeroutput> </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="color"><type>NodeTraits::color</type></typedef><typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>tree_algorithms::insert_commit_data</type></typedef><method-group name="public static functions"><method name="begin_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="end_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="swap_tree" cv=""><type>static void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed.</para><para>Experimental function </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree or an node initialized by init(...).</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv=""><type>static std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header node of the tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes above the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="next_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="prev_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="erase" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone" cv=""><type>static void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(node_ptr)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(node_ptr)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="clear_and_dispose" cv=""><type>static void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="find" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="equal_range" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if they there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_commit" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="get_header" cv=""><type>static node_ptr</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "n" must be a node inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a pointer to the header node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/set.hpp"><namespace name="boost"><namespace name="intrusive"><class name="set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template set is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two sets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to to insert x into the set, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted into the set.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the set, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the set.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size()) + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)). Basic guarantee.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is std::distance(last, first).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a set/multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template multiset is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the multiset, using pos as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a set/multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method><method name="remove_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: removes "value" from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic time.</para><para><emphasis role="bold">Note</emphasis>: This static function is only usable with non-constant time size containers that have stateless comparison functors.</para><para>If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued. </para></description></method></method-group></class><struct name="make_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/set_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>set_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from set_base_hook in order to store objects in in a set/multiset. set_base_hook holds the data necessary to maintain the set/multiset and provides an appropriate value_traits class for set/multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>set_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member set_member_hook in order to store objects of this class in a set/multiset. set_member_hook holds the data necessary for maintaining the set/multiset and provides an appropriate value_traits class for set/multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>optimize_size&lt;&gt;</computeroutput> will tell the hook to optimize the hook for size instead of speed. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/sg_set.hpp"><namespace name="boost"><namespace name="intrusive"><class name="sg_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template sg_set is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>sg_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two sets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sg_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the sg_set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to to insert x into the sg_set, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted into the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an ascapegoatitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the sg_set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the sg_set. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an ascapegoatitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the sg_set, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the sg_set. </para></description></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the sg_set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the sg_set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size()) + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)). Basic guarantee.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the sg_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the sg_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method><method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="balance_factor" cv=""><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty sg_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty sg_set and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is std::distance(last, first).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the sg_set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>sg_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of sg_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sg_set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>sg_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of sg_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sg_set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>sg_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>sg_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the sg_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the sg_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a sg_set/sg_multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_sg_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>sg_set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="sg_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template sg_multiset is an intrusive container, that mimics most of the interface of std::sg_multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>sg_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two sg_multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sg_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the sg_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the sg_multiset, using pos as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the sg_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the sg_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the sg_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method><method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="balance_factor" cv=""><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty sg_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty sg_multiset and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the sg_multiset are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>sg_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of sg_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sg_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>sg_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of sg_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sg_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>sg_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>sg_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the sg_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a sg_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the sg_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a sg_multiset/sg_multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_sg_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>sg_multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>sg_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>sg_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/sgtree.hpp"><namespace name="boost"><namespace name="intrusive"><class name="sgtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template sgtree is an intrusive scapegoat tree container, that is used to construct intrusive sg_set and sg_multiset containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>floating_point&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="key_type"><type>value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="value_compare"><type>Config::compare</type></typedef><typedef name="key_compare"><type>value_compare</type></typedef><typedef name="iterator"><type>tree_iterator&lt; <classname>sgtree</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>tree_iterator&lt; <classname>sgtree</classname>, true &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; node_ptr, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type><classname>sgtree_algorithms</classname>&lt; node_traits &gt;</type></typedef><typedef name="insert_commit_data"><type><classname>node_algorithms::insert_commit_data</classname></type></typedef><data-member name="floating_point" specifiers="static"><type>const bool</type></data-member><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>sgtree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree before the upper bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the tree before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the tree, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter></method><method name="insert_unique_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const <classname>insert_commit_data</classname> &amp;</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>sgtree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method><method name="balance_factor" cv="const"><type>float</type><description><para><emphasis role="bold">Returns</emphasis>: The balance factor (alpha) used in this tree</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="balance_factor" cv=""><type>void</type><parameter name="new_alpha"><paramtype>float</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_alpha must be a value between 0.5 and 1.0</para><para><emphasis role="bold">Effects</emphasis>: Establishes a new balance factor (alpha) and rebalances the tree if the new balance factor is stricter (less) than the old factor.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the value_traits template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>sgtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of sgtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sgtree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>sgtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of sgtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the sgtree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>sgtree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>sgtree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid end const_iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a tree.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group><method-group name="private static functions"><method name="priv_container_from_end_iterator" cv=""><type>static <classname>sgtree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method><method name="priv_container_from_iterator" cv=""><type>static <classname>sgtree</classname> &amp;</type><parameter name="it"><paramtype>const const_iterator &amp;</paramtype></parameter></method></method-group></class><struct name="make_sgtree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>sgtree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>sgtree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/sgtree_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="sgtree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>sgtree_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><struct name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><data-member name="depth"><type>std::size_t</type></data-member></struct><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><method-group name="public static functions"><method name="begin_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="end_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="swap_tree" cv=""><type>static void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed.</para><para>Experimental function </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a tree node but not the header.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the node and rebalances the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="unique" cv=""><type>static bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree or an node initialized by init(...).</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv=""><type>static std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header node of the tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes above the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="next_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="prev_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="erase" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="AlphaByMaxSize"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><parameter name="alpha_by_maxsize"><paramtype>AlphaByMaxSize</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree, z a node of that tree and z != header.</para><para><emphasis role="bold">Effects</emphasis>: Erases node "z" from the tree with header "header".</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone" cv=""><type>static void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(node_ptr)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(node_ptr)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="clear_and_dispose" cv=""><type>static void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="find" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="equal_range" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if they there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the upper bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="h"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree before the lower bound according to "comp".</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype><classname>insert_commit_data</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_commit" cv=""><type>static void</type><template>
          <template-type-parameter name="H_Alpha"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const <classname>insert_commit_data</classname> &amp;</paramtype></parameter><parameter name="tree_size"><paramtype>std::size_t</paramtype></parameter><parameter name="h_alpha"><paramtype>H_Alpha</paramtype></parameter><parameter name="max_tree_size"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="rebalance" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>static node_ptr</type><parameter name="old_root"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="get_header" cv=""><type>static node_ptr</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "n" must be a node inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a pointer to the header node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/slist.hpp"><namespace name="boost"><namespace name="intrusive"><class name="slist"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template slist is an intrusive container, that encapsulates a singly-linked list. You can use such a list to squeeze the last bit of performance from your application. Unfortunately, the little gains come with some huge drawbacks. A lot of member functions can't be implemented as efficiently as for standard containers. To overcome this limitation some other member functions with rather unusual semantics have to be introduced.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>linear&lt;&gt;</computeroutput> and <computeroutput>cache_last&lt;&gt;</computeroutput>.</para><para>The iterators of slist are forward iterators. slist provides a static function called "previous" to compute the previous iterator of a given iterator. This function has linear complexity. To improve the usability esp. with the '*_after' functions, ++end() == begin() and previous(begin()) == end() are defined. An new special function "before_begin()" is defined, which returns an iterator that points one less the beginning of the list: ++before_begin() == begin() </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="iterator"><type>slist_iterator&lt; <classname>slist</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>slist_iterator&lt; <classname>slist</classname>, true &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; pointer, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type><emphasis>unspecified</emphasis></type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><data-member name="linear" specifiers="static"><type>const bool</type></data-member><data-member name="cache_last" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="push_front" cv=""><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the front of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="push_back" cv=""><type>void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the back of the list. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method><method name="pop_front" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="pop_front_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the first element of the list. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="front" cv=""><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the first element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="back" cv=""><type>reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method><method name="back" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reference to the last element of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. This function is only available is cache_last&lt;&gt; is true. </para></description></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="before_begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="before_begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="cbefore_begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator that points to a position before the first element. Equivalent to "end()"</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements contained in the list. if constant_time_size is false. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the elements of x and *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements of both lists. Constant-time if linear&lt;&gt; and/or cache_last&lt;&gt; options are used.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="shift_backwards" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third... the last element becomes the first one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number shifts.</para><para><emphasis role="bold">Note</emphasis>: Iterators Does not affect the validity of iterators and references. </para></description></method><method name="shift_forward" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype><default>1</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves forward all the elements, so that the second element becomes the first, the third becomes the second... the first element becomes the last one.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements plus the number shifts.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert_after" cv=""><type>iterator</type><parameter name="prev_p"><paramtype>iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and prev_p must point to an element contained by the list or to end().</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value after the position pointed by prev_p. No copy constructor is called.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="insert_after" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="prev_p"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>Iterator</paramtype></parameter><parameter name="last"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and prev_p must point to an element contained by the list or to the end node.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the [first, last) after the position prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and p must point to an element contained by the list or to end().</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value before the position pointed by p. No copy constructor is called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before p. Constant-time if cache_last&lt;&gt; is true and p == end().</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="p"><paramtype>iterator</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type and p must point to an element contained by the list or to the end node.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the pointed by b and e before the position p. No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements before b. Linear to the number of elements to insert if cache_last&lt;&gt; option is true and p == end().</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. </para></description></method><method name="erase_after" cv=""><type>iterator</type><parameter name="prev"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase_after" cv=""><type>iterator</type><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_first, last) from the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements if it's a safe-mode , auto-unlink value or constant-time size is activated. Constant time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase_after" cv=""><type>iterator</type><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_first, last) from the list. n must be std::distance(before_first, last) - 1. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: constant-time if link_mode is normal_link. Linear to the elements (last - before_first) otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before i.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed by b and e. No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before last.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range [first, last) from the list. n must be std::distance(first, last). No destructors are called.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: linear to the elements before first if link_mode is normal_link and constant_time_size is activated. Linear to the elements before last otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase_after_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="prev"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev of the list. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="erase_after_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_first, last) from the list. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Lineal to the elements (last - before_first + 1).</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased element. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed by i of the list. No destructors are called. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed element, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before i.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this. Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed by b and e. No destructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements plus linear to the elements before first.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="assign" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list if it's a safe-mode or auto-unlink value. Linear to the number of elements inserted in the list otherwise.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="dispose_and_assign" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Clears the list and inserts the range pointed by b and e. No destructors or copy constructors are called. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted plus linear to the elements contained in the list.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. </para></description></method><method name="splice_after" cv=""><type>iterator</type><parameter name="prev"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev is an iterator to an element or x.end()/x.before_begin() in x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, after the the element pointed by prev. No destructors or copy constructors are called.</para><para><emphasis role="bold">Returns</emphasis>: The last element inserted of x or prev if x is empty. This iterator can be used as new "prev" iterator for a new splice_after call. that will splice new values after the previously spliced values.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements contained in x. Constant-time if cache_last&lt;&gt; option is true.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="prev_ele"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev must point to an element contained by this list or to the before_begin() element. prev_ele must point to an element contained in list x or must be x.before_begin().</para><para><emphasis role="bold">Effects</emphasis>: Transfers the element after prev_ele, from list x to this list, after the element pointed by prev. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="before_last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_first and before_last belong to x and ++before_first != x.end() &amp;&amp; before_last != x.end().</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range (before_first, before_last] from list x to this list, after the element pointed by prev_pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred if constant_time_size is true. Constant-time otherwise.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice_after" cv=""><type>void</type><parameter name="prev_pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>iterator</paramtype></parameter><parameter name="before_last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_first and before_last belong to x and ++before_first != x.end() &amp;&amp; before_last != x.end() and n == std::distance(before_first, before_last).</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range (before_first, before_last] from list x to this list, after the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>iterator</type><parameter name="it"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: it is an iterator to an element in x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by it. No destructors or copy constructors are called.</para><para><emphasis role="bold">Returns</emphasis>: The last element inserted of x or the previous element of it if x is empty. This iterator can be used as new "prev" iterator for a new splice call. that will splice new values after the previously spliced values.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements contained in x plus linear to the elements before it. Linear to the elements before it if cache_last&lt;&gt; option is true. Constant-time if cache_last&lt;&gt; option is true and it == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="elem"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: it p must be a valid iterator of *this. elem must point to an element contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the element elem, from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before pos and before elem. Linear to the elements before elem if cache_last&lt;&gt; option is true and pos == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a dereferenceable iterator in *this and first and last belong to x and first and last a valid range on x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [first, last) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the sum of elements before pos, first, and last plus linear to the number of elements transferred if constant_time_size is true. Linear to the sum of elements before first, and last plus linear to the number of elements transferred if constant_time_size is true if cache_last&lt;&gt; is true and pos == end()</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="splice" cv=""><type>void</type><parameter name="pos"><paramtype>iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><parameter name="n"><paramtype>difference_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a dereferenceable iterator in *this and first and last belong to x and first and last a valid range on x. n == std::distance(first, last).</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [first, last) from list x to this list, before the element pointed by pos. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the sum of elements before pos, first, and last. Linear to the sum of elements before first and last if cache_last&lt;&gt; is true and pos == end().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method><method name="sort" cv=""><type>void</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="sort" cv=""><type>void</type><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="merge" cv=""><type>iterator</type><template>
          <template-type-parameter name="Predicate"/>
        </template><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>Predicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the last transferred value, end() is x is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="merge" cv=""><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: if std::less&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="reverse" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear to the contained elements.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method><method name="remove" cv=""><type>void</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. This function is linear time: it performs exactly size() comparisons for equality. </para></description></method><method name="remove_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="remove_and_dispose_if" cv=""><type>void</type><template>
          <template-type-parameter name="Pred"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique" cv=""><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. No destructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If std::equal_to&lt;value_type&gt; throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="unique_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list. Disposer::operator()(pointer) is called for every removed element.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. Basic guarantee.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1) comparisons equality comparisons.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. </para></description></method><method name="previous" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The iterator to the element before i in the list. Returns the end-iterator, if either i is the begin-iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method><method name="previous" cv="const"><type>const_iterator</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The const_iterator to the element before i in the list. Returns the end-const_iterator, if either i is the begin-const_iterator or the list is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i. Constant if cache_last&lt;&gt; is true and i == end(). </para></description></method></method-group><constructor><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: constructs an empty list.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a list equal to [first,last).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in std::distance(b, e). No copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks). </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: If it's a safe-mode or auto-unlink value, the destructor does nothing (ie. no code is generated). Otherwise it detaches all elements from this. In this case the objects in the list are not deleted (i.e. no destructors are called), but the hooks according to the value_traits template parameter are set to their default value.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list, if it's a safe-mode or auto-unlink value. Otherwise constant. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of slist.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the slist associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of slist.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the slist associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns a const_iterator pointing to the element</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be a const reference to a value inserted in a list.</para><para><emphasis role="bold">Effects</emphasis>: This function returns an iterator pointing to the element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated. This static function is available only if the value traits is stateless. </para></description></method></method-group><method-group name="private member functions"><method name="priv_splice_after" cv=""><type>void</type><parameter name="prev_pos_n"><paramtype>node_ptr</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first_n"><paramtype>node_ptr</paramtype></parameter><parameter name="before_last_n"><paramtype>node_ptr</paramtype></parameter></method><method name="priv_reverse" cv=""><type>void</type><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_reverse" cv=""><type>void</type><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_shift_backwards" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_shift_backwards" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_shift_forward" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_shift_forward" cv=""><type>void</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_swap_cache_last" cv=""><type>void</type><parameter name="other"><paramtype><classname>slist</classname> &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="priv_swap_lists" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_swap_lists" cv=""><type>static void</type><parameter name="this_node"><paramtype>node_ptr</paramtype></parameter><parameter name="other_node"><paramtype>node_ptr</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method><method name="priv_container_from_end_iterator" cv=""><type>static <classname>slist</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method></method-group></class><struct name="make_slist"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>slist</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>slist</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/slist_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_slist_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>slist_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="slist_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from slist_base_hook in order to store objects in in an list. slist_base_hook holds the data necessary to maintain the list and provides an appropriate value_traits class for list.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>slist::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>slist_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an slist an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_slist_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>slist_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="slist_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member slist_member_hook in order to store objects of this class in an list. slist_member_hook holds the data necessary for maintaining the list and provides an appropriate value_traits class for list.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput> and <computeroutput>link_mode&lt;&gt;</computeroutput>.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>slist::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>slist_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an slist an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/splay_set.hpp"><namespace name="boost"><namespace name="intrusive"><class name="splay_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template splay_set is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>splay_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two splay_sets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splay_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the splay_set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to to insert x into the splay_set, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted into the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the splay_set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the splay_set. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the splay_set, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the key_value_comp ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the splay_set. </para></description></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the splay_set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the splay_set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is amortized O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is amortized O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size()) + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If the comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(value)). Basic guarantee.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a splay_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the splay_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a splay_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the splay_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="splay_up" cv=""><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="splay_down" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method><method name="splay_down" cv=""><type>iterator</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty splay_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty splay_set and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise amortized N * log N, where N is std::distance(last, first).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the splay_set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>splay_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of splay_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splay_set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>splay_set</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of splay_set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splay_set associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>splay_set</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>splay_set</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of set.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the set associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a splay_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the splay_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a splay_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the splay_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a splay_set/multisplay_set.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_splay_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splay_set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="splay_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template splay_multiset is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="value_compare"><type>implementation_defined::value_compare</type></typedef><typedef name="key_compare"><type>implementation_defined::key_compare</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="reverse_iterator"><type>implementation_defined::reverse_iterator</type></typedef><typedef name="const_reverse_iterator"><type>implementation_defined::const_reverse_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_compare object used by the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_compare copy-constructor throws. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if, constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>splay_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two splay_multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison functor found using ADL throws. Strong guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splay_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the splay_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the splay_multiset, using pos as a hint to where it will be inserted.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a range into the splay_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator that points to the position where the new element was inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is amortized O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is amortized O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that compare equal with the given key and the given comparison functor.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased element.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the element after the erased elements.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is amortized O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(value)).</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + this-&gt;count(key, comp)).</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the same key compared with the given comparison functor.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element whose key according to the comparison functor is greater than key or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" according to the comparison functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If the internal value_compare ordering function throws. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: comp must imply the same element order as value_compare. Usually key is the part of the value_type that is used in the ordering functor.</para><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k according to the comparison functor or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If comp ordering function throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="splay_up" cv=""><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="splay_down" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method><method name="splay_down" cv=""><type>iterator</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty splay_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>const value_compare &amp;</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty splay_multiset and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise amortized N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>splay_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of splay_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splay_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>splay_multiset</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of splay_multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splay_multiset associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>splay_multiset</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>splay_multiset</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid const_iterator of multiset.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the multiset associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a set/splay_multiset.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group></class><struct name="make_splay_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splay_multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>splay_set</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>splay_multiset</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/splay_set_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_splay_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splay_set_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="splay_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from splay_set_base_hook in order to store objects in in a splay_set/splay_multiset. splay_set_base_hook holds the data necessary to maintain the splay_set/splay_multiset and provides an appropriate value_traits class for splay_set/splay_multiset.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>splay_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>splay_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>splay_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_splay_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splay_set_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="splay_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member splay_set_member_hook in order to store objects of this class in a splay_set/splay_multiset. splay_set_member_hook holds the data necessary for maintaining the splay_set/splay_multiset and provides an appropriate value_traits class for splay_set/splay_multiset.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>optimize_size&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>). </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>splay_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>splay_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>splay_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in a set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header><header name="boost/intrusive/splaytree.hpp"><namespace name="boost"><namespace name="intrusive"><class name="splaytree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template splaytree is an intrusive splay tree container that is used to construct intrusive splay_set and splay_multiset containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput> and <computeroutput>compare&lt;&gt;</computeroutput>. </para></description><typedef name="value_traits"><type>Config::value_traits</type></typedef><typedef name="pointer"><type>real_value_traits::pointer</type></typedef><typedef name="const_pointer"><type>real_value_traits::const_pointer</type></typedef><typedef name="value_type"><type>std::iterator_traits&lt; pointer &gt;::value_type</type></typedef><typedef name="key_type"><type>value_type</type></typedef><typedef name="reference"><type>std::iterator_traits&lt; pointer &gt;::reference</type></typedef><typedef name="const_reference"><type>std::iterator_traits&lt; const_pointer &gt;::reference</type></typedef><typedef name="difference_type"><type>std::iterator_traits&lt; pointer &gt;::difference_type</type></typedef><typedef name="size_type"><type>Config::size_type</type></typedef><typedef name="value_compare"><type>Config::compare</type></typedef><typedef name="key_compare"><type>value_compare</type></typedef><typedef name="iterator"><type>tree_iterator&lt; <classname>splaytree</classname>, false &gt;</type></typedef><typedef name="const_iterator"><type>tree_iterator&lt; <classname>splaytree</classname>, true &gt;</type></typedef><typedef name="reverse_iterator"><type>std::reverse_iterator&lt; iterator &gt;</type></typedef><typedef name="const_reverse_iterator"><type>std::reverse_iterator&lt; const_iterator &gt;</type></typedef><typedef name="node_traits"><type>real_value_traits::node_traits</type></typedef><typedef name="node"><type>node_traits::node</type></typedef><typedef name="node_ptr"><type>boost::pointer_to_other&lt; pointer, node &gt;::type</type></typedef><typedef name="const_node_ptr"><type>boost::pointer_to_other&lt; node_ptr, const node &gt;::type</type></typedef><typedef name="node_algorithms"><type><classname>splaytree_algorithms</classname>&lt; node_traits &gt;</type></typedef><typedef name="insert_commit_data"><type>node_algorithms::insert_commit_data</type></typedef><data-member name="constant_time_size" specifiers="static"><type>const bool</type></data-member><data-member name="stateful_value_traits" specifiers="static"><type>const bool</type></data-member><method-group name="public member functions"><method name="get_real_value_traits" cv="const"><type>const real_value_traits &amp;</type></method><method name="get_real_value_traits" cv=""><type>real_value_traits &amp;</type></method><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv=""><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the value_compare object used by the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_compare copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>splaytree</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two multisets.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor's swap call throws. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree before the lower bound.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for insert element is amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator.</para><para><emphasis role="bold">Effects</emphasis>: Inserts x into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_equal" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a each element of a range into the tree before the upper bound of the key of each element.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general amortized O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the tree if the value is not already present.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue, and "hint" must be a valid iterator</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert x into the tree, using "hint" as a hint to where it will be inserted.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Tries to insert each element of a range into the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general amortized O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="key_value_comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="insert_unique_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter></method><method name="erase" cv=""><type>iterator</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type>iterator</type><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is amortized O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp".</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase element is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>iterator</paramtype></parameter><parameter name="e"><paramtype>iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity for erase range is amortized O(log(size() + N)), where N is the number of elements in the range.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + N).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements calling disposer(p) for each node to be erased. <emphasis role="bold">Complexity</emphasis>: Amortized O(log(size() + N)), where N is the number of elements in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="count_dont_splay" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic to the number of elements contained plus lineal to number of objects with the given key.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="lower_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="upper_bound_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="find_dont_splay" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is k or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="equal_range_dont_splay" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>splaytree</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="unlink_leftmost_without_rebalance" cv=""><type>pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Unlinks the leftmost node from the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </para></description></method><method name="splay_up" cv=""><type>void</type><parameter name="i"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that the element pointed by i is placed as the root of the tree, improving future searches of this value.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="splay_down" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyValueCompare"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyValueCompare</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree. If the element is not present returns the last node compared with the key. If the tree is empty, end() is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the comparison functor throws. </para></description></method><method name="splay_down" cv=""><type>iterator</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Rearranges the splay set so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized logarithmic.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new root of the tree, end() if the tree is empty.</para><para><emphasis role="bold">Throws</emphasis>: If the predicate throws. </para></description></method><method name="replace_node" cv=""><type>void</type><parameter name="replace_this"><paramtype>iterator</paramtype></parameter><parameter name="with_this"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="rebalance" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>iterator</type><parameter name="root"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in the subtree. </para></description></method></method-group><constructor><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="unique"><paramtype>bool</paramtype></parameter><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="cmp"><paramtype>value_compare</paramtype><default>value_compare()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty tree and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if [b, e) is already sorted using comp and otherwise amortized N * log N, where N is the distance between first and last.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the copy constructor of the value_compare object throws. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the value_traits template parameter are reinitialized and thus can be reused.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="container_from_end_iterator" cv=""><type>static <classname>splaytree</classname> &amp;</type><parameter name="end_iterator"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end iterator of splaytree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splaytree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_end_iterator" cv=""><type>static const <classname>splaytree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: end_iterator must be a valid end const_iterator of splaytree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the splaytree associated to the end iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method><method name="container_from_iterator" cv=""><type>static <classname>splaytree</classname> &amp;</type><parameter name="it"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="container_from_iterator" cv=""><type>static const <classname>splaytree</classname> &amp;</type><parameter name="it"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Precondition</emphasis>: it must be a valid end const_iterator of rbtree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the tree associated to the iterator</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method><method name="s_iterator_to" cv=""><type>static iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_iterator_to" cv=""><type>static const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator i belonging to the set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="init_node" cv=""><type>static void</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value shall not be in a tree.</para><para><emphasis role="bold">Effects</emphasis>: init_node puts the hook of a value in a well-known default state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </para></description></method></method-group><method-group name="private static functions"><method name="priv_container_from_end_iterator" cv=""><type>static <classname>splaytree</classname> &amp;</type><parameter name="end_iterator"><paramtype>const const_iterator &amp;</paramtype></parameter></method><method name="priv_container_from_iterator" cv=""><type>static <classname>splaytree</classname> &amp;</type><parameter name="it"><paramtype>const const_iterator &amp;</paramtype></parameter></method></method-group></class><struct name="make_splaytree"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>splaytree</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>splaytree</classname>&lt; T, Options...&gt; &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/intrusive/splaytree_algorithms.hpp"><namespace name="boost"><namespace name="intrusive"><class name="splaytree_algorithms"><template>
      <template-type-parameter name="NodeTraits"/>
    </template><description><para>A splay tree is an implementation of a binary search tree. The tree is self balancing using the splay algorithm as described in</para><para>"Self-Adjusting Binary Search Trees by Daniel Dominic Sleator and Robert Endre Tarjan AT&amp;T Bell Laboratories, Murray Hill, NJ Journal of the ACM, Vol 32, no 3, July 1985, pp 652-686 splaytree_algorithms is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</para><para><emphasis role="bold">Typedefs</emphasis>:</para><para><computeroutput>node</computeroutput>: The type of the node that forms the circular list</para><para><computeroutput>node_ptr</computeroutput>: A pointer to a node</para><para><computeroutput>const_node_ptr</computeroutput>: A pointer to a const node</para><para><emphasis role="bold">Static functions</emphasis>:</para><para><computeroutput>static node_ptr get_parent(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_parent(node_ptr n, node_ptr parent);</computeroutput></para><para><computeroutput>static node_ptr get_left(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_left(node_ptr n, node_ptr left);</computeroutput></para><para><computeroutput>static node_ptr get_right(const_node_ptr n);</computeroutput></para><para><computeroutput>static void set_right(node_ptr n, node_ptr right);</computeroutput> </para></description><typedef name="node"><type>NodeTraits::node</type></typedef><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="node_ptr"><type>NodeTraits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>NodeTraits::const_node_ptr</type></typedef><typedef name="insert_commit_data"><description><para>This type is the information that will be filled by insert_unique_check </para></description><type>tree_algorithms::insert_commit_data</type></typedef><method-group name="public static functions"><method name="begin_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="end_node" cv=""><type>static node_ptr</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter></method><method name="unique" cv=""><type>static bool</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree or an node initialized by init(...).</para><para><emphasis role="bold">Effects</emphasis>: Returns true if the node is initialized by init().</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="unlink" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="swap_nodes" cv=""><type>static void</type><parameter name="node1"><paramtype>node_ptr</paramtype></parameter><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="node2"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed.</para><para>Experimental function </para></description></method><method name="replace_node" cv=""><type>static void</type><parameter name="node_to_be_replaced"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed.</para><para>Experimental function </para></description></method><method name="next_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the next node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="prev_node" cv=""><type>static node_ptr</type><parameter name="p"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a node from the tree except the leftmost node.</para><para><emphasis role="bold">Effects</emphasis>: Returns the previous node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Average constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="init" cv=""><type>static void</type><parameter name="node"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: After the function unique(node) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="init_header" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node must not be part of any tree.</para><para><emphasis role="bold">Effects</emphasis>: Initializes the header to represent an empty tree. unique(header) == true.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Nodes</emphasis>: If node is inserted in a tree, this function corrupts the tree. </para></description></method><method name="clear_and_dispose" cv=""><type>static void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Empties the target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="count" cv=""><type>static std::size_t</type><parameter name="node"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: node is a node of the tree but it's not the header.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes of the subtree.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv=""><type>static std::size_t</type><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header is the header node of the tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of nodes above the header.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap_tree" cv=""><type>static void</type><parameter name="header1"><paramtype>node_ptr</paramtype></parameter><parameter name="header2"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header1 and header2 must be the header nodes of two trees.</para><para><emphasis role="bold">Effects</emphasis>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="insert_unique_commit" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_value"><paramtype>node_ptr</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</para><para><emphasis role="bold">Effects</emphasis>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</para><para><emphasis role="bold">Complexity</emphasis>: Average complexity is at most logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</para><para>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </para></description></method><method name="insert_unique_check" cv=""><type>static std::pair&lt; node_ptr, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method><method name="is_header" cv=""><type>static bool</type><parameter name="p"><paramtype>const_node_ptr</paramtype></parameter></method><method name="find" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="splay"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="equal_range" cv=""><type>static std::pair&lt; node_ptr, node_ptr &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="splay"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if they there are no equivalent elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="splay"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter><parameter name="splay"><paramtype>bool</paramtype><default>true</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</para><para><emphasis role="bold">Effects</emphasis>: Returns an node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="hint"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</para><para><emphasis role="bold">Effects</emphasis>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</para><para><emphasis role="bold">Throws</emphasis>: If "comp" throws. </para></description></method><method name="insert_equal_upper_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter></method><method name="insert_equal_lower_bound" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="NodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="new_node"><paramtype>node_ptr</paramtype></parameter><parameter name="comp"><paramtype>NodePtrCompare</paramtype></parameter></method><method name="clone" cv=""><type>static void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="source_header"><paramtype>const_node_ptr</paramtype></parameter><parameter name="target_header"><paramtype>node_ptr</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: First empties target tree calling <computeroutput>void disposer::operator()(node_ptr)</computeroutput> for every node of the tree except the header.</para><para>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <computeroutput>node_ptr Cloner::operator()(node_ptr)</computeroutput> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <computeroutput>void disposer(node_ptr)</computeroutput>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</para><para><emphasis role="bold">Throws</emphasis>: If cloner functor throws. If this happens target nodes are disposed. </para></description></method><method name="erase" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="z"><paramtype>node_ptr</paramtype></parameter><parameter name="splay"><paramtype>bool</paramtype><default>true</default></parameter></method><method name="splay_up" cv=""><type>static void</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter><parameter name="header"><paramtype>node_ptr</paramtype></parameter></method><method name="splay_down" cv=""><type>static node_ptr</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyNodePtrCompare"/>
        </template><parameter name="header"><paramtype>node_ptr</paramtype></parameter><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="comp"><paramtype>KeyNodePtrCompare</paramtype></parameter></method><method name="rebalance" cv=""><type>static void</type><parameter name="header"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: header must be the header of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="rebalance_subtree" cv=""><type>static node_ptr</type><parameter name="old_root"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: old_root is a node of a tree.</para><para><emphasis role="bold">Effects</emphasis>: Rebalances the subtree rooted at old_root.</para><para><emphasis role="bold">Returns</emphasis>: The new root of the subtree.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear. </para></description></method><method name="get_header" cv=""><type>static node_ptr</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "n" must be a node inserted in a tree.</para><para><emphasis role="bold">Effects</emphasis>: Returns a pointer to the header node of the tree.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class></namespace></namespace></header><header name="boost/intrusive/trivial_value_traits.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="trivial_value_traits"><template>
      <template-type-parameter name="NodeTraits"/>
      <template-nontype-parameter name="LinkMode"><type>link_mode_type</type><default>normal_link</default></template-nontype-parameter>
    </template><description><para>This value traits template is used to create value traits from user defined node traits where value_traits::value_type and node_traits::node should be equal </para></description><typedef name="node_traits"><type>NodeTraits</type></typedef><typedef name="node_ptr"><type>node_traits::node_ptr</type></typedef><typedef name="const_node_ptr"><type>node_traits::const_node_ptr</type></typedef><typedef name="value_type"><type>node_traits::node</type></typedef><typedef name="pointer"><type>node_ptr</type></typedef><typedef name="const_pointer"><type>const_node_ptr</type></typedef><data-member name="link_mode" specifiers="static"><type>const link_mode_type</type></data-member><method-group name="public static functions"><method name="to_node_ptr" cv=""><type>static node_ptr</type><parameter name="value"><paramtype>value_type &amp;</paramtype></parameter></method><method name="to_node_ptr" cv=""><type>static const_node_ptr</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static pointer</type><parameter name="n"><paramtype>node_ptr</paramtype></parameter></method><method name="to_value_ptr" cv=""><type>static const_pointer</type><parameter name="n"><paramtype>const_node_ptr</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/intrusive/unordered_set.hpp"><namespace name="boost"><namespace name="intrusive"><class name="unordered_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template unordered_set is an intrusive container, that mimics most of the interface of std::tr1::unordered_set as described in the C++ TR1.</para><para>unordered_set is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: unordered_set needs a pointer to an array of type `bucket_type` to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of unordered_set more complicated than purely intrusive containers. `bucket_type` is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, power_2_buckets&lt;&gt; and cache_begin&lt;&gt;.</para><para>unordered_set only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size unordered_sets because several key functions, like "empty()", become non-constant time functions. Non constant-time size unordered_sets are mainly provided to support auto-unlink hooks.</para><para>unordered_set, unlike std::unordered_set, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehasing. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="bucket_traits"><type>implementation_defined::bucket_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="key_type"><type>implementation_defined::key_type</type></typedef><typedef name="key_equal"><type>implementation_defined::key_equal</type></typedef><typedef name="hasher"><type>implementation_defined::hasher</type></typedef><typedef name="bucket_type"><type>implementation_defined::bucket_type</type></typedef><typedef name="bucket_ptr"><type>implementation_defined::bucket_ptr</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="local_iterator"><type>implementation_defined::local_iterator</type></typedef><typedef name="const_local_iterator"><type>implementation_defined::const_local_iterator</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method><method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and cache_last options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>unordered_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: the hasher and the equality function unqualified swap call should not throw.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two unordered_sets. Swaps also the contained bucket array and equality and hasher functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison or hash functors found using ADL throw. Basic guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>unordered_set</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. Basic guarantee. </para></description></method><method name="insert" cv=""><type>std::pair&lt; iterator, bool &gt;</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Tries to inserts value into the unordered_set.</para><para><emphasis role="bold">Returns</emphasis>: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true. If there is an equivalent value returns a pair containing an iterator to the already present value and false.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(N), where N is std::distance(b, e). Worst case O(N*this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert_check" cv=""><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hasher"><paramtype>KeyHasher</paramtype></parameter><parameter name="key_value_equal"><paramtype>KeyValueEqual</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hasher" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hasher" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Checks if a value can be inserted in the unordered_set, using a user provided key instead of the value itself.</para><para><emphasis role="bold">Returns</emphasis>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hasher or key_value_equal throw. Strong guarantee.</para><para><emphasis role="bold">Notes</emphasis>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful.</para><para>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time.</para><para>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the unordered_set.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method><method name="insert_commit" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><parameter name="commit_data"><paramtype>const insert_commit_data &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the unordered_set between the "insert_check" that filled "commit_data" and the call to "insert_commit".</para><para><emphasis role="bold">Effects</emphasis>: Inserts the value in the unordered_set using the information obtained from the "commit_data" that a previous "insert_check" filled.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the newly inserted object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Notes</emphasis>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls.</para><para>After a successful rehashing insert_commit_data remains valid. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hasher" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hasher" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>iterator</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all of the elements.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given value</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element is equal to "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, hash_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or the equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"equal_func" must be a equality function that induces the same equality as key_equal. The difference is that "equal_func" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hash_func or equal_func throw.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the internal hash function throws. </para></description></method><method name="local_iterator_to" cv=""><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_count" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_size" cv="const"><type><classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><parameter name="k"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hash_func throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="rehash" cv=""><type>void</type><parameter name="new_bucket_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_buckets must be a pointer to a new bucket array or the same as the old bucket array. new_size is the length of the the array pointed by new_buckets. If new_buckets == this-&gt;bucket_pointer() n can be bigger or smaller than this-&gt;bucket_count().</para><para><emphasis role="bold">Effects</emphasis>: Updates the internal reference with the new bucket erases the values from the old bucket and inserts then in the new one.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. Basic guarantee. </para></description></method></method-group><constructor><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty unordered_set_impl, storing a reference to the bucket array and copies of the hasher and equal functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of Hash or Equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after this is disposed. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource and Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty unordered_set and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: If N is std::distance(b, e): Average case is O(N) (with a good hash function and with buckets_len &gt;= N),worst case O(N2).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after this is disposed. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the unordered_set are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the unordered_set, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="s_local_iterator_to" cv=""><type>static local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_local_iterator_to" cv=""><type>static const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="suggested_upper_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="suggested_lower_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lower possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class><struct name="make_unordered_set"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define an <computeroutput>unordered_set</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="unordered_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>The class template unordered_multiset is an intrusive container, that mimics most of the interface of std::tr1::unordered_multiset as described in the C++ TR1.</para><para>unordered_multiset is a semi-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: unordered_multiset needs a pointer to an array of type `bucket_type` to be passed in the constructor. This bucket array must have at least the same lifetime as the container. This makes the use of unordered_multiset more complicated than purely intrusive containers. `bucket_type` is default-constructible, copyable and assignable</para><para>The template parameter <computeroutput>T</computeroutput> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</para><para>The container supports the following options: <computeroutput>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</computeroutput>, <computeroutput>constant_time_size&lt;&gt;</computeroutput>, <computeroutput>size_type&lt;&gt;</computeroutput>, <computeroutput>hash&lt;&gt;</computeroutput> and <computeroutput>equal&lt;&gt;</computeroutput> <computeroutput>bucket_traits&lt;&gt;</computeroutput>, power_2_buckets&lt;&gt; and cache_begin&lt;&gt;.</para><para>unordered_multiset only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket. Local iterators are faster and smaller.</para><para>It's not recommended to use non constant-time size unordered_multisets because several key functions, like "empty()", become non-constant time functions. Non constant-time size unordered_multisets are mainly provided to support auto-unlink hooks.</para><para>unordered_multiset, unlike std::unordered_set, does not make automatic rehashings nor offers functions related to a load factor. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment.</para><para>Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements. Iterators are only invalidated when rehasing. </para></description><typedef name="value_type"><type>implementation_defined::value_type</type></typedef><typedef name="value_traits"><type>implementation_defined::value_traits</type></typedef><typedef name="bucket_traits"><type>implementation_defined::bucket_traits</type></typedef><typedef name="pointer"><type>implementation_defined::pointer</type></typedef><typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef><typedef name="reference"><type>implementation_defined::reference</type></typedef><typedef name="const_reference"><type>implementation_defined::const_reference</type></typedef><typedef name="difference_type"><type>implementation_defined::difference_type</type></typedef><typedef name="size_type"><type>implementation_defined::size_type</type></typedef><typedef name="key_type"><type>implementation_defined::key_type</type></typedef><typedef name="key_equal"><type>implementation_defined::key_equal</type></typedef><typedef name="hasher"><type>implementation_defined::hasher</type></typedef><typedef name="bucket_type"><type>implementation_defined::bucket_type</type></typedef><typedef name="bucket_ptr"><type>implementation_defined::bucket_ptr</type></typedef><typedef name="iterator"><type>implementation_defined::iterator</type></typedef><typedef name="const_iterator"><type>implementation_defined::const_iterator</type></typedef><typedef name="insert_commit_data"><type>implementation_defined::insert_commit_data</type></typedef><typedef name="local_iterator"><type>implementation_defined::local_iterator</type></typedef><typedef name="const_local_iterator"><type>implementation_defined::const_local_iterator</type></typedef><typedef name="node_traits"><type>implementation_defined::node_traits</type></typedef><typedef name="node"><type>implementation_defined::node</type></typedef><typedef name="node_ptr"><type>implementation_defined::node_ptr</type></typedef><typedef name="const_node_ptr"><type>implementation_defined::const_node_ptr</type></typedef><typedef name="node_algorithms"><type>implementation_defined::node_algorithms</type></typedef><method-group name="private member functions"/><constructor><parameter name=""><paramtype>const <classname>unordered_multiset</classname> &amp;</paramtype></parameter><description><para>This class is non-copyable </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>unordered_multiset</classname> &amp;</paramtype></parameter><description><para>This class is non-assignable </para></description></copy-assignment><method-group name="public member functions"><method name="begin" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the beginning of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the beginning of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time if `cache_begin&lt;&gt;` is true. Amortized constant time with worst case (empty unordered_set) O(this-&gt;bucket_count())</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv=""><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator pointing to the end of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator pointing to the end of the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="hash_function" cv="const"><type>hasher</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the hasher object used by the unordered_set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If hasher copy-constructor throws. </para></description></method><method name="key_eq" cv="const"><type>key_equal</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the key_equal object used by the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If key_equal copy-constructor throws. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true is the container is empty.</para><para><emphasis role="bold">Complexity</emphasis>: if constant-time size and cache_last options are disabled, average constant time (worst case, with empty() == true: O(this-&gt;bucket_count()). Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="size" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements stored in the unordered_multiset.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to elements contained in *this if constant-time size option is enabled. Constant-time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="other"><paramtype><classname>unordered_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: the hasher and the equality function unqualified swap call should not throw.</para><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of two unordered_multisets. Swaps also the contained bucket array and equality and hasher functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the swap() call for the comparison or hash functors found using ADL throw. Basic guarantee. </para></description></method><method name="clone_from" cv=""><type>void</type><template>
          <template-type-parameter name="Cloner"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="src"><paramtype>const <classname>unordered_multiset</classname> &amp;</paramtype></parameter><parameter name="cloner"><paramtype>Cloner</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this.</para><para>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to erased plus inserted elements.</para><para><emphasis role="bold">Throws</emphasis>: If cloner throws. </para></description></method><method name="insert" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue</para><para><emphasis role="bold">Effects</emphasis>: Inserts value into the unordered_multiset.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the new inserted value.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Strong guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="insert" cv=""><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to this-&gt;insert(t) for each element in [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by value_comp().</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references. No copy-constructors are called. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased element. No destructors are called. </para></description></method><method name="erase" cv=""><type>void</type><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements that have the same hash and compare equal with the given key.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the hash_func or the equal_func functors throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="i"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by i. Disposer::operator()(pointer) is called for the removed element.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="b"><paramtype>const_iterator</paramtype></parameter><parameter name="e"><paramtype>const_iterator</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(std::distance(b, e)), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="value"><paramtype>const_reference</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="erase_and_dispose" cv=""><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements with the given key. according to the comparison functor "equal_func". Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Returns</emphasis>: The number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If hash_func or equal_func throw. Basic guarantee.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators to the erased elements. </para></description></method><method name="clear" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="clear_and_dispose" cv=""><type>void</type><template>
          <template-type-parameter name="Disposer"/>
        </template><parameter name="disposer"><paramtype>Disposer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Disposer::operator()(pointer) shouldn't throw.</para><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on the container. Disposer::operator()(pointer) is called for the removed elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="count" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of contained elements with the given key</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv=""><type>iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose value is "value" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv=""><type>iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="find" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Finds a const_iterator to the first element whose key is "key" or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(1), worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv=""><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with values equivalent to value. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(value)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws. </para></description></method><method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
          <template-type-parameter name="KeyValueEqual"/>
        </template><parameter name="key"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>KeyHasher</paramtype></parameter><parameter name="equal_func"><paramtype>KeyValueEqual</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para>"key_value_equal" must be a equality function that induces the same equality as key_equal. The difference is that "key_value_equal" compares an arbitrary key with the contained values.</para><para><emphasis role="bold">Effects</emphasis>: Returns a range containing all elements with equivalent keys. Returns std::make_pair(this-&gt;end(), this-&gt;end()) if no such elements exist.</para><para><emphasis role="bold">Complexity</emphasis>: Average case O(this-&gt;count(key, hash_func, equal_func)). Worst case O(this-&gt;size()).</para><para><emphasis role="bold">Throws</emphasis>: If the internal hasher or the equality functor throws.</para><para><emphasis role="bold">Note</emphasis>: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type. Usually this key is part of the value_type. </para></description></method><method name="iterator_to" cv=""><type>iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid iterator belonging to the unordered_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash function throws. </para></description></method><method name="iterator_to" cv="const"><type>const_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_multiset of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_iterator belonging to the unordered_multiset that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash function throws. </para></description></method><method name="local_iterator_to" cv=""><type>local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="local_iterator_to" cv="const"><type>const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_count" cv="const"><type><classname>size_type</classname></type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of buckets passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket_size" cv="const"><type><classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns the number of elements in the nth bucket.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><parameter name="k"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket" cv="const"><type><classname>size_type</classname></type><template>
          <template-type-parameter name="KeyType"/>
          <template-type-parameter name="KeyHasher"/>
        </template><parameter name="k"><paramtype>const KeyType &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const KeyHasher &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: "hash_func" must be a hash function that induces the same hash values as the stored hasher. The difference is that "hash_func" hashes the given key instead of the value_type.</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If the hash functor throws.</para><para><emphasis role="bold">Note</emphasis>: the return value is in the range [0, this-&gt;bucket_count()). </para></description></method><method name="bucket_pointer" cv="const"><type>bucket_ptr</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the bucket array pointer passed in the constructor or the last rehash function.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="begin" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="begin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cbegin" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv=""><type>local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="end" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="cend" cv="const"><type>const_local_iterator</type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: n is in the range [0, this-&gt;bucket_count()).</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: [this-&gt;begin(n), this-&gt;end(n)) is a valid range containing all of the elements in the nth bucket. </para></description></method><method name="rehash" cv=""><type>void</type><parameter name="new_bucket_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: new_buckets must be a pointer to a new bucket array or the same as the old bucket array. new_size is the length of the the array pointed by new_buckets. If new_buckets == this-&gt;bucket_pointer() n can be bigger or smaller than this-&gt;bucket_count().</para><para><emphasis role="bold">Effects</emphasis>: Updates the internal reference with the new bucket erases the values from the old bucket and inserts then in the new one.</para><para><emphasis role="bold">Complexity</emphasis>: Average case linear in this-&gt;size(), worst case quadratic.</para><para><emphasis role="bold">Throws</emphasis>: If the hasher functor throws. </para></description></method></method-group><constructor><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty unordered_multiset, storing a reference to the bucket array and copies of the hasher and equal functors.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of Hash or Equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after this is disposed. </para></description></constructor><constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="b"><paramtype>Iterator</paramtype></parameter><parameter name="e"><paramtype>Iterator</paramtype></parameter><parameter name="b_traits"><paramtype>const <classname>bucket_traits</classname> &amp;</paramtype></parameter><parameter name="hash_func"><paramtype>const hasher &amp;</paramtype><default>hasher()</default></parameter><parameter name="equal_func"><paramtype>const key_equal &amp;</paramtype><default>key_equal()</default></parameter><parameter name="v_traits"><paramtype>const <classname>value_traits</classname> &amp;</paramtype><default>value_traits()</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: buckets must not be being used by any other resource and Dereferencing iterator must yield an lvalue of type value_type.</para><para><emphasis role="bold">Effects</emphasis>: Constructs an empty unordered_multiset and inserts elements from [b, e).</para><para><emphasis role="bold">Complexity</emphasis>: If N is std::distance(b, e): Average case is O(N) (with a good hash function and with buckets_len &gt;= N),worst case O(N2).</para><para><emphasis role="bold">Throws</emphasis>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws.</para><para><emphasis role="bold">Notes</emphasis>: buckets array must be disposed only after this is disposed. </para></description></constructor><destructor><description><para><emphasis role="bold">Effects</emphasis>: Detaches all elements from this. The objects in the unordered_multiset are not deleted (i.e. no destructors are called).</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the unordered_multiset, if it's a safe-mode or auto-unlink value. Otherwise constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor><method-group name="public static functions"><method name="s_local_iterator_to" cv=""><type>static local_iterator</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="s_local_iterator_to" cv=""><type>static const_local_iterator</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value must be an lvalue and shall be in a unordered_set of appropriate type. Otherwise the behavior is undefined.</para><para><emphasis role="bold">Effects</emphasis>: Returns: a valid const_local_iterator belonging to the unordered_set that points to the value</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Note</emphasis>: This static function is available only if the value traits is stateless. </para></description></method><method name="suggested_upper_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is bigger than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the higher possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="suggested_lower_bucket_count" cv=""><type>static <classname>size_type</classname></type><parameter name="n"><paramtype><classname>size_type</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns the nearest new bucket count optimized for the container that is smaller than n. This suggestion can be used to create bucket arrays with a size that will usually improve container's performance. If such value does not exist, the lower possible value is returned.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group></class><struct name="make_unordered_multiset"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define an <computeroutput>unordered_multiset</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct></namespace></namespace></header><header name="boost/intrusive/unordered_set_hook.hpp"><namespace name="boost"><namespace name="intrusive"><struct name="make_unordered_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>unordered_set_base_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="unordered_set_base_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Derive a class from unordered_set_base_hook in order to store objects in in an unordered_set/unordered_multi_set. unordered_set_base_hook holds the data necessary to maintain the unordered_set/unordered_multi_set and provides an appropriate value_traits class for unordered_set/unordered_multi_set.</para><para>The hook admits the following options: <computeroutput>tag&lt;&gt;</computeroutput>, <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput>, <computeroutput>store_hash&lt;&gt;</computeroutput> and <computeroutput>optimize_multikey&lt;&gt;</computeroutput>.</para><para><computeroutput>tag&lt;&gt;</computeroutput> defines a tag to identify the node. The same tag value can be used in different classes, but if a class is derived from more than one <computeroutput>list_base_hook</computeroutput>, then each <computeroutput>list_base_hook</computeroutput> needs its unique tag.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>store_hash&lt;&gt;</computeroutput> will tell the hook to store the hash of the value to speed up rehashings.</para><para><computeroutput>optimize_multikey&lt;&gt;</computeroutput> will tell the hook to store a link to form a group with other value with the same value to speed up searches and insertions in unordered_multisets with a great number of with equivalent keys. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>unordered_set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>unordered_set_base_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an unordered_set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class><struct name="make_unordered_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to define a <computeroutput>unordered_set_member_hook</computeroutput> that yields to the same type when the same options (either explicitly or implicitly) are used. </para></description><typedef name="type"><type>implementation_defined</type></typedef></struct><class name="unordered_set_member_hook"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Put a public data member unordered_set_member_hook in order to store objects of this class in an unordered_set/unordered_multi_set. unordered_set_member_hook holds the data necessary for maintaining the unordered_set/unordered_multi_set and provides an appropriate value_traits class for unordered_set/unordered_multi_set.</para><para>The hook admits the following options: <computeroutput>void_pointer&lt;&gt;</computeroutput>, <computeroutput>link_mode&lt;&gt;</computeroutput> and <computeroutput>store_hash&lt;&gt;</computeroutput>.</para><para><computeroutput>void_pointer&lt;&gt;</computeroutput> is the pointer type that will be used internally in the hook and the the container configured to use this hook.</para><para><computeroutput>link_mode&lt;&gt;</computeroutput> will specify the linking mode of the hook (<computeroutput>normal_link</computeroutput>, <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput>).</para><para><computeroutput>store_hash&lt;&gt;</computeroutput> will tell the hook to store the hash of the value to speed up rehashings. </para></description><method-group name="private member functions"><method name="swap_nodes" cv=""><type>void</type><parameter name="other"><paramtype><classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swapping two nodes swaps the position of the elements related to those nodes in one or two containers. That is, if the node this is part of the element e1, the node x is part of the element e2 and both elements are included in the containers s1 and s2, then after the swap-operation e1 is in s2 at the position of e2 and e2 is in s1 at the position of e1. If one element is not in a container, then after the swap-operation the other element is not in a container. Iterators to e1 and e2 related to those nodes are invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: Constant</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method><method name="is_linked" cv="const"><type>bool</type><description><para><emphasis role="bold">Precondition</emphasis>: link_mode must be <computeroutput>safe_link</computeroutput> or <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: true, if the node belongs to a container, false otherwise. This function can be used to test whether <computeroutput>unordered_set::iterator_to</computeroutput> will return a valid iterator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method><method name="unlink" cv=""><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the node if it's inserted in a container. This function is only allowed if link_mode is <computeroutput>auto_unlink</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method></method-group><constructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></constructor><constructor><parameter name=""><paramtype>const <classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>auto_unlink</computeroutput> or <computeroutput>safe_link</computeroutput> initializes the node to an unlinked state. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing a copy-constructor makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></constructor><copy-assignment><parameter name=""><paramtype>const <classname>unordered_set_member_hook</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Empty function. The argument is ignored.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Rationale</emphasis>: Providing an assignment operator makes classes using the hook STL-compliant without forcing the user to do some additional work. <computeroutput>swap</computeroutput> can be used to emulate move-semantics. </para></description></copy-assignment><destructor><description><para><emphasis role="bold">Effects</emphasis>: If link_mode is <computeroutput>normal_link</computeroutput>, the destructor does nothing (ie. no code is generated). If link_mode is <computeroutput>safe_link</computeroutput> and the object is stored in an unordered_set an assertion is raised. If link_mode is <computeroutput>auto_unlink</computeroutput> and <computeroutput>is_linked()</computeroutput> is true, the node is unlinked.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></destructor></class></namespace></namespace></header></library-reference>

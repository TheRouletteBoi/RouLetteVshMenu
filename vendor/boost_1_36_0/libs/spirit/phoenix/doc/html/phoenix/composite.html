<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Composite</title>
<link rel="stylesheet" href="../../../../../../doc/html/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.66.1">
<link rel="start" href="../index.html" title="Chapter 1. Phoenix 2.0">
<link rel="up" href="../index.html" title="Chapter 1. Phoenix 2.0">
<link rel="prev" href="primitives.html" title="Primitives">
<link rel="next" href="container.html" title="Container">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="primitives.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="container.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="phoenix.composite"></a><a href="composite.html" title="Composite">Composite</a></h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="composite.html#phoenix.composite.function">Function</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.operator">Operator</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement">Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.object">Object</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.scope">Scope</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.bind">Bind</a></span></dt>
</dl></div>
<p>
      Actors may be combined in a multitude of ways to form composites. Composites
      are actors that are composed of zero or more actors. Composition is hierarchical.
      An element of the composite can be a primitive or again another composite.
      The flexibility to arbitrarily compose hierarchical structures allows us to
      form intricate constructions that model complex functions, statements and expressions.
    </p>
<p>
      A composite is-a tuple of 0..N actors. N is the predefined maximum actors a
      composite can take.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
        You can set <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt>,
        the predefined maximum actors a composite can take. By default, <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt> is set to <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt> (See <a href="actors.html" title="Actors">Actors</a>).
      </p></td></tr>
</table></div>
<p>
      As mentioned, each of the actors A0..AN can, in turn, be another composite,
      since a composite is itself an actor. This makes the composite a recursive
      structure. The actual evaluation is handled by a composite specific eval policy.
    </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.function"></a><a href="composite.html#phoenix.composite.function" title="Function">Function</a></h3></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">function</span><span class="special">/</span><span class="identifier">function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        The <tt class="computeroutput"><span class="identifier">function</span></tt> class template
        provides a mechanism for implementing lazily evaluated functions. Syntactically,
        a lazy function looks like an ordinary C/C++ function. The function call
        looks familiar and feels the same as ordinary C++ functions. However, unlike
        ordinary functions, the actual function execution is deferred.
      </p>
<p>
        Unlike ordinary function pointers or functor objects that need to be explicitly
        bound through the bind function (see <a href="composite.html#phoenix.composite.bind" title="Bind">Bind</a>),
        the argument types of these functions are automatically lazily bound.
      </p>
<p>
        In order to create a lazy function, we need to implement a model of the FunctionEval
        concept. For a function that takes <tt class="computeroutput"><span class="identifier">N</span></tt>
        arguments, a model of FunctionEval must provide:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
          An <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>
          that implements that takes <tt class="computeroutput"><span class="identifier">N</span></tt>
          arguments, and implements the function logic.
        </li>
<li>
          A nested metafunction <tt class="computeroutput"><span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">A1</span><span class="special">,</span> <span class="special">...</span> <span class="identifier">AN</span><span class="special">&gt;</span></tt> that takes the types of the <tt class="computeroutput"><span class="identifier">N</span></tt> arguments to the function and returns
          the result type of the function. (There is a special case for function
          objects that accept no arguments. Such nullary functors are only required
          to define a typedef <tt class="computeroutput"><span class="identifier">result_type</span></tt>
          that reflects the return type of its <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>).
        </li>
</ul></div>
<p>
        For example, the following type implements the FunctionEval concept, in order
        to provide a lazy factorial function:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">factorial_impl</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">Arg</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Arg</span><span class="special">&gt;</span>
    <span class="identifier">Arg</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">Arg</span> <span class="identifier">n</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">(</span><span class="identifier">n</span> <span class="special">&lt;=</span> <span class="number">0</span><span class="special">)</span> <span class="special">?</span> <span class="number">1</span> <span class="special">:</span> <span class="identifier">n</span> <span class="special">*</span> <span class="keyword">this</span><span class="special">-&gt;</span><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">n</span><span class="special">-</span><span class="number">1</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        (See <a href="../../../example/users_manual/factorial.cpp" target="_top">factorial.cpp</a>)
      </p>
<p>
        Having implemented the <tt class="computeroutput"><span class="identifier">factorial_impl</span></tt>
        type, we can declare and instantiate a lazy <tt class="computeroutput"><span class="identifier">factorial</span></tt>
        function this way:
      </p>
<pre class="programlisting">
<span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">factorial_impl</span><span class="special">&gt;</span> <span class="identifier">factorial</span><span class="special">;</span>
</pre>
<p>
        Invoking a lazy function such as <tt class="computeroutput"><span class="identifier">factorial</span></tt>
        does not immediately execute the function object <tt class="computeroutput"><span class="identifier">factorial_impl</span></tt>.
        Instead, an <a href="actors.html" title="Actors">actor</a> object is created
        and returned to the caller. Example:
      </p>
<pre class="programlisting">
<span class="identifier">factorial</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span>
</pre>
<p>
        does nothing more than return an actor. A second function call will invoke
        the actual factorial function. Example:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">4</span><span class="special">;</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">factorial</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)(</span><span class="identifier">i</span><span class="special">);</span>
</pre>
<p>
        will print out "24".
      </p>
<p>
        Take note that in certain cases (e.g. for function objects with state), an
        instance of the model of FunctionEval may be passed on to the constructor.
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">factorial_impl</span><span class="special">&gt;</span> <span class="identifier">factorial</span><span class="special">(</span><span class="identifier">ftor</span><span class="special">);</span>
</pre>
<p>
        where ftor is an instance of factorial_impl (this is not necessary in this
        case as <tt class="computeroutput"><span class="identifier">factorial_impl</span></tt> does
        not require any state).
      </p>
<div class="sidebar"><p>
        <span class="inlinemediaobject"><img src="../images/alert.png" alt="alert"></span> Take care though when using function objects with state
        because they are often copied repeatedly, and state may change in one of
        the copies, rather than the original.
      </p></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.operator"></a><a href="composite.html#phoenix.composite.operator" title="Operator">Operator</a></h3></div></div></div>
<p>
        This facility provides a mechanism for lazily evaluating operators. Syntactically,
        a lazy operator looks and feels like an ordinary C/C++ infix, prefix or postfix
        operator. The operator application looks the same. However, unlike ordinary
        operators, the actual operator execution is deferred. Samples:
      </p>
<pre class="programlisting">
<span class="identifier">arg1</span> <span class="special">+</span> <span class="identifier">arg2</span>
<span class="number">1</span> <span class="special">+</span> <span class="identifier">arg1</span> <span class="special">*</span> <span class="identifier">arg2</span>
<span class="number">1</span> <span class="special">/</span> <span class="special">-</span><span class="identifier">arg1</span>
<span class="identifier">arg1</span> <span class="special">&lt;</span> <span class="number">150</span>
</pre>
<p>
        We have seen the lazy operators in action (see <a href="starter_kit.html" title="Starter Kit">Quick
        Start</a>). Let's go back and examine them a little bit further:
      </p>
<pre class="programlisting">
<span class="identifier">find_if</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">arg1</span> <span class="special">%</span> <span class="number">2</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span>
</pre>
<p>
        Through operator overloading, the expression <tt class="computeroutput"><span class="identifier">arg1</span>
        <span class="special">%</span> <span class="number">2</span> <span class="special">==</span> <span class="number">1</span></tt> actually
        generates an actor. This actor object is passed on to STL's <tt class="computeroutput"><span class="identifier">find_if</span></tt> function. From the viewpoint of
        STL, the composite is simply a function object expecting a single argument
        of the containers value_type. For each element in <tt class="computeroutput"><span class="identifier">c</span></tt>,
        the element is passed on as an argument <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        to the actor (function object). The actor checks if this is an odd value
        based on the expression <tt class="computeroutput"><span class="identifier">arg1</span> <span class="special">%</span> <span class="number">2</span> <span class="special">==</span>
        <span class="number">1</span></tt> where arg1 is replaced by the container's
        element.
      </p>
<p>
        Like lazy functions (see <a href="composite.html#phoenix.composite.function" title="Function">function</a>),
        lazy operators are not immediately executed when invoked. Instead, an actor
        (see <a href="actors.html" title="Actors">actors</a>) object is created and
        returned to the caller. Example:
      </p>
<pre class="programlisting">
<span class="special">(</span><span class="identifier">arg1</span> <span class="special">+</span> <span class="identifier">arg2</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">arg3</span>
</pre>
<p>
        does nothing more than return an actor. A second function call will evaluate
        the actual operators. Example:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">4</span><span class="special">,</span> <span class="identifier">j</span> <span class="special">=</span> <span class="number">5</span><span class="special">,</span> <span class="identifier">k</span> <span class="special">=</span> <span class="number">6</span><span class="special">;</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">((</span><span class="identifier">arg1</span> <span class="special">+</span> <span class="identifier">arg2</span><span class="special">)</span> <span class="special">*</span> <span class="identifier">arg3</span><span class="special">)(</span><span class="identifier">i</span><span class="special">,</span> <span class="identifier">j</span><span class="special">,</span> <span class="identifier">k</span><span class="special">);</span>
</pre>
<p>
        will print out "54".
      </p>
<p>
        Operator expressions are lazily evaluated following four simple rules:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          A binary operator, except <tt class="computeroutput"><span class="special">-&gt;*</span></tt>
          will be lazily evaluated when <span class="emphasis"><em>at least</em></span> one of its
          operands is an actor object (see <a href="actors.html" title="Actors">actors</a>).
        </li>
<li>
          Unary operators are lazily evaluted if their argument is an actor object.
        </li>
<li>
          Operator <tt class="computeroutput"><span class="special">-&gt;*</span></tt> is lazily
          evaluted if the left hand argument is an actor object.
        </li>
<li>
          The result of a lazy operator is an actor object that can in turn allow
          the applications of rules 1 and 2.
        </li>
</ol></div>
<p>
        For example, to check the following expression is lazily evaluated:
      </p>
<pre class="programlisting">
<span class="special">-(</span><span class="identifier">arg1</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span> <span class="number">6</span><span class="special">)</span>
</pre>
<div class="orderedlist"><ol type="1">
<li>
          Following rule 1, <tt class="computeroutput"><span class="identifier">arg1</span> <span class="special">+</span> <span class="number">3</span></tt> is lazily
          evaluated since <tt class="computeroutput"><span class="identifier">arg1</span></tt> is
          an actor (see <a href="primitives.html" title="Primitives">primitives</a>).
        </li>
<li>
          The result of this <tt class="computeroutput"><span class="identifier">arg1</span> <span class="special">+</span> <span class="number">3</span></tt> expression
          is an actor object, following rule 4.
        </li>
<li>
          Continuing, <tt class="computeroutput"><span class="identifier">arg1</span> <span class="special">+</span>
          <span class="number">3</span> <span class="special">+</span> <span class="number">6</span></tt> is again lazily evaluated. Rule 2.
        </li>
<li>
          By rule 4 again, the result of <tt class="computeroutput"><span class="identifier">arg1</span>
          <span class="special">+</span> <span class="number">3</span> <span class="special">+</span> <span class="number">6</span></tt> is an
          actor object.
        </li>
<li>
          As <tt class="computeroutput"><span class="identifier">arg1</span> <span class="special">+</span>
          <span class="number">3</span> <span class="special">+</span> <span class="number">6</span></tt> is an actor, <tt class="computeroutput"><span class="special">-(</span><span class="identifier">arg1</span> <span class="special">+</span> <span class="number">3</span> <span class="special">+</span> <span class="number">6</span><span class="special">)</span></tt> is lazily evaluated. Rule 2.
        </li>
</ol></div>
<p>
        Lazy-operator application is highly contagious. In most cases, a single
        <tt class="computeroutput"><span class="identifier">argN</span></tt> actor infects all its
        immediate neighbors within a group (first level or parenthesized expression).
      </p>
<p>
        Note that at least one operand of any operator must be a valid actor for
        lazy evaluation to take effect. To force lazy evaluation of an ordinary expression,
        we can use <tt class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></tt>, <tt class="computeroutput"><span class="identifier">val</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></tt> or <tt class="computeroutput"><span class="identifier">cref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></tt>
        to transform an operand into a valid actor object (see <a href="primitives.html" title="Primitives">primitives</a>.
        For example:
      </p>
<pre class="programlisting">
<span class="number">1</span> <span class="special">&lt;&lt;</span> <span class="number">3</span><span class="special">;</span>      <span class="comment">// Immediately evaluated
</span><span class="identifier">val</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="number">3</span><span class="special">;</span> <span class="comment">// Lazily evaluated
</span></pre>
<a name="phoenix.composite.operator.supported_operators"></a><h2>
<a name="id469226"></a>
        <a href="composite.html#phoenix.composite.operator.supported_operators">Supported
        operators</a>
      </h2>
<a name="phoenix.composite.operator.unary_operators"></a><h3>
<a name="id469251"></a>
        <a href="composite.html#phoenix.composite.operator.unary_operators">Unary operators</a>
      </h3>
<pre class="programlisting">
<span class="identifier">prefix</span><span class="special">:</span>   <span class="special">~,</span> <span class="special">!,</span> <span class="special">-,</span> <span class="special">+,</span> <span class="special">++,</span> <span class="special">--,</span> <span class="special">&amp;</span> <span class="special">(</span><span class="identifier">reference</span><span class="special">),</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">dereference</span><span class="special">)</span>
<span class="identifier">postfix</span><span class="special">:</span>  <span class="special">++,</span> <span class="special">--</span>
</pre>
<a name="phoenix.composite.operator.binary_operators"></a><h3>
<a name="id469399"></a>
        <a href="composite.html#phoenix.composite.operator.binary_operators">Binary operators</a>
      </h3>
<pre class="programlisting">
<span class="special">=,</span> <span class="special">[],</span> <span class="special">+=,</span> <span class="special">-=,</span> <span class="special">*=,</span> <span class="special">/=,</span> <span class="special">%=,</span> <span class="special">&amp;=,</span> <span class="special">|=,</span> <span class="special">^=,</span> <span class="special">&lt;&lt;=,</span> <span class="special">&gt;&gt;=</span>
<span class="special">+,</span> <span class="special">-,</span> <span class="special">*,</span> <span class="special">/,</span> <span class="special">%,</span> <span class="special">&amp;,</span> <span class="special">|,</span> <span class="special">^,</span> <span class="special">&lt;&lt;,</span> <span class="special">&gt;&gt;</span>
<span class="special">==,</span> <span class="special">!=,</span> <span class="special">&lt;,</span> <span class="special">&gt;,</span> <span class="special">&lt;=,</span> <span class="special">&gt;=</span>
<span class="special">&amp;&amp;,</span> <span class="special">||,</span> <span class="special">-&gt;*</span>
</pre>
<a name="phoenix.composite.operator.ternary_operator"></a><h3>
<a name="id469622"></a>
        <a href="composite.html#phoenix.composite.operator.ternary_operator">Ternary operator</a>
      </h3>
<pre class="programlisting">
<span class="identifier">if_else</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span>
</pre>
<p>
        The ternary operator deserves special mention. Since C++ does not allow us
        to overload the conditional expression: <tt class="computeroutput"><span class="identifier">c</span>
        <span class="special">?</span> <span class="identifier">a</span> <span class="special">:</span> <span class="identifier">b</span></tt>, the
        if_else pseudo function is provided for this purpose. The behavior is identical,
        albeit in a lazy manner.
      </p>
<a name="phoenix.composite.operator.member_pointer_operator"></a><h3>
<a name="id469742"></a>
        <a href="composite.html#phoenix.composite.operator.member_pointer_operator">Member
        pointer operator</a>
      </h3>
<pre class="programlisting">
<span class="identifier">a</span><span class="special">-&gt;*</span><span class="identifier">member_object_pointer</span>
<span class="identifier">a</span><span class="special">-&gt;*</span><span class="identifier">member_function_pointer</span>
</pre>
<p>
        The left hand side of the member pointer operator must be an actor returning
        a pointer type. The right hand side of the member pointer operator may be
        either a pointer to member object or pointer to member function.
      </p>
<p>
        If the right hand side is a member object pointer, the result is an actor
        which, when evaluated, returns a reference to that member. For example:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">A</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">member</span><span class="special">;</span>
<span class="special">};</span>

<span class="identifier">A</span><span class="special">*</span> <span class="identifier">a</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">A</span><span class="special">;</span>
<span class="special">...</span>

<span class="special">(</span><span class="identifier">arg1</span><span class="special">-&gt;*&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">member</span><span class="special">)(</span><span class="identifier">a</span><span class="special">);</span> <span class="comment">// returns member a-&gt;member
</span></pre>
<p>
        If the right hand side is a member function pointer, the result is an actor
        which, when invoked, calls the specified member function. For example:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">A</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">func</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>
<span class="special">};</span>

<span class="identifier">A</span><span class="special">*</span> <span class="identifier">a</span> <span class="special">=</span> <span class="keyword">new</span> <span class="identifier">A</span><span class="special">;</span>
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>

<span class="special">(</span><span class="identifier">arg1</span><span class="special">-&gt;*&amp;</span><span class="identifier">A</span><span class="special">::</span><span class="identifier">func</span><span class="special">)(</span><span class="identifier">arg2</span><span class="special">)(</span><span class="identifier">a</span><span class="special">,</span> <span class="identifier">i</span><span class="special">);</span> <span class="comment">// returns a-&gt;func(i)
</span></pre>
<div class="table">
<a name="id470169"></a><p class="title"><b>Table 1.4. Include Files</b></p>
<table class="table" summary="Include Files">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
            <p>
              Operators
            </p>
            </th>
<th>
            <p>
              File
            </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">-</span></tt>, <tt class="computeroutput"><span class="special">+</span></tt>,
              <tt class="computeroutput"><span class="special">++</span></tt>, <tt class="computeroutput"><span class="special">--</span></tt>,
              <tt class="computeroutput"><span class="special">+=</span></tt>, <tt class="computeroutput"><span class="special">-=</span></tt>,
              <tt class="computeroutput"><span class="special">*=</span></tt>, <tt class="computeroutput"><span class="special">/=</span></tt>,
              <tt class="computeroutput"><span class="special">%=</span></tt>, <tt class="computeroutput"><span class="special">*</span></tt>,
              <tt class="computeroutput"><span class="special">/</span></tt>, <tt class="computeroutput"><span class="special">%</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">arithmetic</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">&amp;=</span></tt>, <tt class="computeroutput"><span class="special">|=</span></tt>, <tt class="computeroutput"><span class="special">^=</span></tt>,
              <tt class="computeroutput"><span class="special">&lt;&lt;=</span></tt>, <tt class="computeroutput"><span class="special">&gt;&gt;=</span></tt>, <tt class="computeroutput"><span class="special">&amp;</span></tt>,
              <tt class="computeroutput"><span class="special">|</span></tt>, <tt class="computeroutput"><span class="special">^</span></tt>,
              <tt class="computeroutput"><span class="special">&lt;&lt;</span></tt>, <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">bitwise</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">==</span></tt>, <tt class="computeroutput"><span class="special">!=</span></tt>,
              <tt class="computeroutput"><span class="special">&lt;</span></tt>, <tt class="computeroutput"><span class="special">&lt;=</span></tt>,
              <tt class="computeroutput"><span class="special">&gt;</span></tt>, <tt class="computeroutput"><span class="special">&gt;=</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">comparison</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">&lt;&lt;</span></tt>, <tt class="computeroutput"><span class="special">&gt;&gt;</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">io</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">!</span></tt>, &amp;&amp;, <tt class="computeroutput"><span class="special">||</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">logical</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">&amp;</span><span class="identifier">x</span></tt>,
              <tt class="computeroutput"><span class="special">*</span><span class="identifier">p</span></tt>,
              <tt class="computeroutput"><span class="special">=</span></tt>, <tt class="computeroutput"><span class="special">[]</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">self</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="identifier">if_else</span><span class="special">(</span><span class="identifier">c</span><span class="special">,</span> <span class="identifier">a</span><span class="special">,</span> <span class="identifier">b</span><span class="special">)</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">if_else</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
<tr>
<td>
            <p>
              <tt class="computeroutput"><span class="special">-&gt;*</span></tt>
            </p>
            </td>
<td>
            <p>
              <tt class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="keyword">operator</span><span class="special">/</span><span class="identifier">member</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></tt>
            </p>
            </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.statement"></a><a href="composite.html#phoenix.composite.statement" title="Statement">Statement</a></h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.block_statement">Block
        Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.if__statement">if_ Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.if_else__statement">if<span class="underline">else</span> statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.switch__statement">switch_
        statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.while__statement">while_
        Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.do_while__statement">do<span class="underline">while</span> Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.for__statement">for_ Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.try__catch__statement">try_
        catch_ Statement</a></span></dt>
<dt><span class="section"><a href="composite.html#phoenix.composite.statement.throw_">throw_</a></span></dt>
</dl></div>
<p>
        <span class="bold"><b><span class="emphasis"><em>Lazy statements...</em></span></b></span>
      </p>
<p>
        The primitives and composite building blocks presented so far are sufficiently
        powerful to construct quite elaborate structures. We have presented lazy-
        functions and lazy-operators. How about lazy-statements? First, an appetizer:
      </p>
<p>
        Print all odd-numbered contents of an STL container using <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span></tt>
        (<a href="../../../example/users_manual/all_odds.cpp" target="_top">all_odds.cpp</a>):
      </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="identifier">if_</span><span class="special">(</span><span class="identifier">arg1</span> <span class="special">%</span> <span class="number">2</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span>
    <span class="special">[</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span>
    <span class="special">]</span>
<span class="special">);</span>
</pre>
<p>
        Huh? Is that valid C++? Read on...
      </p>
<p>
        Yes, it is valid C++. The sample code above is as close as you can get to
        the syntax of C++. This stylized C++ syntax differs from actual C++ code.
        First, the <tt class="computeroutput"><span class="keyword">if</span></tt> has a trailing
        underscore. Second, the block uses square brackets instead of the familiar
        curly braces {}.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top">
<p>
          <span class="bold"><b>C++ in C++?</b></span>
        </p>
<p>
          In as much as <a href="http://spirit.sourceforge.net" target="_top">Spirit</a>
          attempts to mimic EBNF in C++, Phoenix attempts to mimic C++ in C++!!!
        </p>
</td></tr>
</table></div>
<p>
        Here are more examples with annotations. The code almost speaks for itself.
      </p>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.block_statement"></a><a href="composite.html#phoenix.composite.statement.block_statement" title="Block
        Statement">Block
        Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="identifier">sequence</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          Syntax:
        </p>
<pre class="programlisting">
<span class="identifier">statement</span><span class="special">,</span>
<span class="identifier">statement</span><span class="special">,</span>
<span class="special">....</span>
<span class="identifier">statement</span>
</pre>
<p>
          Basically, these are comma separated statements. Take note that unlike
          the C/C++ semicolon, the comma is a separator put <span class="bold"><b>in-between</b></span>
          statements. This is like Pascal's semicolon separator, rather than C/C++'s
          semicolon terminator. For example:
        </p>
<pre class="programlisting">
<span class="identifier">statement</span><span class="special">,</span>
<span class="identifier">statement</span><span class="special">,</span>
<span class="identifier">statement</span><span class="special">,</span> <span class="comment">// ERROR!
</span></pre>
<p>
          Is an error. The last statement should not have a comma. Block statements
          can be grouped using the parentheses. Again, the last statement in a group
          should not have a trailing comma.
        </p>
<pre class="programlisting">
<span class="identifier">statement</span><span class="special">,</span>
<span class="identifier">statement</span><span class="special">,</span>
<span class="special">(</span>
    <span class="identifier">statement</span><span class="special">,</span>
    <span class="identifier">statement</span>
<span class="special">),</span>
<span class="identifier">statement</span>
</pre>
<p>
          Outside the square brackets, block statements should be grouped. For example:
        </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="special">(</span>
        <span class="identifier">do_this</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">),</span>
        <span class="identifier">do_that</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span>
    <span class="special">)</span>
<span class="special">);</span>
</pre>
<p>
          Wrapping a comma operator chain around a parentheses pair blocks the interpretation
          as an argument separator. The reason for the exception for the square bracket
          operator is that the operator always takes exactly one argument, so it
          "transforms" any attempt at multiple arguments with a comma operator
          chain (and spits out an error for zero arguments).
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.if__statement"></a><a href="composite.html#phoenix.composite.statement.if__statement" title="if_ Statement">if_ Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">if</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          We have seen the <tt class="computeroutput"><span class="identifier">if_</span></tt> statement.
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">if_</span><span class="special">(</span><span class="identifier">conditional_expression</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.if_else__statement"></a><a href="composite.html#phoenix.composite.statement.if_else__statement" title="ifelse statement">if<span class="underline">else</span> statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">if</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is
        </p>
<pre class="programlisting">
<span class="identifier">if_</span><span class="special">(</span><span class="identifier">conditional_expression</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">else_</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
</pre>
<p>
          Take note that <tt class="computeroutput"><span class="keyword">else</span></tt> has a
          leading dot and a trailing underscore: <tt class="computeroutput"><span class="special">.</span><span class="identifier">else_</span></tt>
        </p>
<p>
          Example: This code prints out all the elements and appends <tt class="computeroutput"><span class="string">" &gt; 5"</span></tt>, <tt class="computeroutput"><span class="string">"
          == 5"</span></tt> or <tt class="computeroutput"><span class="string">" &lt; 5"</span></tt>
          depending on the element's actual value:
        </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="identifier">if_</span><span class="special">(</span><span class="identifier">arg1</span> <span class="special">&gt;</span> <span class="number">5</span><span class="special">)</span>
    <span class="special">[</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">" &gt; 5\n"</span>
    <span class="special">]</span>
    <span class="special">.</span><span class="identifier">else_</span>
    <span class="special">[</span>
        <span class="identifier">if_</span><span class="special">(</span><span class="identifier">arg1</span> <span class="special">==</span> <span class="number">5</span><span class="special">)</span>
        <span class="special">[</span>
            <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">" == 5\n"</span>
        <span class="special">]</span>
        <span class="special">.</span><span class="identifier">else_</span>
        <span class="special">[</span>
            <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">" &lt; 5\n"</span>
        <span class="special">]</span>
    <span class="special">]</span>
<span class="special">);</span>
</pre>
<p>
          Notice how the <tt class="computeroutput"><span class="identifier">if_else_</span></tt>
          statement is nested.
        </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.switch__statement"></a><a href="composite.html#phoenix.composite.statement.switch__statement" title="switch_
        statement">switch_
        statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">switch</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">switch_</span><span class="special">(</span><span class="identifier">integral_expression</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">case_</span><span class="special">&lt;</span><span class="identifier">integral_value</span><span class="special">&gt;(</span><span class="identifier">sequenced_statements</span><span class="special">),</span>
    <span class="special">...</span>
    <span class="identifier">default_</span><span class="special">&lt;</span><span class="identifier">integral_value</span><span class="special">&gt;(</span><span class="identifier">sequenced_statements</span><span class="special">)</span>
<span class="special">]</span>
</pre>
<p>
          A comma separated list of cases, and an optional default can be provided.
          Note unlike a normal switch statement, cases do not fall through.
        </p>
<p>
          Example: This code prints out <tt class="computeroutput"><span class="string">"one"</span></tt>,
          <tt class="computeroutput"><span class="string">"two"</span></tt> or <tt class="computeroutput"><span class="string">"other value"</span></tt> depending on the
          element's actual value:
        </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="identifier">switch_</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span>
    <span class="special">[</span>
        <span class="identifier">case_</span><span class="special">&lt;</span><span class="number">1</span><span class="special">&gt;(</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"one"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">),</span>
        <span class="identifier">case_</span><span class="special">&lt;</span><span class="number">2</span><span class="special">&gt;(</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"two"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">),</span>
        <span class="identifier">default_</span><span class="special">(</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"other value"</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">)</span>
    <span class="special">]</span>
<span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.while__statement"></a><a href="composite.html#phoenix.composite.statement.while__statement" title="while_
        Statement">while_
        Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">while</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">while_</span><span class="special">(</span><span class="identifier">conditional_expression</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
</pre>
<p>
          Example: This code decrements each element until it reaches zero and prints
          out the number at each step. A newline terminates the printout of each
          value.
        </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="special">(</span>
        <span class="identifier">while_</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">--)</span>
        <span class="special">[</span>
            <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span>
        <span class="special">],</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"\n"</span><span class="special">)</span>
    <span class="special">)</span>
<span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.do_while__statement"></a><a href="composite.html#phoenix.composite.statement.do_while__statement" title="dowhile Statement">do<span class="underline">while</span> Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="identifier">do_while</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">do_</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">while_</span><span class="special">(</span><span class="identifier">conditional_expression</span><span class="special">)</span>
</pre>
<p>
          Again, take note that <tt class="computeroutput"><span class="keyword">while</span></tt>
          has a leading dot and a trailing underscore: <tt class="computeroutput"><span class="special">.</span><span class="identifier">while_</span></tt>
        </p>
<p>
          Example: This code is almost the same as the previous example above with
          a slight twist in logic.
        </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="special">(</span>
        <span class="identifier">do_</span>
        <span class="special">[</span>
            <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span>
        <span class="special">]</span>
        <span class="special">.</span><span class="identifier">while_</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">--),</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"\n"</span><span class="special">)</span>
    <span class="special">)</span>
<span class="special">);</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.for__statement"></a><a href="composite.html#phoenix.composite.statement.for__statement" title="for_ Statement">for_ Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">for</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">for_</span><span class="special">(</span><span class="identifier">init_statement</span><span class="special">,</span> <span class="identifier">conditional_expression</span><span class="special">,</span> <span class="identifier">step_statement</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
</pre>
<p>
          It is again very similar to the C++ for statement. Take note that the init_statement,
          conditional_expression and step<span class="underline">statement are
          separated by the comma instead of the semi-colon and each must be present
          (i.e. `for</span>(,,)` is invalid). This is a case where the <a href="primitives.html#phoenix.primitives.nothing" title="Nothing">nothing</a> actor can be useful.
        </p>
<p>
          Example: This code prints each element N times where N is the element's
          value. A newline terminates the printout of each value.
        </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">iii</span><span class="special">;</span>
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span>
    <span class="special">(</span>
        <span class="identifier">for_</span><span class="special">(</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">iii</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="identifier">ref</span><span class="special">(</span><span class="identifier">iii</span><span class="special">)</span> <span class="special">&lt;</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="special">++</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">iii</span><span class="special">))</span>
        <span class="special">[</span>
            <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span> <span class="special">&lt;&lt;</span> <span class="string">", "</span>
        <span class="special">],</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"\n"</span><span class="special">)</span>
    <span class="special">)</span>
<span class="special">);</span>
</pre>
<p>
          As before, all these are lazily evaluated. The result of such statements
          are in fact composites that are passed on to STL's for_each function. In
          the viewpoint of <tt class="computeroutput"><span class="identifier">for_each</span></tt>,
          what was passed is just a functor, no more, no less.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
            Unlike lazy functions and lazy operators, lazy statements always return
            void.
          </p></td></tr>
</table></div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.try__catch__statement"></a><a href="composite.html#phoenix.composite.statement.try__catch__statement" title="try_
        catch_ Statement">try_
        catch_ Statement</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="identifier">try_catch</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          The syntax is:
        </p>
<pre class="programlisting">
<span class="identifier">try_</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_</span><span class="special">&lt;</span><span class="identifier">exception_type</span><span class="special">&gt;()</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statements</span>
<span class="special">]</span>
<span class="special">...</span>
<span class="special">.</span><span class="identifier">catch_all</span>
<span class="special">[</span>
    <span class="identifier">sequenced_statement</span>
<span class="special">]</span>
</pre>
<p>
          Note the usual underscore after try and catch, and the extra parentheses
          required after the catch.
        </p>
<p>
          Example: The following code calls the (lazy) function <tt class="computeroutput"><span class="identifier">f</span></tt>
          for each element, and prints messages about different exception types it
          catches.
        </p>
<pre class="programlisting">
<span class="identifier">try_</span>
<span class="special">[</span>
    <span class="identifier">f</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_</span><span class="special">&lt;</span><span class="identifier">runtime_error</span><span class="special">&gt;()</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught runtime error or derived\n"</span><span class="special">)</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_</span><span class="special">&lt;</span><span class="identifier">exception</span><span class="special">&gt;()</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught exception or derived\n"</span><span class="special">)</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_all</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught some other type of exception\n"</span><span class="special">)</span>
<span class="special">]</span>
</pre>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="phoenix.composite.statement.throw_"></a><a href="composite.html#phoenix.composite.statement.throw_" title="throw_">throw_</a></h4></div></div></div>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">statement</span><span class="special">/</span><span class="keyword">throw</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
          As a natural companion to the try/catch support, the statement module provides
          lazy throwing and rethrowing of exceptions.
        </p>
<p>
          The syntax to throw an exception is:
        </p>
<pre class="programlisting">
<span class="identifier">throw_</span><span class="special">(</span><span class="identifier">exception_expression</span><span class="special">)</span>
</pre>
<p>
          The syntax to rethrow an exception is:
        </p>
<pre class="programlisting">
<span class="identifier">throw_</span><span class="special">()</span>
</pre>
<p>
          Example: This code extends the try/catch example, rethrowing exceptions
          derived from runtime_error or exception, and translating other exception
          types to runtime_errors.
        </p>
<pre class="programlisting">
<span class="identifier">try_</span>
<span class="special">[</span>
    <span class="identifier">f</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">)</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_</span><span class="special">&lt;</span><span class="identifier">runtime_error</span><span class="special">&gt;()</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught runtime error or derived\n"</span><span class="special">),</span>
    <span class="identifier">throw_</span><span class="special">()</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_</span><span class="special">&lt;</span><span class="identifier">exception</span><span class="special">&gt;()</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught exception or derived\n"</span><span class="special">),</span>
    <span class="identifier">throw_</span><span class="special">()</span>
<span class="special">]</span>
<span class="special">.</span><span class="identifier">catch_all</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">val</span><span class="special">(</span><span class="string">"caught some other type of exception\n"</span><span class="special">),</span>
    <span class="identifier">throw_</span><span class="special">(</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"translated exception"</span><span class="special">))</span>
<span class="special">]</span>
</pre>
</div>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.object"></a><a href="composite.html#phoenix.composite.object" title="Object">Object</a></h3></div></div></div>
<p>
        The Object module deals with object construction, destruction and conversion.
        The module provides <span class="emphasis"><em>"lazy"</em></span> versions of C++'s
        object constructor, <tt class="computeroutput"><span class="keyword">new</span></tt>, <tt class="computeroutput"><span class="keyword">delete</span></tt>, <tt class="computeroutput"><span class="keyword">static_cast</span></tt>,
        <tt class="computeroutput"><span class="keyword">dynamic_cast</span></tt>, <tt class="computeroutput"><span class="keyword">const_cast</span></tt> and <tt class="computeroutput"><span class="keyword">reinterpret_cast</span></tt>.
      </p>
<a name="phoenix.composite.object.construction"></a><h2>
<a name="id475951"></a>
        <a href="composite.html#phoenix.composite.object.construction">Construction</a>
      </h2>
<p>
        <span class="bold"><b><span class="emphasis"><em>Lazy constructors...</em></span></b></span>
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="identifier">construct</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Lazily construct an object from an arbitrary set of arguments:
      </p>
<pre class="programlisting">
<span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">ctor_arg1</span><span class="special">,</span> <span class="identifier">ctor_arg2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">ctor_argN</span><span class="special">);</span>
</pre>
<p>
        where the given parameters are the parameters to the contructor of the object
        of type T (This implies, that type T is expected to have a constructor with
        a corresponding set of parameter types.).
      </p>
<p>
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">construct</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">)</span>
</pre>
<p>
        Constructs a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> from <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        and <tt class="computeroutput"><span class="identifier">arg2</span></tt>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          The maximum number of actual parameters is limited by the preprocessor
          constant PHOENIX_COMPOSITE_LIMIT. Note though, that this limit should not
          be greater than PHOENIX_LIMIT. By default, <tt class="computeroutput"><span class="identifier">PHOENIX_COMPOSITE_LIMIT</span></tt>
          is set to <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>
          (See <a href="actors.html" title="Actors">Actors</a>).
        </p></td></tr>
</table></div>
<a name="phoenix.composite.object.new"></a><h2>
<a name="id476315"></a>
        <a href="composite.html#phoenix.composite.object.new">New</a>
      </h2>
<p>
        <span class="bold"><b><span class="emphasis"><em>Lazy new...</em></span></b></span>
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">new</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Lazily construct an object, on the heap, from an arbitrary set of arguments:
      </p>
<pre class="programlisting">
<span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">ctor_arg1</span><span class="special">,</span> <span class="identifier">ctor_arg2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">ctor_argN</span><span class="special">);</span>
</pre>
<p>
        where the given parameters are the parameters to the contructor of the object
        of type T (This implies, that type T is expected to have a constructor with
        a corresponding set of parameter types.).
      </p>
<p>
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">new_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">)</span> <span class="comment">// note the spelling of new_ (with trailing underscore)
</span></pre>
<p>
        Creates a <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></tt> from <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        and <tt class="computeroutput"><span class="identifier">arg2</span></tt> on the heap.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          Again, the maximum number of actual parameters is limited by the preprocessor
          constant PHOENIX_COMPOSITE_LIMIT. See the note above.
        </p></td></tr>
</table></div>
<a name="phoenix.composite.object.delete"></a><h2>
<a name="id476651"></a>
        <a href="composite.html#phoenix.composite.object.delete">Delete</a>
      </h2>
<p>
        <span class="bold"><b><span class="emphasis"><em>Lazy delete...</em></span></b></span>
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">delete</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Lazily delete an object, from the heap:
      </p>
<pre class="programlisting">
<span class="identifier">delete_</span><span class="special">(</span><span class="identifier">arg</span><span class="special">);</span>
</pre>
<p>
        where arg is assumed to be a pointer to an object.
      </p>
<p>
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">delete_</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">arg1</span><span class="special">)</span> <span class="comment">// note the spelling of delete_ (with trailing underscore)
</span></pre>
<a name="phoenix.composite.object.casts"></a><h2>
<a name="id476871"></a>
        <a href="composite.html#phoenix.composite.object.casts">Casts</a>
      </h2>
<p>
        <span class="bold"><b><span class="emphasis"><em>Lazy casts...</em></span></b></span>
      </p>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">static_cast</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">dynamic_cast</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">const_cast</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">object</span><span class="special">/</span><span class="keyword">reinterpret_cast</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        The set of lazy C++ cast template functions provide a way of lazily casting
        an object of a certain type to another type. The syntax resembles the well
        known C++ casts. Take note however that the lazy versions have a trailing
        underscore.
      </p>
<pre class="programlisting">
<span class="identifier">static_cast_</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">lambda_expression</span><span class="special">)</span>
<span class="identifier">dynamic_cast_</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">lambda_expression</span><span class="special">)</span>
<span class="identifier">const_cast_</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">lambda_expression</span><span class="special">)</span>
<span class="identifier">reinterpret_cast_</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="identifier">lambda_expression</span><span class="special">)</span>
</pre>
<p>
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">static_cast_</span><span class="special">&lt;</span><span class="identifier">Base</span><span class="special">*&gt;(&amp;</span><span class="identifier">arg1</span><span class="special">)</span>
</pre>
<p>
        Static-casts the address of <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        to a <tt class="computeroutput"><span class="identifier">Base</span><span class="special">*</span></tt>.
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.scope"></a><a href="composite.html#phoenix.composite.scope" title="Scope">Scope</a></h3></div></div></div>
<p>
        Up until now, the most basic ingredient is missing: creation of and access
        to local variables in the stack. When recursion comes into play, you will
        soon realize the need to have true local variables. It may seem that we do
        not need this at all since an unnamed lambda function cannot call itself
        anyway; at least not directly. With some sort of arrangement, situations
        will arise where a lambda function becomes recursive. A typical situation
        occurs when we store a lambda function in a <a href="http://www.boost.org/libs/function" target="_top">Boost.Function</a>,
        essentially naming the unnamed lambda.
      </p>
<p>
        There will also be situations where a lambda function gets passed as an argument
        to another function. This is a more common situation. In this case, the lambda
        function assumes a new scope; new arguments and possibly new local variables.
      </p>
<p>
        This section deals with local variables and nested lambda scopes.
      </p>
<a name="phoenix.composite.scope.local_variables"></a><h2>
<a name="id477790"></a>
        <a href="composite.html#phoenix.composite.scope.local_variables">Local Variables</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">scope</span><span class="special">/</span><span class="identifier">local_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        We use an instance of:
      </p>
<pre class="programlisting">
<span class="identifier">actor</span><span class="special">&lt;</span><span class="identifier">local_variable</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="special">&gt;</span>
</pre>
<p>
        to represent a local variable. The local variable acts as an imaginary data-bin
        where a local, stack based data will be placed. <tt class="computeroutput"><span class="identifier">Key</span></tt>
        is an arbitrary type that is used to identify the local variable. Example:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">size_key</span><span class="special">;</span>
<span class="identifier">actor</span><span class="special">&lt;</span><span class="identifier">local_variable</span><span class="special">&lt;</span><span class="identifier">size_key</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">size</span><span class="special">;</span>
</pre>
<a name="phoenix.composite.scope.predefined_local_variables"></a><h2>
<a name="id477914"></a>
        <a href="composite.html#phoenix.composite.scope.predefined_local_variables">Predefined
        Local Variables</a>
      </h2>
<p>
        There are a few predefined instances of <tt class="computeroutput"><span class="identifier">actor</span><span class="special">&lt;</span><span class="identifier">local_variable</span><span class="special">&lt;</span><span class="identifier">Key</span><span class="special">&gt;</span> <span class="special">&gt;</span></tt>
        named <tt class="computeroutput"><span class="identifier">_a</span></tt>..<tt class="computeroutput"><span class="identifier">_z</span></tt>
        that you can already use. To make use of them, simply use the <tt class="computeroutput"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">local_names</span></tt>:
      </p>
<pre class="programlisting">
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">phoenix</span><span class="special">::</span><span class="identifier">local_names</span><span class="special">;</span>
</pre>
<a name="phoenix.composite.scope.let"></a><h2>
<a name="id478101"></a>
        <a href="composite.html#phoenix.composite.scope.let">let</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">scope</span><span class="special">/</span><span class="identifier">let</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        You declare local variables using the syntax:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span><span class="identifier">local</span><span class="special">-</span><span class="identifier">declarations</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">let</span><span class="special">-</span><span class="identifier">body</span>
<span class="special">]</span>
</pre>
<p>
        <tt class="computeroutput"><span class="identifier">let</span></tt> allows 1..N local variable
        declarations (where N == <tt class="computeroutput"><span class="identifier">PHOENIX_LOCAL_LIMIT</span></tt>).
        Each declaration follows the form:
      </p>
<pre class="programlisting">
<span class="identifier">local</span><span class="special">-</span><span class="identifier">id</span> <span class="special">=</span> <span class="identifier">lambda</span><span class="special">-</span><span class="identifier">expression</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          You can set <tt class="computeroutput"><span class="identifier">PHOENIX_LOCAL_LIMIT</span></tt>,
          the predefined maximum local variable declarations in a let expression.
          By default, <tt class="computeroutput"><span class="identifier">PHOENIX_LOCAL_LIMIT</span></tt>
          is set to <tt class="computeroutput"><span class="identifier">PHOENIX_LIMIT</span></tt>.
        </p></td></tr>
</table></div>
<p>
        Example:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="number">123</span><span class="special">,</span> <span class="identifier">_b</span> <span class="special">=</span> <span class="number">456</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">_a</span> <span class="special">+</span> <span class="identifier">_b</span>
<span class="special">]</span>
</pre>
<a name="phoenix.composite.scope.reference_preservation"></a><h2>
<a name="id478506"></a>
        <a href="composite.html#phoenix.composite.scope.reference_preservation">Reference
        Preservation</a>
      </h2>
<p>
        The type of the local variable assumes the type of the lambda- expression.
        Type deduction is reference preserving. For example:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">_b</span> <span class="special">=</span> <span class="number">456</span><span class="special">)</span>
</pre>
<p>
        <tt class="computeroutput"><span class="identifier">_a</span></tt> assumes the type of <tt class="computeroutput"><span class="identifier">arg1</span></tt>: a reference to an argument, while
        <tt class="computeroutput"><span class="identifier">_b</span></tt> has type <tt class="computeroutput"><span class="keyword">int</span></tt>.
      </p>
<p>
        Consider this:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span>

<span class="identifier">let</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">arg1</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">--</span><span class="identifier">_a</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span>
<span class="special">]</span>
<span class="special">(</span><span class="identifier">i</span><span class="special">);</span>

<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        the output of above is : 0 0
      </p>
<p>
        While with this:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span>

<span class="identifier">let</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">val</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">))</span>
<span class="special">[</span>
    <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="special">--</span><span class="identifier">_a</span> <span class="special">&lt;&lt;</span> <span class="char">' '</span>
<span class="special">]</span>
<span class="special">(</span><span class="identifier">i</span><span class="special">);</span>

<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        the output is : 0 1
      </p>
<p>
        Reference preservation is necessary because we need to have L-value access
        to outer lambda-scopes (especially the arguments). <tt class="computeroutput"><span class="identifier">arg</span></tt>s
        and <tt class="computeroutput"><span class="identifier">ref</span></tt>s are L-values. <tt class="computeroutput"><span class="identifier">val</span></tt>s are R-values.
      </p>
<a name="phoenix.composite.scope.visibility"></a><h2>
<a name="id479058"></a>
        <a href="composite.html#phoenix.composite.scope.visibility">Visibility</a>
      </h2>
<p>
        The scope and lifetimes of the local variables is limited within the let-body.
        <tt class="computeroutput"><span class="identifier">let</span></tt> blocks can be nested.
        A local variable may hide an outer local variable. For example:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span><span class="identifier">_x</span> <span class="special">=</span> <span class="number">1</span><span class="special">,</span> <span class="identifier">_y</span> <span class="special">=</span> <span class="string">", World"</span><span class="special">)</span>
<span class="special">[</span>
    <span class="comment">// _x here is an int: 1
</span>
    <span class="identifier">let</span><span class="special">(</span><span class="identifier">_x</span> <span class="special">=</span> <span class="string">"Hello"</span><span class="special">)</span> <span class="comment">// hides the outer _x
</span>    <span class="special">[</span>
        <span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">_x</span> <span class="special">&lt;&lt;</span> <span class="identifier">_y</span> <span class="comment">// prints "Hello, World"
</span>    <span class="special">]</span>
<span class="special">]</span>
</pre>
<p>
        The RHS (right hand side lambda-expression) of each local-declaration cannot
        refer to any LHS local-id. At this point, the local-ids are not in scope
        yet; they will only be in scope in the let-body. The code below is in error:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span>
    <span class="identifier">_a</span> <span class="special">=</span> <span class="number">1</span>
  <span class="special">,</span> <span class="identifier">_b</span> <span class="special">=</span> <span class="identifier">_a</span> <span class="comment">// Error: _a is not in scope yet
</span><span class="special">)</span>
<span class="special">[</span>
    <span class="comment">// _a and _b's scope starts here
</span>    <span class="comment">/*. body .*/</span>
<span class="special">]</span>
</pre>
<p>
        However, if an outer let scope is available, this will be searched. Since
        the scope of the RHS of a local-declaration is the outer scope enclosing
        the let, the RHS of a local-declaration can refer to a local variable of
        an outer scope:
      </p>
<pre class="programlisting">
<span class="identifier">let</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="number">1</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">let</span><span class="special">(</span>
        <span class="identifier">_a</span> <span class="special">=</span> <span class="number">1</span>
      <span class="special">,</span> <span class="identifier">_b</span> <span class="special">=</span> <span class="identifier">_a</span> <span class="comment">// Ok. _a refers to the outer _a
</span>    <span class="special">)</span>
    <span class="special">[</span>
        <span class="comment">/*. body .*/</span>
    <span class="special">]</span>
<span class="special">]</span>
</pre>
<a name="phoenix.composite.scope.lambda"></a><h2>
<a name="id479523"></a>
        <a href="composite.html#phoenix.composite.scope.lambda">lambda</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">scope</span><span class="special">/</span><span class="identifier">lambda</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        A lot of times, you'd want to write a lazy function that accepts one or more
        functions (higher order functions). STL algorithms come to mind, for example.
        Consider a lazy version of <tt class="computeroutput"><span class="identifier">stl</span><span class="special">::</span><span class="identifier">for_each</span></tt>:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">for_each_impl</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">F</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">C</span><span class="special">&amp;</span> <span class="identifier">c</span><span class="special">,</span> <span class="identifier">F</span> <span class="identifier">f</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span><span class="special">(</span><span class="identifier">c</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">c</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">f</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">for_each_impl</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">for_each</span> <span class="special">=</span> <span class="identifier">for_each_impl</span><span class="special">();</span>
</pre>
<p>
        Notice that the function accepts another function, <tt class="computeroutput"><span class="identifier">f</span></tt>
        as an argument. The scope of this function, <tt class="computeroutput"><span class="identifier">f</span></tt>,
        is limited within the <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>. When <tt class="computeroutput"><span class="identifier">f</span></tt>
        is called inside <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span></tt>, it exists in a new scope, along
        with new arguments and, possibly, local variables. This new scope is not
        at all related to the outer scopes beyond the <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt>.
      </p>
<p>
        Simple syntax:
      </p>
<pre class="programlisting">
<span class="identifier">lambda</span>
<span class="special">[</span>
    <span class="identifier">lambda</span><span class="special">-</span><span class="identifier">body</span>
<span class="special">]</span>
</pre>
<p>
        Like <tt class="computeroutput"><span class="identifier">let</span></tt>, local variables
        may be declared, allowing 1..N local variable declarations (where N == <tt class="computeroutput"><span class="identifier">PHOENIX_LOCAL_LIMIT</span></tt>):
      </p>
<pre class="programlisting">
<span class="identifier">lambda</span><span class="special">(</span><span class="identifier">local</span><span class="special">-</span><span class="identifier">declarations</span><span class="special">)</span>
<span class="special">[</span>
    <span class="identifier">lambda</span><span class="special">-</span><span class="identifier">body</span>
<span class="special">]</span>
</pre>
<p>
        The same restrictions apply with regard to scope and visibility. The RHS
        (right hand side lambda-expression) of each local-declaration cannot refer
        to any LHS local-id. The local-ids are not in scope yet; they will be in
        scope only in the lambda-body:
      </p>
<pre class="programlisting">
<span class="identifier">lambda</span><span class="special">(</span>
    <span class="identifier">_a</span> <span class="special">=</span> <span class="number">1</span>
  <span class="special">,</span> <span class="identifier">_b</span> <span class="special">=</span> <span class="identifier">_a</span> <span class="comment">// Error: _a is not in scope yet
</span><span class="special">)</span>
</pre>
<p>
        See <a href="composite.html#phoenix.composite.scope.visibility"><tt class="computeroutput"><span class="identifier">let</span></tt>
        Visibility</a> above for more information.
      </p>
<p>
        Example: Using our lazy <tt class="computeroutput"><span class="identifier">for_each</span></tt>
        let's print all the elements in a container:
      </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">lambda</span><span class="special">[</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">arg1</span><span class="special">])</span>
</pre>
<p>
        As far as the arguments are concerned (arg1..argN), the scope in which the
        lambda-body exists is totally new. The left <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        refers to the argument passed to <tt class="computeroutput"><span class="identifier">for_each</span></tt>
        (a container). The right <tt class="computeroutput"><span class="identifier">arg1</span></tt>
        refers to the argument passed by <tt class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">for_each</span></tt>
        when we finally get to call <tt class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></tt> in our <tt class="computeroutput"><span class="identifier">for_each_impl</span></tt>
        above (a container element).
      </p>
<p>
        Yet, we may wish to get information from outer scopes. While we do not have
        access to arguments in outer scopes, what we still have is access to local
        variables from outer scopes. We may only be able to pass argument related
        information from outer <tt class="computeroutput"><span class="identifier">lambda</span></tt>
        scopes through the local variables.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          This is a crucial difference between <tt class="computeroutput"><span class="identifier">let</span></tt>
          and <tt class="computeroutput"><span class="identifier">lambda</span></tt>: <tt class="computeroutput"><span class="identifier">let</span></tt> does not introduce new arguments;
          <tt class="computeroutput"><span class="identifier">lambda</span></tt> does.
        </p></td></tr>
</table></div>
<p>
        Another example: Using our lazy <tt class="computeroutput"><span class="identifier">for_each</span></tt>,
        and a lazy <tt class="computeroutput"><span class="identifier">push_back</span></tt>:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">push_back_impl</span>
<span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span>
    <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">void</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">C</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">C</span><span class="special">&amp;</span> <span class="identifier">c</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="keyword">const</span>
    <span class="special">{</span>
        <span class="identifier">c</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="identifier">function</span><span class="special">&lt;</span><span class="identifier">push_back_impl</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">push_back</span> <span class="special">=</span> <span class="identifier">push_back_impl</span><span class="special">();</span>
</pre>
<p>
        write a lambda expression that accepts:
      </p>
<div class="orderedlist"><ol type="1">
<li>
          a 2-dimensional container (e.g. <tt class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span></tt>)
        </li>
<li>
          a container element (e.g. <tt class="computeroutput"><span class="keyword">int</span></tt>)
        </li>
</ol></div>
<p>
        and pushes-back the element to each of the <tt class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></tt>.
      </p>
<p>
        Solution:
      </p>
<pre class="programlisting">
<span class="identifier">for_each</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">,</span>
    <span class="identifier">lambda</span><span class="special">(</span><span class="identifier">_a</span> <span class="special">=</span> <span class="identifier">arg2</span><span class="special">)</span>
    <span class="special">[</span>
        <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">_a</span><span class="special">)</span>
    <span class="special">]</span>
<span class="special">)</span>
</pre>
<p>
        Since we do not have access to the arguments of the outer scopes beyond the
        lambda-body, we introduce a local variable <tt class="computeroutput"><span class="identifier">_a</span></tt>
        that captures the second outer argument: <tt class="computeroutput"><span class="identifier">arg2</span></tt>.
        Hence: _a = arg2. This local variable is visible inside the lambda scope.
      </p>
<p>
        (See <a href="../../../example/users_manual/lambda.cpp" target="_top">lambda.cpp</a>)
      </p>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="phoenix.composite.bind"></a><a href="composite.html#phoenix.composite.bind" title="Bind">Bind</a></h3></div></div></div>
<p>
        <span class="emphasis"><em>Binding</em></span> is the act of tying together a function to some
        arguments for deferred (lazy) evaluation. Named <a href="composite.html#phoenix.composite.function" title="Function">Lazy
        functions</a> require a bit of typing. Unlike (unnamed) lambda expressions,
        we need to write a functor somewhere offline, detached from the call site.
        If you wish to transform a plain function, member function or member variable
        to a lambda expression, <tt class="computeroutput"><span class="identifier">bind</span></tt>
        is your friend.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../doc/html/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td colspan="2" align="left" valign="top"><p>
          Take note that binders are monomorphic. Rather than binding functions,
          the preferred way is to write true generic and polymorphic <a href="composite.html#phoenix.composite.function" title="Function">lazy-functions</a>.
          However, since most of the time we are dealing with adaptation of exisiting
          code, binders get the job done faster.
        </p></td></tr>
</table></div>
<p>
        There is a set of overloaded <tt class="computeroutput"><span class="identifier">bind</span></tt>
        template functions. Each <tt class="computeroutput"><span class="identifier">bind</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></tt>
        function generates a suitable binder object, a <a href="composite.html" title="Composite">composite</a>.
      </p>
<a name="phoenix.composite.bind.binding_functions"></a><h2>
<a name="id481395"></a>
        <a href="composite.html#phoenix.composite.bind.binding_functions">Binding Functions</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">bind</span><span class="special">/</span><span class="identifier">bind_function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Example, given a function <tt class="computeroutput"><span class="identifier">foo</span></tt>:
      </p>
<pre class="programlisting">
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">n</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">n</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Here's how the function <tt class="computeroutput"><span class="identifier">foo</span></tt>
        may be bound:
      </p>
<pre class="programlisting">
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span>
</pre>
<p>
        This is now a full-fledged <a href="composite.html" title="Composite">composite</a>
        that can finally be evaluated by another function call invocation. A second
        function call will invoke the actual <tt class="computeroutput"><span class="identifier">foo</span></tt>
        function. Example:
      </p>
<pre class="programlisting">
<span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">4</span><span class="special">;</span>
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)(</span><span class="identifier">i</span><span class="special">);</span>
</pre>
<p>
        will print out "4".
      </p>
<a name="phoenix.composite.bind.binding_member_functions"></a><h2>
<a name="id481800"></a>
        <a href="composite.html#phoenix.composite.bind.binding_member_functions">Binding Member
        Functions</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">bind</span><span class="special">/</span><span class="identifier">bind_member_function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Binding member functions can be done similarly. A bound member function takes
        in a pointer or reference to an object as the first argument. For instance,
        given:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">xyz</span>
<span class="special">{</span>
    <span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        <tt class="computeroutput"><span class="identifier">xyz</span></tt>'s <tt class="computeroutput"><span class="identifier">foo</span></tt>
        member function can be bound as:
      </p>
<pre class="programlisting">
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span> <span class="comment">// obj is an xyz object
</span></pre>
<p>
        Take note that a lazy-member functions expects the first argument to be a
        pointer or reference to an object. Both the object (reference or pointer)
        and the arguments can be lazily bound. Examples:
      </p>
<pre class="programlisting">
<span class="identifier">xyz</span> <span class="identifier">obj</span><span class="special">;</span>
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">,</span> <span class="identifier">arg2</span><span class="special">)</span>     <span class="comment">// arg1.foo(arg2)
</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">obj</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span>      <span class="comment">// obj.foo(arg1)
</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">foo</span><span class="special">,</span> <span class="identifier">obj</span><span class="special">,</span> <span class="number">100</span><span class="special">)</span>       <span class="comment">// obj.foo(100)
</span></pre>
<a name="phoenix.composite.bind.binding_member_variables"></a><h2>
<a name="id482292"></a>
        <a href="composite.html#phoenix.composite.bind.binding_member_variables">Binding Member
        Variables</a>
      </h2>
<pre class="programlisting">
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">spirit</span><span class="special">/</span><span class="identifier">home</span><span class="special">/</span><span class="identifier">phoenix</span><span class="special">/</span><span class="identifier">bind</span><span class="special">/</span><span class="identifier">bind_member_variable</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<p>
        Member variables can also be bound much like member functions. Member variables
        are not functions. Yet, like the <a href="primitives.html#phoenix.primitives.references" title="References"><tt class="computeroutput"><span class="identifier">ref</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></tt></a> that acts like a nullary function
        returning a reference to the data, member variables, when bound, act like
        a unary function, taking in a pointer or reference to an object as its argument
        and returning a reference to the bound member variable. For instance, given:
      </p>
<pre class="programlisting">
<span class="keyword">struct</span> <span class="identifier">xyz</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">v</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        <tt class="computeroutput"><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">v</span></tt> can be bound as:
      </p>
<pre class="programlisting">
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">obj</span><span class="special">)</span> <span class="comment">// obj is an xyz object
</span></pre>
<p>
        As noted, just like the bound member function, a bound member variable also
        expects the first (and only) argument to be a pointer or reference to an
        object. The object (reference or pointer) can be lazily bound. Examples:
      </p>
<pre class="programlisting">
<span class="identifier">xyz</span> <span class="identifier">obj</span><span class="special">;</span>
<span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)</span>             <span class="comment">// arg1.v
</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">obj</span><span class="special">)</span>              <span class="comment">// obj.v
</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">xyz</span><span class="special">::</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">arg1</span><span class="special">)(</span><span class="identifier">obj</span><span class="special">)</span> <span class="special">=</span> <span class="number">4</span>    <span class="comment">// obj.v = 4
</span></pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2002-2005 Joel
      de Guzman, Dan Marsden<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="primitives.html"><img src="../../../../../../doc/html/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../../doc/html/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../../doc/html/images/home.png" alt="Home"></a><a accesskey="n" href="container.html"><img src="../../../../../../doc/html/images/next.png" alt="Next"></a>
</div>
</body>
</html>

<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/basic_regex.hpp"><para>Contains the definition of the basic_regex&lt;&gt; class template and its associated helper functions. </para><namespace name="boost"><namespace name="xpressive"><struct name="basic_regex"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template basic_regex&lt;&gt; is a class for holding a compiled regular expression. </purpose><typedef name="iterator_type"><type>BidiIter</type></typedef><typedef name="char_type"><type>iterator_value&lt; BidiIter &gt;::type</type></typedef><typedef name="string_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="flag_type"><type>regex_constants::syntax_option_type</type></typedef><method-group name="public member functions"><method name="mark_count" cv="const"><type>std::size_t</type><description><para>Returns the count of capturing sub-expressions in this regular expression </para></description></method><method name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns a token which uniquely identifies this regular expression. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The other basic_regex object. </para></description></parameter><description><para>Swaps the contents of this basic_regex object with another.</para><para>


</para></description><throws><simpara>Will not throw.</simpara></throws><notes><para>This is a shallow swap that does not do reference tracking. If you embed a basic_regex object by reference in another regular expression and then swap its contents with another basic_regex object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that swap() cannot throw. </para></notes></method></method-group><constructor><description><para>
</para></description><postconditions><para>regex_id() == 0 </para><para>mark_count() == 0 </para></postconditions></constructor><constructor><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The basic_regex object to copy. </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id() </para><para>mark_count() == that.mark_count() </para></postconditions></constructor><copy-assignment><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The basic_regex object to copy. </para></description></parameter><description><para>


</para></description><postconditions><para>regex_id() == that.regex_id() </para><para>mark_count() == that.mark_count() </para></postconditions><returns><para>*this </para></returns></copy-assignment><constructor><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression </para></description></parameter><description><para>Construct from a static regular expression.</para><para>


</para></description><requires><para>Expr is the type of a static regular expression. </para></requires><postconditions><para>regex_id() != 0 </para><para>mark_count() &gt;= 0 </para></postconditions></constructor><copy-assignment><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression. </para></description></parameter><description><para>Construct from a static regular expression.</para><para>




</para></description><requires><para>Expr is the type of a static regular expression. </para></requires><postconditions><para>regex_id() != 0 </para><para>mark_count() &gt;= 0 </para></postconditions><returns><para>*this </para></returns><throws><simpara><classname>std::bad_alloc</classname> </simpara></throws></copy-assignment><method-group name="public static functions"><method name="compile" cv=""><type>static <classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Factory method for building a regex object from a range of characters. Equivalent to regex_compiler&lt; BidiIter &gt;().compile(begin, end, flags);</para><para>



</para></description><requires><para>[begin,end) is a valid range. </para><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para></requires><returns><para>A basic_regex object corresponding to the regular expression represented by the character range. </para></returns><throws><simpara><classname/> </simpara></throws></method><method name="compile" cv=""><type>static <classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="compile" cv=""><type>static <classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="compile" cv=""><type>static <classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="len"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><method-group name="private member functions"/></struct><function name="swap"><type>void</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="left"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The first basic_regex object. </para></description></parameter><parameter name="right"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The second basic_regex object. </para></description></parameter><purpose>Swaps the contents of two basic_regex objects. </purpose><description><para>


</para></description><throws><simpara>Will not throw.</simpara></throws><notes><para>This is a shallow swap that does not do reference tracking. If you embed a basic_regex object by reference in another regular expression and then swap its contents with another basic_regex object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that swap() cannot throw. </para></notes></function></namespace></namespace></header><header name="boost/xpressive/match_results.hpp"><para>Contains the definition of the match_results type and associated helpers. The match_results type holds the results of a regex_match() or regex_search() operation. </para><namespace name="boost"><namespace name="xpressive"><struct name="match_results"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template match_results&lt;&gt; holds the results of a regex_match() or a regex_search() as a collection of sub_match objects. </purpose><description><para>Class template match_results&lt;&gt; denotes a collection of sequences representing the result of a regular expression match. Storage for the collection is allocated and freed as necessary by the member functions of class match_results&lt;&gt;.</para><para>The class template match_results&lt;&gt; conforms to the requirements of a Sequence, as specified in (lib.sequence.reqmts), except that only operations defined for const-qualified Sequences are supported. </para></description><typedef name="char_type"><type>iterator_value&lt; BidiIter &gt;::type</type></typedef><typedef name="string_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="size_type"><type>std::size_t</type></typedef><typedef name="value_type"><type><classname>sub_match</classname>&lt; BidiIter &gt;</type></typedef><typedef name="difference_type"><type>iterator_difference&lt; BidiIter &gt;::type</type></typedef><typedef name="reference"><type><classname>value_type</classname> const &amp;</type></typedef><typedef name="const_reference"><type><classname>value_type</classname> const &amp;</type></typedef><typedef name="iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_iterator"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="nested_results_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="size" cv="const"><type>size_type</type><description><para>Returns one plus the number of marked sub-expressions in the regular expression that was matched if *this represents the result of a successful match. Otherwise returns 0. </para></description></method><method name="empty" cv="const"><type>bool</type><description><para>Returns size() == 0. </para></description></method><method name="length" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].length(). </para></description></method><method name="position" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>If !(*this)[sub].matched then returns -1. Otherwise returns std::distance(base, (*this)[sub].first), where base is the start iterator of the sequence that was searched. [Note - unless this is part of a repeated search with a regex_iterator then base is the same as prefix().first - end note] </para></description></method><method name="str" cv="const"><type>string_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].str(). </para></description></method><method name="operator[]" cv="const"><type>const_reference</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter><description><para>Returns a reference to the sub_match object representing the sequence that matched marked sub-expression sub. If sub == 0 then returns a reference to a sub_match object representing the sequence that matched the whole regular expression. If sub &gt;= size() then returns a sub_match object representing an unmatched sub-expression. </para></description></method><method name="prefix" cv="const"><type>const_reference</type><description><para>Returns a reference to the sub_match object representing the character sequence from the start of the string being matched/searched, to the start of the match found. </para></description></method><method name="suffix" cv="const"><type>const_reference</type><description><para>Returns a reference to the sub_match object representing the character sequence from the end of the match found to the end of the string being matched/searched. </para></description></method><method name="begin" cv="const"><type>const_iterator</type><description><para>Returns a starting iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method><method name="end" cv="const"><type>const_iterator</type><description><para>Returns a terminating iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method><method name="conversion-operator" cv="const"><type>bool_type</type><description><para>Returns a true value if (*this)[0].matched, else returns a false value. </para></description></method><method name="operator!" cv="const"><type>bool</type><description><para>Returns true if empty() || !(*this)[0].matched, else returns false. </para></description></method><method name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns the id of the basic_regex object most recently used with this match_results object. </para></description></method><method name="nested_results" cv="const"><type>nested_results_type const &amp;</type><description><para>Returns a Sequence of nested match_results elements. </para></description></method><method name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function copies the character sequence in <computeroutput>fmt</computeroutput> to <computeroutput>OutputIterator</computeroutput> <computeroutput>out</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in flags determines what format specifiers or escape sequences are recognized. By default, this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out, flags)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>std::copy(x.begin(), x.end(), out)</computeroutput>, where <computeroutput>x</computeroutput> is the result of calling <computeroutput>fmt(*this)</computeroutput>. </para></description></method><method name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="format" cv="const"><type>string_type</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function returns a copy of the character sequence <computeroutput>fmt</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in <computeroutput>flags</computeroutput> determines what format specifiers or escape sequences are recognized. By default this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out, flags)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;match_results&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>fmt(*this)</computeroutput>. </para></description></method><method name="format" cv="const"><type>string_type</type><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="swap" cv=""><type>void</type><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The match_results object to swap with. </para></description></parameter><description><para>Swaps the contents of two match_results objects. Guaranteed not to throw. 


</para></description><postconditions><para>*this contains the sequence of matched sub-expressions that were in that, that contains the sequence of matched sub-expressions that were in *this. </para></postconditions><throws><simpara>Will not throw.</simpara></throws></method><method name="let" cv=""><type><classname>match_results</classname>&lt; BidiIter &gt; &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><description><para>TODO document me </para></description></method></method-group><constructor><description><para>
</para></description><postconditions><para>regex_id() == 0 </para><para>size() == 0 </para><para>empty() == true </para><para>str() == string_type() </para></postconditions></constructor><constructor><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The match_results object to copy </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id(). </para><para>size() == that.size(). </para><para>empty() == that.empty(). </para><para>str(n) == that.str(n) for all positive integers n &lt; that.size(). </para><para>prefix() == that.prefix(). </para><para>suffix() == that.suffix(). </para><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para><para>length(n) == that.length(n) for all positive integers n &lt; that.size(). </para><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para></postconditions></constructor><destructor/><copy-assignment><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The match_results object to copy. </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id(). </para><para>size() == that.size(). </para><para>empty() == that.empty(). </para><para>str(n) == that.str(n) for all positive integers n &lt; that.size(). </para><para>prefix() == that.prefix(). </para><para>suffix() == that.suffix(). </para><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para><para>length(n) == that.length(n) for all positive integers n &lt; that.size(). </para><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para></postconditions></copy-assignment></struct><struct name="regex_id_filter_predicate"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions"><method name="operator()" cv="const"><type>bool</type><parameter name="res"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></method></method-group><constructor><parameter name="regex_id"><paramtype>regex_id_type</paramtype></parameter></constructor></struct></namespace></namespace></header><header name="boost/xpressive/regex_actions.hpp"><para>Defines the syntax elements of xpressive's action expressions. </para><namespace name="boost"><namespace name="xpressive"><struct name="function"><template>
      <template-type-parameter name="Fun"/>
    </template><typedef name="type"><type>proto::terminal&lt; Fun &gt;::type</type></typedef></struct><struct name="value"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="base_type"><type>proto::extends&lt; typename proto::terminal&lt; T &gt;::type, <classname>value</classname>&lt; T &gt; &gt;</type></typedef><method-group name="public member functions"><method name="get" cv=""><type>T &amp;</type></method><method name="get" cv="const"><type>T const &amp;</type></method></method-group><constructor/><constructor><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></constructor></struct><struct name="reference"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="base_type"><type>proto::extends&lt; typename proto::terminal&lt; reference_wrapper&lt; T &gt; &gt;::type, <classname>reference</classname>&lt; T &gt; &gt;</type></typedef><method-group name="public member functions"><method name="get" cv="const"><type>T &amp;</type></method></method-group><constructor><parameter name="t"><paramtype>T &amp;</paramtype></parameter></constructor></struct><struct name="local"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="base_type"><type>proto::terminal&lt; reference_wrapper&lt; T &gt; &gt;::type</type></typedef><method-group name="public member functions"><method name="get" cv=""><type>T &amp;</type></method><method name="get" cv="const"><type>T const &amp;</type></method></method-group><constructor/><constructor><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></constructor></struct><struct name="placeholder"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="I"><type>int</type></template-nontype-parameter>
      <template-type-parameter name="Dummy"/>
    </template><description><para>placeholder&lt;T&gt;, for defining a placeholder to stand in fo a variable of type T in a semantic action. </para></description><typedef name="this_type"><type><classname>placeholder</classname>&lt; T, I, Dummy &gt;</type></typedef><typedef name="action_arg_type"><type><emphasis>unspecified</emphasis></type></typedef></struct><namespace name="op"><struct name="push"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="push_back"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="push_front"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="pop"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct><struct name="pop_back"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct><struct name="pop_front"><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct><struct name="front"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="type"><type>mpl::if_&lt; is_const&lt; sequence_type &gt;, typename sequence_type::const_reference, typename sequence_type::reference &gt;::type</type></typedef><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Sequence</paramtype></parameter></method></method-group></struct-specialization></struct><struct name="back"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="type"><type>mpl::if_&lt; is_const&lt; sequence_type &gt;, typename sequence_type::const_reference, typename sequence_type::reference &gt;::type</type></typedef><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Sequence</paramtype></parameter></method></method-group></struct-specialization></struct><struct name="top"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="type"><type>mpl::if_&lt; is_const&lt; sequence_type &gt;, typename sequence_type::value_type const &amp;, typename sequence_type::value_type &amp; &gt;::type</type></typedef><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Sequence</paramtype></parameter></method></method-group></struct-specialization></struct><struct name="first"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Pair::first_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype></parameter></method></method-group></struct><struct name="second"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Pair::second_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype></parameter></method></method-group></struct><struct name="matched"><typedef name="result_type"><type>bool</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter></method></method-group></struct><struct name="length"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Sub::difference_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter></method></method-group></struct><struct name="str"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Sub::string_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter></method></method-group></struct><struct name="insert"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="It"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>It</template-arg><template-arg>It)</template-arg><template-arg>void</template-arg></specialization><typedef name="type"><type>void</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="It"/>
      <template-type-parameter name="Size"/>
      <template-type-parameter name="Value"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>It</template-arg><template-arg>Size</template-arg><template-arg>Value)</template-arg><template-arg>typename disable_if&lt; is_integral&lt; UNCVREF(It)&gt; &gt;::type</template-arg></specialization><typedef name="type"><type>void</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="It"/>
      <template-type-parameter name="Value"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>It</template-arg><template-arg>Value)</template-arg><template-arg>typename disable_if&lt; mpl::or_&lt; is_integral&lt; UNCVREF(It)&gt;</template-arg><template-arg>is_same&lt; UNCVREF(It)</template-arg><template-arg>UNCVREF(Value)&gt; &gt; &gt;::type</template-arg></specialization></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Size"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>Size</template-arg><template-arg>A0</template-arg><template-arg>A1)</template-arg><template-arg>typename enable_if&lt; is_integral&lt; UNCVREF(Size)&gt; &gt;::type</template-arg></specialization><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Cont</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Size"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>Size</template-arg><template-arg>T)</template-arg><template-arg>typename enable_if&lt; is_integral&lt; UNCVREF(Size)&gt; &gt;::type</template-arg></specialization><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Cont</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Value"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>Value)</template-arg><template-arg>void</template-arg></specialization><data-member name="scont_" specifiers="static"><type>cont_type &amp;</type></data-member><data-member name="svalue_" specifiers="static"><type>value_type &amp;</type></data-member><typedef name="yes_type"><type>char</type></typedef><typedef name="no_type"><type>char(&amp;</type></typedef><typedef name="type"><type>mpl::if_c&lt; is_iterator, typename cont_type::iterator, <classname>std::pair</classname>&lt; typename cont_type::iterator, bool &gt; &gt;::type</type></typedef><method-group name="public member functions"><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Cont</paramtype></parameter></method><method name="UNREF" cv=""><type>typedef</type><parameter name=""><paramtype>Value</paramtype></parameter></method><method name="BOOST_STATIC_CONSTANT" cv=""><type/><parameter name=""><paramtype>bool</paramtype></parameter><parameter name=""><paramtype>is_iterator</paramtype><default>(sizeof(yes_type)==sizeof(check_insert_return(scont_.insert(svalue_))))</default></parameter></method></method-group><method-group name="public static functions"><method name="check_insert_return" cv=""><type>static yes_type</type><parameter name=""><paramtype>typename cont_type::iterator</paramtype></parameter></method><method name="check_insert_return" cv=""><type>static no_type</type><parameter name=""><paramtype><classname>std::pair</classname>&lt; typename cont_type::iterator, bool &gt;</paramtype></parameter></method></method-group></struct-specialization></struct><struct name="make_pair"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="First"/>
      <template-type-parameter name="Second"/>
    </template><specialization><template-arg>This(First</template-arg><template-arg>Second)</template-arg></specialization><typedef name="type"><type><classname>std::pair</classname>&lt; UNCVREF(First), UNCVREF(Second)&gt;</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>std::pair</classname>&lt; First, Second &gt;</type><template>
          <template-type-parameter name="First"/>
          <template-type-parameter name="Second"/>
        </template><parameter name="first"><paramtype>First const &amp;</paramtype></parameter><parameter name="second"><paramtype>Second const &amp;</paramtype></parameter></method></method-group></struct><struct name="as"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="result_type"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="static_cast_"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="result_type"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="dynamic_cast_"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="result_type"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="const_cast_"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="result_type"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype></parameter></method></method-group></struct><struct name="construct"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="result_type"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>T</type></method><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method></method-group></struct><struct name="throw_"><template>
      <template-type-parameter name="Except"/>
    </template><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method></method-group></struct></namespace><data-member name="push"><type><classname>function</classname>&lt; <classname>op::push</classname> &gt;::type const</type></data-member><data-member name="push_back"><type><classname>function</classname>&lt; <classname>op::push_back</classname> &gt;::type const</type></data-member><data-member name="push_front"><type><classname>function</classname>&lt; <classname>op::push_front</classname> &gt;::type const</type></data-member><data-member name="pop"><type><classname>function</classname>&lt; <classname>op::pop</classname> &gt;::type const</type></data-member><data-member name="pop_back"><type><classname>function</classname>&lt; <classname>op::pop_back</classname> &gt;::type const</type></data-member><data-member name="pop_front"><type><classname>function</classname>&lt; <classname>op::pop_front</classname> &gt;::type const</type></data-member><data-member name="top"><type><classname>function</classname>&lt; <classname>op::top</classname> &gt;::type const</type></data-member><data-member name="back"><type><classname>function</classname>&lt; <classname>op::back</classname> &gt;::type const</type></data-member><data-member name="front"><type><classname>function</classname>&lt; <classname>op::front</classname> &gt;::type const</type></data-member><data-member name="first"><type><classname>function</classname>&lt; <classname>op::first</classname> &gt;::type const</type></data-member><data-member name="second"><type><classname>function</classname>&lt; <classname>op::second</classname> &gt;::type const</type></data-member><data-member name="matched"><type><classname>function</classname>&lt; <classname>op::matched</classname> &gt;::type const</type></data-member><data-member name="length"><type><classname>function</classname>&lt; <classname>op::length</classname> &gt;::type const</type></data-member><data-member name="str"><type><classname>function</classname>&lt; <classname>op::str</classname> &gt;::type const</type></data-member><data-member name="insert"><type><classname>function</classname>&lt; <classname>op::insert</classname> &gt;::type const</type></data-member><data-member name="make_pair"><type><classname>function</classname>&lt; <classname>op::make_pair</classname> &gt;::type const</type></data-member><data-member name="static_cast_"><type/></data-member><data-member name="dynamic_cast_"><type>()</type></data-member><data-member name="const_cast_"><type>()()</type></data-member><data-member name="check"><type><emphasis>unspecified</emphasis></type><description><para>check(), for testing custom assertions </para></description></data-member><data-member name="let"><type><emphasis>unspecified</emphasis></type><description><para>let(), for binding references to non-local variables </para></description></data-member><function name="BOOST_PROTO_DEFINE_FUNCTION_TEMPLATE"><type/><parameter name=""><paramtype>1</paramtype></parameter><parameter name=""><paramtype>as</paramtype></parameter><parameter name=""><paramtype>boost::proto::default_domain</paramtype></parameter><parameter name=""><paramtype>(boost::proto::tag::function)</paramtype></parameter><parameter name=""><paramtype>((<classname>op::as</classname>)(typename))</paramtype></parameter><description><para>as (a.k.a., lexical_cast) static_cast_ </para></description></function><function name="ref"><type><classname>reference</classname>&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter><description><para>ref() </para></description></function><function name="cref"><type><classname>reference</classname>&lt; T const  &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>cref() </para></description></function><function name="BOOST_PROTO_DEFINE_VARARG_FUNCTION_TEMPLATE"><type/><parameter name=""><paramtype>construct</paramtype></parameter><parameter name=""><paramtype>boost::proto::default_domain</paramtype></parameter><parameter name=""><paramtype>(boost::proto::tag::function)</paramtype></parameter><parameter name=""><paramtype>((<classname>op::construct</classname>)(typename))</paramtype></parameter><description><para>Usage: construct&lt;Type&gt;(arg1, arg2) Usage: throw_&lt;Exception&gt;(arg1, arg2) </para></description></function></namespace></namespace></header><header name="boost/xpressive/regex_algorithms.hpp"><para>Contains the regex_match(), regex_search() and regex_replace() algorithms. </para><namespace name="boost"><namespace name="xpressive"><overloaded-function name="regex_match"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence. </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput>match_results</computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>See if a regex matches a sequence from beginning to end. </purpose><description><para>Determines whether there is an exact match between the regular expression <computeroutput>re</computeroutput>, and all of the sequence <computeroutput>[begin, end)</computeroutput>.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para></returns><throws><simpara><classname>\c</classname> </simpara></throws></overloaded-function><overloaded-function name="regex_search"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput>match_results</computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>. </purpose><description><para>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para></returns><throws><simpara><classname>\c</classname> </simpara></throws></overloaded-function><overloaded-function name="regex_replace"><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype><description><para>An output iterator into which the output sequence is written. </para></description></parameter><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the input sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the input sequence. </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use. </para></description></parameter><parameter name="format"><paramtype><classname>Formatter</classname> const &amp;</paramtype><description><para>The format string used to format the replacement sequence, or a formatter function, function object, or expression. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype></parameter><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype><classname>Formatter</classname> const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype><classname>Formatter</classname> const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype><classname>Formatter</classname> const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename add_const&lt; Char &gt;::type *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><purpose>Build an output sequence given an input sequence, a regex, and a format string or a formatter object, function, or expression. </purpose><description><para>Constructs a <computeroutput>regex_iterator</computeroutput> object: <computeroutput>regex_iterator&lt; BidiIter &gt; i(begin, end, re, flags)</computeroutput>, and uses <computeroutput>i</computeroutput> to enumerate through all of the matches m of type <computeroutput>match_results&lt; BidiIter &gt;</computeroutput> that occur within the sequence <computeroutput>[begin, end)</computeroutput>. If no such matches are found and <computeroutput>!(flags &amp; format_no_copy)</computeroutput> then calls <computeroutput>std::copy(begin, end, out)</computeroutput>. Otherwise, for each match found, if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(m.prefix().first, m.prefix().second, out)</computeroutput>, and then calls <computeroutput>m.format(out, format, flags)</computeroutput>. Finally if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(last_m.suffix().first, last_m.suffix().second, out)</computeroutput> where <computeroutput>last_m</computeroutput> is a copy of the last match found.</para><para>If <computeroutput>flags &amp; format_first_only</computeroutput> is non-zero then only the first match found is replaced.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para>Type <computeroutput>OutIter</computeroutput> meets the requirements of an Output Iterator (24.1.2). </para><para>Type <computeroutput>Formatter</computeroutput> models <computeroutput>ForwardRange</computeroutput>, <computeroutput>Callable&lt;match_results&lt;BidiIter&gt; &gt;</computeroutput>, <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutIter&gt;</computeroutput>, or <computeroutput>Callable&lt;match_results&lt;BidiIter&gt;, OutIter, regex_constants::match_flag_type&gt;</computeroutput>; or else it is a null-terminated format string, or an expression template representing a formatter lambda expression. </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para>The value of the output iterator after the output sequence has been written to it. </para></returns><throws><simpara><classname>\c</classname> </simpara></throws></overloaded-function></namespace></namespace></header><header name="boost/xpressive/regex_compiler.hpp"><para>Contains the definition of regex_compiler, a factory for building regex objects from strings. </para><namespace name="boost"><namespace name="xpressive"><struct name="regex_compiler"><template>
      <template-type-parameter name="BidiIter"/>
      <template-type-parameter name="RegexTraits"/>
      <template-type-parameter name="CompilerTraits"/>
    </template><purpose>Class template regex_compiler is a factory for building basic_regex objects from a string. </purpose><description><para>Class template regex_compiler is used to construct a basic_regex object from a string. The string should contain a valid regular expression. You can imbue a regex_compiler object with a locale, after which all basic_regex objects created with that regex_compiler object will use that locale. After creating a regex_compiler object, and optionally imbueing it with a locale, you can call the compile() method to construct a basic_regex object, passing it the string representing the regular expression. You can call compile() multiple times on the same regex_compiler object. Two basic_regex objects compiled from the same string will have different regex_id's. </para></description><typedef name="iterator_type"><type>BidiIter</type></typedef><typedef name="char_type"><type>iterator_value&lt; BidiIter &gt;::type</type></typedef><typedef name="flag_type"><type>regex_constants::syntax_option_type</type></typedef><typedef name="traits_type"><type>RegexTraits</type></typedef><typedef name="string_type"><type>traits_type::string_type</type></typedef><typedef name="locale_type"><type>traits_type::locale_type</type></typedef><typedef name="char_class_type"><type>traits_type::char_class_type</type></typedef><method-group name="public member functions"><method name="imbue" cv=""><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>The locale that this regex_compiler should use. </para></description></parameter><description><para>Specify the locale to be used by a regex_compiler.</para><para>

</para></description><returns><para>The previous locale. </para></returns></method><method name="getloc" cv="const"><type>locale_type</type><description><para>Get the locale used by a regex_compiler.</para><para>
</para></description><returns><para>The locale used by this regex_compiler. </para></returns></method><method name="compile" cv=""><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Builds a basic_regex object from a range of characters.</para><para>



</para></description><requires><para>InputIter is a model of the InputIterator concept. </para><para>[begin,end) is a valid range. </para><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para></requires><returns><para>A basic_regex object corresponding to the regular expression represented by the character range. </para></returns><throws><simpara><classname/> </simpara></throws></method><method name="compile" cv=""><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="compile" cv=""><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="compile" cv=""><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype><description><para>A std::string containing the name of the regular expression. </para></description></parameter><description><para>Return a reference to the named regular expression. If no such named regular expression exists, create a new regular expression and return a reference to it.</para><para>


</para></description><requires><para>The string is not empty. </para></requires><throws><simpara><classname>bad_alloc</classname> </simpara></throws></method><method name="operator[]" cv="const"><type><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><constructor><parameter name="traits"><paramtype>RegexTraits const &amp;</paramtype><default>RegexTraits()</default></parameter></constructor><method-group name="private member functions"><method name="is_upper_" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/xpressive/regex_constants.hpp"><para>Contains definitions for the syntax_option_type, match_flag_type and error_type enumerations. </para><namespace name="boost"><namespace name="xpressive"><namespace name="regex_constants"><enum name="syntax_option_type"><enumvalue name="ECMAScript"><default> 0</default><description><para>Specifies that the grammar recognized by the regular expression engine uses its normal semantics: that is the same as that given in the ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1). </para></description></enumvalue><enumvalue name="icase"><default> 1 &lt;&lt; 1</default><description><para>Specifies that matching of regular expressions against a character container sequence shall be performed without regard to case. </para></description></enumvalue><enumvalue name="nosubs"><default> 1 &lt;&lt; 2</default><description><para>Specifies that when a regular expression is matched against a character container sequence, then no sub-expression matches are to be stored in the supplied match_results structure. </para></description></enumvalue><enumvalue name="optimize"><default> 1 &lt;&lt; 3</default><description><para>Specifies that the regular expression engine should pay more attention to the speed with which regular expressions are matched, and less to the speed with which regular expression objects are constructed. Otherwise it has no detectable effect on the program output. </para></description></enumvalue><enumvalue name="collate"><default> 1 &lt;&lt; 4</default><description><para>Specifies that character ranges of the form "[a-b]" should be locale sensitive. </para></description></enumvalue><enumvalue name="single_line"><default> 1 &lt;&lt; 10</default><description><para>Specifies that the ^ and $ metacharacters DO NOT match at internal line breaks. Note that this is the opposite of the perl default. It is the inverse of perl's /m (multi-line) modifier. </para></description></enumvalue><enumvalue name="not_dot_null"><default> 1 &lt;&lt; 11</default><description><para>Specifies that the . metacharacter does not match the null character \0. </para></description></enumvalue><enumvalue name="not_dot_newline"><default> 1 &lt;&lt; 12</default><description><para>Specifies that the . metacharacter does not match the newline character \n. </para></description></enumvalue><enumvalue name="ignore_white_space"><default> 1 &lt;&lt; 13</default><description><para>Specifies that non-escaped white-space is not significant. </para></description></enumvalue><description><para>Flags used to customize the regex syntax </para></description></enum><enum name="match_flag_type"><enumvalue name="match_default"><default> 0</default><description><para>Specifies that matching of regular expressions proceeds without any modification of the normal rules used in ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1) </para></description></enumvalue><enumvalue name="match_not_bol"><default> 1 &lt;&lt; 1</default><description><para>Specifies that the expression "^" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue name="match_not_eol"><default> 1 &lt;&lt; 2</default><description><para>Specifies that the expression "\$" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue name="match_not_bow"><default> 1 &lt;&lt; 3</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue name="match_not_eow"><default> 1 &lt;&lt; 4</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue name="match_any"><default> 1 &lt;&lt; 7</default><description><para>Specifies that if more than one match is possible then any match is an acceptable result. </para></description></enumvalue><enumvalue name="match_not_null"><default> 1 &lt;&lt; 8</default><description><para>Specifies that the expression can not be matched against an empty sequence. </para></description></enumvalue><enumvalue name="match_continuous"><default> 1 &lt;&lt; 10</default><description><para>Specifies that the expression must match a sub-sequence that begins at first. </para></description></enumvalue><enumvalue name="match_partial"><default> 1 &lt;&lt; 11</default><description><para>Specifies that if no match can be found, then it is acceptable to return a match [from, last) where from != last, if there exists some sequence of characters [from,to) of which [from,last) is a prefix, and which would result in a full match. </para></description></enumvalue><enumvalue name="match_prev_avail"><default> 1 &lt;&lt; 12</default><description><para>Specifies that --first is a valid iterator position, when this flag is set then the flags match_not_bol and match_not_bow are ignored by the regular expression algorithms (RE.7) and iterators (RE.8). </para></description></enumvalue><enumvalue name="format_default"><default> 0</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace. (FWD.1). In addition during search and replace operations then all non-overlapping occurrences of the regular expression are located and replaced, and sections of the input that did not match the expression, are copied unchanged to the output string. </para></description></enumvalue><enumvalue name="format_sed"><default> 1 &lt;&lt; 13</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the Unix sed utility in IEEE Std 1003.1-2001, Portable Operating SystemInterface (POSIX), Shells and Utilities. </para></description></enumvalue><enumvalue name="format_perl"><default> 1 &lt;&lt; 14</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using an implementation defined superset of the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace (FWD.1). </para></description></enumvalue><enumvalue name="format_no_copy"><default> 1 &lt;&lt; 15</default><description><para>When specified during a search and replace operation, then sections of the character container sequence being searched that do match the regular expression, are not copied to the output string. </para></description></enumvalue><enumvalue name="format_first_only"><default> 1 &lt;&lt; 16</default><description><para>When specified during a search and replace operation, then only the first occurrence of the regular expression is replaced. </para></description></enumvalue><enumvalue name="format_literal"><default> 1 &lt;&lt; 17</default><description><para>Treat the format string as a literal. </para></description></enumvalue><enumvalue name="format_all"><default> 1 &lt;&lt; 18</default><description><para>Specifies that all syntax extensions are enabled, including conditional (?ddexpression1:expression2) replacements. </para></description></enumvalue><description><para>Flags used to customize the behavior of the regex algorithms </para></description></enum><enum name="error_type"><enumvalue name="error_collate"><description><para>The expression contained an invalid collating element name. </para></description></enumvalue><enumvalue name="error_ctype"><description><para>The expression contained an invalid character class name. </para></description></enumvalue><enumvalue name="error_escape"><description><para>The expression contained an invalid escaped character, or a trailing escape. </para></description></enumvalue><enumvalue name="error_subreg"><description><para>The expression contained an invalid back-reference. </para></description></enumvalue><enumvalue name="error_brack"><description><para>The expression contained mismatched [ and ]. </para></description></enumvalue><enumvalue name="error_paren"><description><para>The expression contained mismatched ( and ). </para></description></enumvalue><enumvalue name="error_brace"><description><para>The expression contained mismatched { and }. </para></description></enumvalue><enumvalue name="error_badbrace"><description><para>The expression contained an invalid range in a {} expression. </para></description></enumvalue><enumvalue name="error_range"><description><para>The expression contained an invalid character range, for example [b-a]. </para></description></enumvalue><enumvalue name="error_space"><description><para>There was insufficient memory to convert the expression into a finite state machine. </para></description></enumvalue><enumvalue name="error_badrepeat"><description><para>One of *?+{ was not preceded by a valid regular expression. </para></description></enumvalue><enumvalue name="error_complexity"><description><para>The complexity of an attempted match against a regular expression exceeded a pre-set level. </para></description></enumvalue><enumvalue name="error_stack"><description><para>There was insufficient memory to determine whether the regular expression could match the specified character sequence. </para></description></enumvalue><enumvalue name="error_badref"><description><para>An nested regex is uninitialized. </para></description></enumvalue><enumvalue name="error_badmark"><description><para>An invalid use of a named capture. </para></description></enumvalue><enumvalue name="error_badlookbehind"><description><para>An attempt to create a variable-width look-behind assertion was detected. </para></description></enumvalue><enumvalue name="error_badrule"><description><para>An invalid use of a rule was detected. </para></description></enumvalue><enumvalue name="error_badarg"><description><para>An argument to an action was unbound. </para></description></enumvalue><enumvalue name="error_badattr"><description><para>Tried to read from an uninitialized attribute. </para></description></enumvalue><enumvalue name="error_internal"><description><para>An internal error has occured. </para></description></enumvalue><description><para>Error codes used by the regex_error type </para></description></enum></namespace></namespace></namespace></header><header name="boost/xpressive/regex_error.hpp"><para>Contains the definition of the regex_error exception class. </para><namespace name="boost"><namespace name="xpressive"><struct name="regex_error"><inherit access="public">std::runtime_error</inherit><purpose>The class regex_error defines the type of objects thrown as exceptions to report errors during the conversion from a string representing a regular expression to a finite state machine. </purpose><method-group name="public member functions"><method name="code" cv="const"><type>regex_constants::error_type</type><description><para>Accessor for the error_type value 

</para></description><returns><para>the error_type code passed to the constructor </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group><constructor><parameter name="code"><paramtype>regex_constants::error_type</paramtype><description><para>The error_type this regex_error represents. </para></description></parameter><parameter name="str"><paramtype>char const *</paramtype><default>""</default></parameter><description><para>Constructs an object of class regex_error. 

</para></description><postconditions><para>code() == code </para></postconditions></constructor></struct></namespace></namespace></header><header name="boost/xpressive/regex_iterator.hpp"><para>Contains the definition of the regex_iterator type, an STL-compatible iterator for stepping through all the matches in a sequence. </para><namespace name="boost"><namespace name="xpressive"><struct name="regex_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><typedef name="regex_type"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type></typedef><typedef name="value_type"><type><classname>match_results</classname>&lt; BidiIter &gt;</type></typedef><typedef name="difference_type"><type>iterator_difference&lt; BidiIter &gt;::type</type></typedef><typedef name="pointer"><type><classname>value_type</classname> const *</type></typedef><typedef name="reference"><type><classname>value_type</classname> const &amp;</type></typedef><typedef name="iterator_category"><type>std::forward_iterator_tag</type></typedef><method-group name="public member functions"><method name="operator*" cv="const"><type><classname>value_type</classname> const &amp;</type></method><method name="operator-&gt;" cv="const"><type><classname>value_type</classname> const *</type></method><method name="operator++" cv=""><type><classname>regex_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then behaves as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If no further match is found then sets this equal to the end of sequence iterator. 
</para></description><postconditions><para>(*this)-&gt;size() == pre-&gt;mark_count() + 1 </para><para>(*this)-&gt;empty() == false </para><para>(*this)-&gt;prefix().first == An iterator denoting the end point of the previous match found </para><para>(*this)-&gt;prefix().last == (**this)[0].first </para><para>(*this)-&gt;prefix().matched == (*this)-&gt;prefix().first != (*this)-&gt;prefix().second </para><para>(*this)-&gt;suffix().first == (**this)[0].second </para><para>(*this)-&gt;suffix().last == end </para><para>(*this)-&gt;suffix().matched == (*this)-&gt;suffix().first != (*this)-&gt;suffix().second </para><para>(**this)[0].first == The starting iterator for this match. </para><para>(**this)[0].second == The ending iterator for this match. </para><para>(**this)[0].matched == true if a full match was found, and false if it was a partial match (found as a result of the match_partial flag being set). </para><para>(**this)[n].first == For all integers n &lt; (*this)-&gt;size(), the start of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para><para>(**this)[n].second == For all integers n &lt; (*this)-&gt;size(), the end of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para><para>(**this)[n].matched == For all integers n &lt; (*this)-&gt;size(), true if sub-expression n participated in the match, false otherwise. </para><para>(*this)-&gt;position() == The distance from the start of the original sequence being iterated, to the start of this match. </para></postconditions></method><method name="operator++" cv=""><type><classname>regex_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor><constructor><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor><constructor><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></constructor><copy-assignment><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></copy-assignment><method-group name="private member functions"/></struct></namespace></namespace></header><header name="boost/xpressive/regex_primitives.hpp"><para>Contains the syntax elements for writing static regular expressions. </para><namespace name="boost"><namespace name="xpressive"><data-member name="inf"><type>unsigned int const</type><purpose>For infinite repetition of a sub-expression. </purpose><description><para>Magic value used with the repeat&lt;&gt;() function template to specify an unbounded repeat. Use as: repeat&lt;17, inf&gt;('a'). The equivalent in perl is /a{17,}/. </para></description></data-member><data-member name="nil"><type><emphasis>unspecified</emphasis></type><purpose>Successfully matches nothing. </purpose><description><para>Successfully matches a zero-width sequence. nil always succeeds and never consumes any characters. </para></description></data-member><data-member name="alnum"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alpha-numeric character. </purpose><description><para>The regex traits are used to determine which characters are alpha-numeric. To match any character that is not alpha-numeric, use ~alnum.</para><para>
</para></description></data-member><data-member name="alpha"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alphabetic character. </purpose><description><para>The regex traits are used to determine which characters are alphabetic. To match any character that is not alphabetic, use ~alpha.</para><para>
</para></description></data-member><data-member name="blank"><type><emphasis>unspecified</emphasis></type><purpose>Matches a blank (horizonal white-space) character. </purpose><description><para>The regex traits are used to determine which characters are blank characters. To match any character that is not blank, use ~blank.</para><para>
</para></description></data-member><data-member name="cntrl"><type><emphasis>unspecified</emphasis></type><purpose>Matches a control character. </purpose><description><para>The regex traits are used to determine which characters are control characters. To match any character that is not a control character, use ~cntrl.</para><para>
</para></description></data-member><data-member name="digit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>The regex traits are used to determine which characters are digits. To match any character that is not a digit, use ~digit.</para><para>
</para></description></data-member><data-member name="graph"><type><emphasis>unspecified</emphasis></type><purpose>Matches a graph character. </purpose><description><para>The regex traits are used to determine which characters are graphable. To match any character that is not graphable, use ~graph.</para><para>
</para></description></data-member><data-member name="lower"><type><emphasis>unspecified</emphasis></type><purpose>Matches a lower-case character. </purpose><description><para>The regex traits are used to determine which characters are lower-case. To match any character that is not a lower-case character, use ~lower.</para><para>
</para></description></data-member><data-member name="print"><type><emphasis>unspecified</emphasis></type><purpose>Matches a printable character. </purpose><description><para>The regex traits are used to determine which characters are printable. To match any character that is not printable, use ~print.</para><para>
</para></description></data-member><data-member name="punct"><type><emphasis>unspecified</emphasis></type><purpose>Matches a punctuation character. </purpose><description><para>The regex traits are used to determine which characters are punctuation. To match any character that is not punctuation, use ~punct.</para><para>
</para></description></data-member><data-member name="space"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>The regex traits are used to determine which characters are space characters. To match any character that is not white-space, use ~space.</para><para>
</para></description></data-member><data-member name="upper"><type><emphasis>unspecified</emphasis></type><purpose>Matches an upper-case character. </purpose><description><para>The regex traits are used to determine which characters are upper-case. To match any character that is not upper-case, use ~upper.</para><para>
</para></description></data-member><data-member name="xdigit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a hexadecimal digit character. </purpose><description><para>The regex traits are used to determine which characters are hex digits. To match any character that is not a hex digit, use ~xdigit.</para><para>
</para></description></data-member><data-member name="bos"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'bos' matches the zero-width sub-sequence [begin, begin). </para></description></data-member><data-member name="eos"><type><emphasis>unspecified</emphasis></type><purpose>End of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'eos' matches the zero-width sub-sequence [end, end).</para><para>
</para></description></data-member><data-member name="bol"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of line assertion. </purpose><description><para>'bol' matches the zero-width sub-sequence immediately following a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member><data-member name="eol"><type><emphasis>unspecified</emphasis></type><purpose>End of line assertion. </purpose><description><para>'eol' matches the zero-width sub-sequence immediately preceeding a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member><data-member name="bow"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of word assertion. </purpose><description><para>'bow' matches the zero-width sub-sequence immediately following a non-word character and preceeding a word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member><data-member name="eow"><type><emphasis>unspecified</emphasis></type><purpose>End of word assertion. </purpose><description><para>'eow' matches the zero-width sub-sequence immediately following a word character and preceeding a non-word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member><data-member name="_b"><type><emphasis>unspecified</emphasis></type><purpose>Word boundary assertion. </purpose><description><para>'_b' matches the zero-width sub-sequence at the beginning or the end of a word. It is equivalent to (bow | eow). The regex traits are used to determine what constitutes a word character. To match a non-word boundary, use ~_b.</para><para>
</para></description></data-member><data-member name="_w"><type><emphasis>unspecified</emphasis></type><purpose>Matches a word character. </purpose><description><para>'_w' matches a single word character. The regex traits are used to determine which characters are word characters. Use ~_w to match a character that is not a word character.</para><para>
</para></description></data-member><data-member name="_d"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>'_d' matches a single digit character. The regex traits are used to determine which characters are digits. Use ~_d to match a character that is not a digit character.</para><para>
</para></description></data-member><data-member name="_s"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>'_s' matches a single space character. The regex traits are used to determine which characters are space characters. Use ~_s to match a character that is not a space character.</para><para>
</para></description></data-member><data-member name="_n"><type>proto::terminal&lt; char &gt;::type const</type><purpose>Matches a literal newline character, '\n'. </purpose><description><para>'_n' matches a single newline character, '\n'. Use ~_n to match a character that is not a newline.</para><para>
</para></description></data-member><data-member name="_ln"><type><emphasis>unspecified</emphasis></type><purpose>Matches a logical newline sequence. </purpose><description><para>'_ln' matches a logical newline sequence. This can be any character in the line separator class, as determined by the regex traits, or the '\r\n' sequence. For the purpose of back-tracking, '\r\n' is treated as a unit. To match any one character that is not a logical newline, use ~_ln. </para></description></data-member><data-member name="_"><type><emphasis>unspecified</emphasis></type><purpose>Matches any one character. </purpose><description><para>Match any character, similar to '.' in perl syntax with the /s modifier. '_' matches any one character, including the newline.</para><para>
</para></description></data-member><data-member name="self"><type><emphasis>unspecified</emphasis></type><purpose>Reference to the current regex object. </purpose><description><para>Useful when constructing recursive regular expression objects. The 'self' identifier is a short-hand for the current regex object. For instance, sregex rx = '(' &gt;&gt; (self | nil) &gt;&gt; ')'; will create a regex object that matches balanced parens such as "((()))". </para></description></data-member><data-member name="set"><type><emphasis>unspecified</emphasis></type><purpose>Used to create character sets. </purpose><description><para>There are two ways to create character sets with the 'set' identifier. The easiest is to create a comma-separated list of the characters in the set, as in (set= 'a','b','c'). This set will match 'a', 'b', or 'c'. The other way is to define the set as an argument to the set subscript operator. For instance, set[ 'a' | range('b','c') | digit ] will match an 'a', 'b', 'c' or a digit character.</para><para>To complement a set, apply the '~' operator. For instance, ~(set= 'a','b','c') will match any character that is not an 'a', 'b', or 'c'.</para><para>Sets can be composed of other, possibly complemented, sets. For instance, set[ ~digit | ~(set= 'a','b','c') ]. </para></description></data-member><data-member name="s0"><type>mark_tag::proto_base_expr const</type><purpose>Sub-match placeholder, like $&amp; in Perl. </purpose></data-member><data-member name="s1"><type>mark_tag::proto_base_expr const</type><purpose>Sub-match placeholder, like $1 in perl. </purpose><description><para>To create a sub-match, assign a sub-expression to the sub-match placeholder. For instance, (s1= _) will match any one character and remember which character was matched in the 1st sub-match. Later in the pattern, you can refer back to the sub-match. For instance, (s1= _) &gt;&gt; s1 will match any character, and then match the same character again.</para><para>After a successful regex_match() or regex_search(), the sub-match placeholders can be used to index into the match_results&lt;&gt; object to retrieve the Nth sub-match. </para></description></data-member><data-member name="s2"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s3"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s4"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s5"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s6"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s7"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s8"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="s9"><type>mark_tag::proto_base_expr const</type></data-member><data-member name="a1"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a2"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a3"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a4"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a5"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a6"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a7"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a8"><type><emphasis>unspecified</emphasis></type></data-member><data-member name="a9"><type><emphasis>unspecified</emphasis></type></data-member><function name="icase"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>Makes a sub-expression case-insensitive. </purpose><description><para>Use icase() to make a sub-expression case-insensitive. For instance, "foo" &gt;&gt; icase(set['b'] &gt;&gt; "ar") will match "foo" exactly followed by "bar" irrespective of case. </para></description></function><function name="as_xpr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Literal"/>
        </template><parameter name="literal"><paramtype>Literal const &amp;</paramtype></parameter><purpose>Makes a literal into a regular expression. </purpose><description><para>Use as_xpr() to turn a literal into a regular expression. For instance, "foo" &gt;&gt; "bar" will not compile because both operands to the right-shift operator are const char*, and no such operator exists. Use as_xpr("foo") &gt;&gt; "bar" instead.</para><para>You can use as_xpr() with character literals in addition to string literals. For instance, as_xpr('a') will match an 'a'. You can also complement a character literal, as with ~as_xpr('a'). This will match any one character that is not an 'a'. </para></description></function><function name="by_ref"><type>proto::terminal&lt; reference_wrapper&lt; <classname>basic_regex</classname>&lt; BidiIter &gt; const  &gt; &gt;::type const</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The basic_regex object to embed by reference. </para></description></parameter><purpose>Embed a regex object by reference. </purpose><description><para>
</para></description></function><function name="range"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="ch_min"><paramtype>Char</paramtype><description><para>The lower end of the range to match. </para></description></parameter><parameter name="ch_max"><paramtype>Char</paramtype><description><para>The upper end of the range to match. </para></description></parameter><purpose>Match a range of characters. </purpose><description><para>Match any character in the range [ch_min, ch_max].</para><para>
</para></description></function><function name="optional"><type>proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Expr const &amp; &gt;::type const</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to make optional. </para></description></parameter><purpose>Make a sub-expression optional. Equivalent to !as_xpr(expr). </purpose><description><para>
</para></description></function><overloaded-function name="repeat"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Min"><type>unsigned int</type></template-nontype-parameter>
          <template-nontype-parameter name="Max"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to repeat. </para></description></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Count"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr2"/>
        </template><parameter name="expr2"><paramtype>Expr2 const &amp;</paramtype></parameter></signature><purpose>Repeat a sub-expression multiple times. </purpose><description><para>There are two forms of the repeat&lt;&gt;() function template. To match a sub-expression N times, use repeat&lt;N&gt;(expr). To match a sub-expression from M to N times, use repeat&lt;M,N&gt;(expr).</para><para>The repeat&lt;&gt;() function creates a greedy quantifier. To make the quantifier non-greedy, apply the unary minus operator, as in -repeat&lt;M,N&gt;(expr).</para><para>
</para></description></overloaded-function><function name="keep"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to modify. </para></description></parameter><purpose>Create an independent sub-expression. </purpose><description><para>Turn off back-tracking for a sub-expression. Any branches or repeats within the sub-expression will match only one way, and no other alternatives are tried.</para><para>

</para></description><notes><para>keep(expr) is equivalent to the perl (?&gt;...) extension.</para></notes></function><function name="before"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion. </para></description></parameter><purpose>Look-ahead assertion. </purpose><description><para>before(expr) succeeds if the expr sub-expression would match at the current position in the sequence, but expr is not included in the match. For instance, before("foo") succeeds if we are before a "foo". Look-ahead assertions can be negated with the bit-compliment operator.</para><para>

</para></description><notes><para>before(expr) is equivalent to the perl (?=...) extension. ~before(expr) is a negative look-ahead assertion, equivalent to the perl (?!...) extension.</para></notes></function><function name="after"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion.</para></description></parameter><purpose>Look-behind assertion. </purpose><description><para>after(expr) succeeds if the expr sub-expression would match at the current position minus N in the sequence, where N is the width of expr. expr is not included in the match. For instance, after("foo") succeeds if we are after a "foo". Look-behind assertions can be negated with the bit-complement operator.</para><para>


</para></description><requires><para>expr cannot match a variable number of characters. </para></requires><notes><para>after(expr) is equivalent to the perl (?&lt;=...) extension. ~after(expr) is a negative look-behind assertion, equivalent to the perl (?&lt;!...) extension.</para></notes></function><function name="imbue"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Locale"/>
        </template><parameter name="loc"><paramtype>Locale const &amp;</paramtype><description><para>The std::locale or regex traits object. </para></description></parameter><purpose>Specify a regex traits or a std::locale. </purpose><description><para>imbue() instructs the regex engine to use the specified traits or locale when matching the regex. The entire expression must use the same traits/locale. For instance, the following specifies a locale for use with a regex: std::locale loc; sregex rx = imbue(loc)(+digit);</para><para>
</para></description></function><function name="skip"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Skip"/>
        </template><parameter name="skip"><paramtype>Skip const &amp;</paramtype><description><para>A regex that specifies which characters to skip. </para></description></parameter><purpose>Specify which characters to skip when matching a regex. </purpose><description><para><computeroutput>skip()</computeroutput> instructs the regex engine to skip certain characters when matching a regex. It is most useful for writing regexes that ignore whitespace. For instance, the following specifies a regex that skips whitespace and punctuation:</para><para><programlisting> // A sentence is one or more words separated by whitespace
 // and punctuation.
 sregex word = +alpha;
 sregex sentence = skip(set[_s | punct])( +word );
</programlisting></para><para>The way it works in the above example is to insert <computeroutput>keep(*set[_s | punct])</computeroutput> before each primitive within the regex. A "primitive" includes terminals like strings, character sets and nested regexes. A final <computeroutput>*set[_s | punct]</computeroutput> is added to the end of the regex. The regex <computeroutput>sentence</computeroutput> specified above is equivalent to the following:</para><para><programlisting> sregex sentence = +( keep(*set[_s | punct]) &gt;&gt; word )
                        &gt;&gt; *set[_s | punct];
</programlisting></para><para>

</para></description><notes><para>Skipping does not affect how nested regexes are handled because they are treated atomically. String literals are also treated atomically; that is, no skipping is done within a string literal. So <computeroutput>skip(_s)("this that")</computeroutput> is not the same as <computeroutput>skip(_s)("this" &gt;&gt; as_xpr("that"))</computeroutput>. The first will only match when there is only one space between "this" and "that". The second will skip any and all whitespace between "this" and "that".</para></notes></function></namespace></namespace></header><header name="boost/xpressive/regex_token_iterator.hpp"><para>Contains the definition of regex_token_iterator, and STL-compatible iterator for tokenizing a string using a regular expression. </para><namespace name="boost"><namespace name="xpressive"><struct name="regex_token_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><typedef name="regex_type"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type></typedef><typedef name="char_type"><type>iterator_value&lt; BidiIter &gt;::type</type></typedef><typedef name="value_type"><type><classname>sub_match</classname>&lt; BidiIter &gt;</type></typedef><typedef name="difference_type"><type>std::ptrdiff_t</type></typedef><typedef name="pointer"><type><classname>value_type</classname> const *</type></typedef><typedef name="reference"><type><classname>value_type</classname> const &amp;</type></typedef><typedef name="iterator_category"><type>std::forward_iterator_tag</type></typedef><method-group name="public member functions"><method name="operator*" cv="const"><type><classname>value_type</classname> const &amp;</type></method><method name="operator-&gt;" cv="const"><type><classname>value_type</classname> const *</type></method><method name="operator++" cv=""><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If N == -1 then sets *this equal to the end of sequence iterator. Otherwise if N+1 &lt; subs.size(), then increments N and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())). Otherwise if what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then locates the next match as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If such a match is found then sets N equal to zero, and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())). Otherwise if no further matches were found, then let last_end be the endpoint of the last match that was found. Then if last_end != end and subs[0] == -1 sets N equal to -1 and sets result equal to value_type(last_end, end). Otherwise sets *this equal to the end of sequence iterator. </para></description></method><method name="operator++" cv=""><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method></method-group><constructor><description><para>
</para></description><postconditions><para><computeroutput>*this</computeroutput> is the end of sequence iterator. </para></postconditions></constructor><constructor><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para></requires></constructor><constructor><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A let() expression with argument bindings for semantic actions. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para></requires></constructor><constructor><template>
          <template-type-parameter name="Subs"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para></requires></constructor><constructor><template>
          <template-type-parameter name="Subs"/>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A let() expression with argument bindings for semantic actions. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para></requires></constructor><constructor><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></constructor><copy-assignment><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></copy-assignment><method-group name="private member functions"/></struct></namespace></namespace></header><header name="boost/xpressive/regex_traits.hpp"><para>Includes the C regex traits or the CPP regex traits header file depending on the BOOST_XPRESSIVE_USE_C_TRAITS macro. </para><namespace name="boost"><namespace name="xpressive"><struct name="regex_traits_version_1_tag"><description><para>Tag used to denote that a traits class conforms to the version 1 traits interface. </para></description></struct><struct name="regex_traits_version_2_tag"><inherit access="public">boost::xpressive::regex_traits_version_1_tag</inherit><description><para>Tag used to denote that a traits class conforms to the version 2 traits interface. </para></description></struct><struct name="has_fold_case"><template>
      <template-type-parameter name="Traits"/>
    </template><purpose>Trait used to denote that a traits class has the fold_case member function. </purpose></struct><struct name="regex_traits"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Impl"/>
    </template><description><para>Thin wrapper around the default regex_traits implementation, either cpp_regex_traits or c_regex_traits </para></description><typedef name="locale_type"><type>Impl::locale_type</type></typedef><method-group name="public member functions"/><constructor/><constructor><parameter name="loc"><paramtype>locale_type const &amp;</paramtype></parameter></constructor></struct></namespace></namespace></header><header name="boost/xpressive/sub_match.hpp"><para>Contains the definition of the class template sub_match&lt;&gt; and associated helper functions </para><namespace name="boost"><namespace name="xpressive"><struct name="sub_match"><template>
      <template-type-parameter name="BidiIter"/>
    </template><inherit access="public">std::pair&lt; BidiIter, BidiIter &gt;</inherit><purpose>Class template sub_match denotes the sequence of characters matched by a particular marked sub-expression. </purpose><description><para>When the marked sub-expression denoted by an object of type sub_match&lt;&gt; participated in a regular expression match then member matched evaluates to true, and members first and second denote the range of characters [first,second) which formed that match. Otherwise matched is false, and members first and second contained undefined values.</para><para>If an object of type sub_match&lt;&gt; represents sub-expression 0 - that is to say the whole match - then member matched is always true, unless a partial match was obtained as a result of the flag match_partial being passed to a regular expression algorithm, in which case member matched is false, and members first and second represent the character range that formed the partial match. </para></description><typedef name="value_type"><type>iterator_value&lt; BidiIter &gt;::type</type></typedef><typedef name="difference_type"><type>iterator_difference&lt; BidiIter &gt;::type</type></typedef><typedef name="string_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="iterator"><type>BidiIter</type></typedef><data-member name="matched"><type>bool</type><purpose>true if this sub-match participated in the full match. </purpose></data-member><method-group name="public member functions"><method name="str" cv="const"><type>string_type</type></method><method name="conversion-operator" cv="const"><type>string_type</type></method><method name="length" cv="const"><type>difference_type</type></method><method name="conversion-operator" cv="const"><type>bool_type</type></method><method name="operator!" cv="const"><type>bool</type></method><method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>string_type const &amp;</paramtype><description><para>the string against which to compare </para></description></parameter><purpose>Performs a lexicographic string comparison. </purpose><description><para>

</para></description><returns><para>the results of (*this).str().compare(str) </para></returns></method><method name="compare" cv="const"><type>int</type><parameter name="sub"><paramtype><classname>sub_match</classname> const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="compare" cv="const"><type>int</type><parameter name="ptr"><paramtype>value_type const *</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><constructor/><constructor><parameter name="first"><paramtype>BidiIter</paramtype></parameter><parameter name="second"><paramtype>BidiIter</paramtype></parameter><parameter name="matched_"><paramtype>bool</paramtype><default>false</default></parameter></constructor></struct><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
        </template><parameter name="sout"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype><description><para>output stream. </para></description></parameter><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>sub_match object to be written to the stream. </para></description></parameter><purpose>insertion operator for sending sub-matches to ostreams </purpose><description><para>

</para></description><returns><para>sout &lt;&lt; sub.str() </para></returns></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter></function><function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/traits/c_regex_traits.hpp"><para>Contains the definition of the c_regex_traits&lt;&gt; template, which is a wrapper for the C locale functions that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost"><namespace name="xpressive"><struct name="c_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates the standard C locale functions for use by the basic_regex&lt;&gt; class template. </purpose><typedef name="char_type"><type>Char</type></typedef><typedef name="string_type"><type>std::basic_string&lt; char_type &gt;</type></typedef><typedef name="locale_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="char_class_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="version_tag"><type><classname>regex_traits_version_2_tag</classname></type></typedef><typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two c_regex_traits objects for equality</para><para>
</para></description><returns><para>true. </para></returns></method><method name="operator!=" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two c_regex_traits objects for inequality</para><para>
</para></description><returns><para>false. </para></returns></method><method name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a string_type containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if has_fold_case&lt;c_regex_traits&lt;Char&gt; &gt;value is true.</para><para>

</para></description><returns><para>string_type containing all chars which are equal to ch when disregarding case </para></returns></method><method name="imbue" cv=""><type><classname>locale_type</classname></type><parameter name="loc"><paramtype><classname>locale_type</classname></paramtype></parameter><description><para>No-op </para></description></method><method name="widen" cv=""><type>char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method><method name="widen" cv=""><type>wchar_t</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter></method><method name="value" cv=""><type>int</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter><parameter name="radix"><paramtype>int</paramtype></parameter></method><method name="value" cv=""><type>int</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter><parameter name="radix"><paramtype>int</paramtype></parameter></method></method-group><constructor><parameter name="loc"><paramtype><classname>locale_type</classname> const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a c_regex_traits object to use the global C locale. </para></description></constructor><method-group name="public static functions"><method name="widen" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>ch if Char is char, std::btowc(ch) if Char is wchar_t. </para></returns></method><method name="hash" cv=""><type>static unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method><method name="translate" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method><method name="translate_nocase" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para></returns></method><method name="tolower" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para></returns></method><method name="toupper" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the current global C locale.</para><para>

</para></description><returns><para>std::toupper(ch) if Char is char, std::towupper(ch) if Char is wchar_t. </para></returns></method><method name="in_range" cv=""><type>static bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method><method name="in_range_nocase" cv=""><type>static bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>


</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch)) || in_range(first, last, toupper(ch)) </para></returns><notes><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard C locale functions. </para></notes></method><method name="transform" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="transform_primary" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_collatename" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_classname" cv=""><type>static char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para></returns></method><method name="isctype" cv=""><type>static bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para></requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para></returns></method><method name="value" cv=""><type>static int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para></requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. If char_type is char, std::strtol is used for the conversion. If char_type is wchar_t, std::wcstol is used. </para></returns></method><method name="getloc" cv=""><type>static <classname>locale_type</classname></type><description><para>No-op </para></description></method></method-group></struct><struct-specialization name="has_fold_case"><template>
    </template><specialization><template-arg>c_regex_traits&lt; char &gt;</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/xpressive/traits/cpp_regex_traits.hpp"><para>Contains the definition of the cpp_regex_traits&lt;&gt; template, which is a wrapper for std::locale that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost"><namespace name="xpressive"><struct name="cpp_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates a std::locale for use by the basic_regex&lt;&gt; class template. </purpose><typedef name="char_type"><type>Char</type></typedef><typedef name="string_type"><type>std::basic_string&lt; char_type &gt;</type></typedef><typedef name="locale_type"><type>std::locale</type></typedef><typedef name="char_class_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="version_tag"><type><classname>regex_traits_version_2_tag</classname></type></typedef><typedef name="base_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two cpp_regex_traits objects for equality</para><para>
</para></description><returns><para>this-&gt;getloc() == that.getloc(). </para></returns></method><method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two cpp_regex_traits objects for inequality</para><para>
</para></description><returns><para>this-&gt;getloc() != that.getloc(). </para></returns></method><method name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>std::use_facet&lt;std::ctype&lt;char_type&gt; &gt;(this-&gt;getloc()).widen(ch). </para></returns></method><method name="translate_nocase" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;getloc()). </para></returns></method><method name="tolower" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;getloc()). </para></returns></method><method name="toupper" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::toupper(ch, this-&gt;getloc()). </para></returns></method><method name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a string_type containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if has_fold_case&lt;cpp_regex_traits&lt;Char&gt; &gt;value is true.</para><para>

</para></description><returns><para>string_type containing all chars which are equal to ch when disregarding case </para></returns></method><method name="in_range_nocase" cv="const"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>


</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch, this-&gt;getloc())) || in_range(first, last, toupper(ch, this-&gt;getloc())) </para></returns><notes><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard ctype facet. </para></notes></method><method name="transform_primary" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_collatename" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_classname" cv="const"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para></returns></method><method name="isctype" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para></requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para></returns></method><method name="value" cv="const"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para></requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. The conversion is performed by imbueing a std::stringstream with this-&gt;getloc(); setting the radix to one of oct, hex or dec; inserting ch into the stream; and extracting an int. </para></returns></method><method name="imbue" cv=""><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>A std::locale. </para></description></parameter><description><para>Imbues *this with loc</para><para>

</para></description><returns><para>the previous std::locale used by *this. </para></returns></method><method name="getloc" cv="const"><type>locale_type</type><description><para>Returns the current std::locale used by *this. </para></description></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>unsigned char</paramtype></parameter></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>signed char</paramtype></parameter></method><method name="hash" cv=""><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter></method></method-group><constructor><parameter name="loc"><paramtype>locale_type const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a cpp_regex_traits object to use the specified std::locale, or the global std::locale if none is specified. </para></description></constructor><method-group name="public static functions"><method name="hash" cv=""><type>static unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method><method name="translate" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method><method name="in_range" cv=""><type>static bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method></method-group><method-group name="private static functions"/></struct><struct-specialization name="has_fold_case"><template>
    </template><specialization><template-arg>cpp_regex_traits&lt; char &gt;</template-arg></specialization></struct-specialization></namespace></namespace></header><header name="boost/xpressive/traits/null_regex_traits.hpp"><para>Contains the definition of the null_regex_traits&lt;&gt; template, which is a stub regex traits implementation that can be used by static and dynamic regexes for searching non-character data. </para><namespace name="boost"><namespace name="xpressive"><struct name="null_regex_traits"><template>
      <template-type-parameter name="Elem"/>
    </template><purpose>stub regex_traits for non-char data </purpose><typedef name="char_type"><type>Elem</type></typedef><typedef name="string_type"><type>std::vector&lt; char_type &gt;</type></typedef><typedef name="locale_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="char_class_type"><type>int</type></typedef><typedef name="version_tag"><type><classname>regex_traits_version_1_tag</classname></type></typedef><method-group name="public member functions"><method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two null_regex_traits objects for equality</para><para>
</para></description><returns><para>true. </para></returns></method><method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two null_regex_traits objects for inequality</para><para>
</para></description><returns><para>false. </para></returns></method><method name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Elem</para><para>

</para></description><returns><para>Elem(ch). </para></returns></method></method-group><constructor><parameter name=""><paramtype><classname>locale_type</classname></paramtype><default>locale_type()</default></parameter><description><para>Initialize a null_regex_traits object. </para></description></constructor><method-group name="public static functions"><method name="hash" cv=""><type>static unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Elem in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method><method name="translate" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method><method name="translate_nocase" cv=""><type>static char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method><method name="in_range" cv=""><type>static bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method><method name="in_range_nocase" cv=""><type>static bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>


</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns><notes><para>Since the null_regex_traits does not do case-folding, this function is equivalent to in_range(). </para></notes></method><method name="transform" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="transform_primary" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_collatename" cv=""><type>static string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para>
</para></description><notes><para>Not currently used </para></notes></method><method name="lookup_classname" cv=""><type>static char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>not used </para></description></parameter><description><para>The null_regex_traits does not have character classifications, so lookup_classname() is unused.</para><para>

</para></description><returns><para>static_cast&lt;char_class_type&gt;(0) </para></returns></method><method name="isctype" cv=""><type>static bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>not used </para></description></parameter><description><para>The null_regex_traits does not have character classifications, so isctype() is unused.</para><para>

</para></description><returns><para>false </para></returns></method><method name="value" cv=""><type>static int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>not used </para></description></parameter><description><para>The null_regex_traits recognizes no elements as digits, so value() is unused.</para><para>

</para></description><returns><para>-1 </para></returns></method><method name="imbue" cv=""><type>static <classname>locale_type</classname></type><parameter name="loc"><paramtype><classname>locale_type</classname></paramtype><description><para>not used </para></description></parameter><description><para>Not used</para><para>

</para></description><returns><para>loc </para></returns></method><method name="getloc" cv=""><type>static <classname>locale_type</classname></type><description><para>Returns locale_type().</para><para>
</para></description><returns><para>locale_type() </para></returns></method></method-group></struct></namespace></namespace></header><header name="boost/xpressive/xpressive.hpp"><para>Includes all of xpressive including support for both static and dynamic regular expressions. </para></header><header name="boost/xpressive/xpressive_dynamic.hpp"><para>Includes everything you need to write and use dynamic regular expressions. </para></header><header name="boost/xpressive/xpressive_fwd.hpp"><para>Forward declarations for all of xpressive's public data types. </para><namespace name="boost"><namespace name="xpressive"><typedef name="regex_id_type"><type>void const *</type></typedef><typedef name="sregex"><type><classname>basic_regex</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cregex"><type><classname>basic_regex</classname>&lt; char const * &gt;</type></typedef><typedef name="wsregex"><type><classname>basic_regex</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcregex"><type><classname>basic_regex</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="ssub_match"><type><classname>sub_match</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="csub_match"><type><classname>sub_match</classname>&lt; char const * &gt;</type></typedef><typedef name="wssub_match"><type><classname>sub_match</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcsub_match"><type><classname>sub_match</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="sregex_compiler"><type><classname>regex_compiler</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cregex_compiler"><type><classname>regex_compiler</classname>&lt; char const * &gt;</type></typedef><typedef name="wsregex_compiler"><type><classname>regex_compiler</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcregex_compiler"><type><classname>regex_compiler</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="sregex_iterator"><type><classname>regex_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cregex_iterator"><type><classname>regex_iterator</classname>&lt; char const * &gt;</type></typedef><typedef name="wsregex_iterator"><type><classname>regex_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcregex_iterator"><type><classname>regex_iterator</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="sregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; char const * &gt;</type></typedef><typedef name="wsregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="smatch"><type><classname>match_results</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cmatch"><type><classname>match_results</classname>&lt; char const * &gt;</type></typedef><typedef name="wsmatch"><type><classname>match_results</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcmatch"><type><classname>match_results</classname>&lt; wchar_t const * &gt;</type></typedef><typedef name="sregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::string::const_iterator &gt;</type></typedef><typedef name="cregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; char const * &gt;</type></typedef><typedef name="wsregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::wstring::const_iterator &gt;</type></typedef><typedef name="wcregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; wchar_t const * &gt;</type></typedef></namespace></namespace><macro name="BOOST_PROTO_FUSION_V2"/><macro name="BOOST_XPRESSIVE_HAS_MS_STACK_GUARD"/></header><header name="boost/xpressive/xpressive_static.hpp"><para>Includes everything you need to write static regular expressions and use them. </para></header><header name="boost/xpressive/xpressive_typeof.hpp"><para>Type registrations so that xpressive can be used with the Boost.Typeof library. </para></header></library-reference>

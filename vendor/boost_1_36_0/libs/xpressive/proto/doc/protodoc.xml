<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/proto/args.hpp"><para>Contains definition of args&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><namespace name="argsns_"><struct name="args0"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args1"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args2"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args3"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args4"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args5"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>Arg4</type></typedef></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context.hpp"><para>Includes all the context classes in the context/ sub-directory. </para></header><header name="boost/xpressive/proto/context/callable.hpp"><para>Definintion of callable_context&lt;&gt;, an evaluation context for proto::eval() that explodes each node and calls the derived context type with the expressions constituents. If the derived context doesn't have an overload that handles this node, fall-back to the default_context. TODO: make the fall-back configurable! </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template><description><para>callable_eval </para></description></struct><struct name="callable_context"><template>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="DefaultCtx"/>
    </template><description><para>callable_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>Context</default></template-type-parameter>
    </template><description><para>callable_context::eval </para></description></struct></struct><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 4 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context/default.hpp"><para>Definintion of default_context, a default evaluation context for proto::eval() that uses Boost.Typeof to deduce return types of the built-in operators. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="Tag"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template></struct><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::posit</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::terminal</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>mpl::if_&lt; is_const&lt; Expr &gt;, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::const_reference, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::reference &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::if_else_</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::comma</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>0</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::arg_c&lt; Expr, 4 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="default_context"><description><para>default_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>default_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::default_eval&lt; Expr, ThisContext &gt;</inherit><description><para>default_context::eval </para></description></struct></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context/null.hpp"><para>Definintion of null_context&lt;&gt;, an evaluation context for proto::eval() that simply evaluates each child expression, doesn't combine the results at all, and returns void. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template></struct><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name=""><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="null_context"><description><para>null_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>null_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::null_eval&lt; Expr, ThisContext &gt;</inherit><description><para>null_context::eval </para></description></struct></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/debug.hpp"><para>Utilities for debugging Proto expression trees </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="display_expr"><purpose>Pretty-print a Proto expression tree. </purpose><description><para>A PolymorphicFunctionObject which accepts a Proto expression tree and pretty-prints it to an <computeroutput>ostream</computeroutput> for debugging purposes. </para></description><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; <classname>tag::terminal</classname>, Args, 0 &gt; const &amp;</paramtype></parameter><purpose>Pretty-print the current node in a Proto expression tree. </purpose></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 0 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><constructor><parameter name="depth"><paramtype>int</paramtype><default>0</default><description><para>The starting indentation depth for this node. Children nodes will be displayed at a starting depth of <computeroutput>depth+4</computeroutput>. </para></description></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default><description><para>The <computeroutput>ostream</computeroutput> to which the expression tree will be written. </para></description></parameter><description><para>
</para></description></constructor><method-group name="private member functions"/><copy-assignment><parameter name=""><paramtype><classname>display_expr</classname> const &amp;</paramtype></parameter></copy-assignment></struct></namespace><namespace name="tag"><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::posit</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::negate</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::dereference</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::complement</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::address_of</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_not</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::not_equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::comma</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::mem_ptr</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subscript</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::if_else_</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::function</classname></paramtype></parameter></function></namespace><overloaded-function name="display_expr"><signature><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The Proto expression tree to pretty-print </para></description></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><description><para>The <computeroutput>ostream</computeroutput> to which the output should be written. </para></description></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Pretty-print a Proto expression tree. </purpose><description><para>

</para></description><notes><para>Equivalent to <computeroutput>functional::display_expr(0, sout)(expr)</computeroutput> </para></notes></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/deep_copy.hpp"><para>Replace all nodes stored by reference by nodes stored by value. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="deep_copy"><purpose>A PolymorphicFunctionObject type for deep-copying Proto expression trees. </purpose><description><para>A PolymorphicFunctionObject type for deep-copying Proto expression trees. When a tree is deep-copied, all internal nodes and most terminals held by reference are instead held by value.</para><para>
</para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::deep_copy</classname>&lt; typename boost::remove_const&lt; typename boost::remove_reference&lt; Expr &gt;::type &gt;::type &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>Deep-copies a Proto expression tree, turning all nodes and terminals held by reference into ones held by value. </purpose></method></method-group></struct></namespace><namespace name="result_of"><struct name="deep_copy"><template>
      <template-type-parameter name="Expr"/>
    </template><purpose>A metafunction for calculating the return type of <computeroutput>proto::deep_copy()</computeroutput>. </purpose><description><para>A metafunction for calculating the return type of <computeroutput>proto::deep_copy()</computeroutput>. The type parameter <computeroutput>Expr</computeroutput> should be the type of a Proto expression tree. It should not be a reference type, nor should it be cv-qualified. </para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace><data-member name="deep_copy"><type><classname>functional::deep_copy</classname> const</type><purpose>A PolymorphicFunctionObject for deep-copying Proto expression trees. </purpose><description><para>A PolymorphicFunctionObject for deep-copying Proto expression trees. When a tree is deep-copied, all internal nodes and most terminals held by reference are instead held by value.</para><para>
<para>proto::functional::deep_copy. </para>
</para></description></data-member></namespace></namespace></header><header name="boost/xpressive/proto/domain.hpp"><para>Contains definition of domain&lt;&gt; class template and helpers for defining domains with a generator and a grammar for controlling operator overloading. </para><namespace name="boost"><namespace name="proto"><namespace name="domainns_"><struct name="domain"><template>
      <template-type-parameter name="Generator"/>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">Generator</inherit><purpose>For use in defining domain tags to be used with <computeroutput>proto::extends&lt;&gt;</computeroutput>. A Domain associates an expression type with a Generator, and optionally a Grammar. </purpose><description><para>The Generator determines how new expressions in the domain are constructed. Typically, a generator wraps all new expressions in a wrapper that imparts domain-specific behaviors to expressions within its domain. (See <computeroutput>proto::extends&lt;&gt;</computeroutput>.)</para><para>The Grammar determines whether a given expression is valid within the domain, and automatically disables any operator overloads which would cause an invalid expression to be created. By default, the Grammar parameter defaults to the wildcard, <computeroutput>proto::_</computeroutput>, which makes all expressions valid within the domain.</para><para>Example: <programlisting> template&lt;typename Expr&gt;
 struct MyExpr;

 struct MyGrammar
   : or_&lt; terminal&lt;_&gt;, plus&lt;MyGrammar, MyGrammar&gt; &gt;
 {};

 // Define MyDomain, in which all expressions are
 // wrapped in MyExpr&lt;&gt; and only expressions that
 // conform to MyGrammar are allowed.
 struct MyDomain
   : domain&lt;generator&lt;MyExpr&gt;, MyGrammar&gt;
 {};

 // Use MyDomain to define MyExpr
 template&lt;typename Expr&gt;
 struct MyExpr
   : extends&lt;Expr, MyExpr&lt;Expr&gt;, MyDomain&gt;
 {
     // ...
 };
</programlisting> </para></description><typedef name="proto_grammar"><type>Grammar</type></typedef></struct><struct name="default_domain"><inherit access="public">boost::proto::domainns_::domain&lt;  &gt;</inherit><purpose>The domain expressions have by default, if <computeroutput>proto::extends&lt;&gt;</computeroutput> has not been used to associate a domain with an expression. </purpose></struct><struct name="deduce_domain"><inherit access="public">boost::proto::domainns_::domain&lt; Generator, Grammar &gt;</inherit><purpose>A pseudo-domain for use in functions and metafunctions that require a domain parameter. It indicates that the domain of the parent node should be inferred from the domains of the children nodes. </purpose><description><para>
</para></description></struct></namespace><namespace name="result_of"><struct name="is_domain"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">boost::mpl::false_</inherit><description><para>A metafunction that returns <computeroutput>mpl::true_</computeroutput> if the type <computeroutput>T</computeroutput> is the type of a Proto domain; <computeroutput>mpl::false_</computeroutput> otherwise. If <computeroutput>T</computeroutput> inherits from <computeroutput>proto::domain&lt;&gt;</computeroutput>, <computeroutput>is_domain&lt;T&gt;</computeroutput> is <computeroutput>mpl::true_</computeroutput>. </para></description></struct><struct name="domain_of"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><description><para>A metafunction that returns the domain of a given type. If <computeroutput>T</computeroutput> is a Proto expression type, it returns that expression's associated domain. If not, it returns <computeroutput>proto::default_domain</computeroutput>. </para></description><typedef name="type"><type>default_domain</type></typedef></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/eval.hpp"><para>Contains the eval() expression evaluator. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="eval"><purpose>A PolymorphicFunctionObject type for evaluating a given Proto expression with a given context. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>Context)</template-arg></specialization><typedef name="type"><type><classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; Expr &gt;::type, typename remove_reference&lt; Context &gt;::type &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression to evaluate </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The context in which the expression should be evaluated. </para></description></parameter><purpose>Evaluate a given Proto expression with a given context. </purpose><description><para>

</para></description><returns><para><computeroutput>typename Context::template eval&lt;Expr&gt;()(expr, context)</computeroutput> </para></returns></method><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct></namespace><namespace name="result_of"><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><purpose>A metafunction for calculating the return type of <computeroutput>proto::eval()</computeroutput> given a certain <computeroutput>Expr</computeroutput> and <computeroutput>Context</computeroutput> types. </purpose><description><para>
</para></description><typedef name="type"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type></typedef></struct></namespace><data-member name="eval"><type><classname>functional::eval</classname> const</type><purpose>A PolymorphicFunctionObject for evaluating a given Proto expression with a given context. </purpose><description><para><para>proto::functional::eval. </para>
</para></description></data-member></namespace></namespace></header><header name="boost/xpressive/proto/expr.hpp"><para>Contains definition of expr&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><namespace name="exprns_"><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>0</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 0 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>void</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv=""><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr &gt; &gt; &gt; const</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>void</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><typedef name="address_of_hack_type_"><description><para>If <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput> and <computeroutput>proto_arg0</computeroutput> is <computeroutput>proto::ref_&lt;T&gt;</computeroutput>, then <computeroutput>address_of_hack_type_</computeroutput> is <computeroutput>T*</computeroutput>. Otherwise, it is some undefined type. </para></description><type><emphasis>unspecified</emphasis></type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="conversion-operator" cv="const"><type>address_of_hack_type_</type><description><para>

</para></description><returns><para>The address of <computeroutput>this-&gt;arg0</computeroutput> if <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput>. Otherwise, this function will fail to compile.</para></returns><notes><para>Proto overloads <computeroutput>operator&amp;</computeroutput>, which means that proto-ified objects cannot have their addresses taken, unless we use the following hack to make <computeroutput>&amp;x</computeroutput> implicitly convertible to <computeroutput>X*</computeroutput>. </para></notes></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 2 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 3 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 4 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>Args::arg3</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><data-member name="arg3"><type>proto_arg3</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args0&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the children expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 5 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type>default_domain</type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>Args::arg3</type></typedef><typedef name="proto_arg4"><type>Args::arg4</type></typedef><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><data-member name="arg3"><type>proto_arg3</type></data-member><data-member name="arg4"><type>proto_arg4</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; ref_&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization></namespace><namespace name="result_of"><struct name="funop0"><template>
      <template-type-parameter name="Expr"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; ref_&lt; Expr &gt;&gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const ()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; Expr &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop1"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>args2</classname>&lt; ref_&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This, remove_reference&lt; A0 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; Expr, A0 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>args3</classname>&lt; ref_&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; Expr, A0, A1 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop3"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>args4</classname>&lt; ref_&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; Expr, A0, A1, A2 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop4"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>args5</classname>&lt; ref_&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A3 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; Expr, A0, A1, A2, A3 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/extends.hpp"><para>Macros and a base class for defining end-user expression types </para><namespace name="boost"><namespace name="proto"><namespace name="exprns_"><struct name="is_proto_expr"><purpose>Empty type to be used as a dummy template parameter of POD expression wrappers. It allows argument-dependent lookup to find Proto's operator overloads. </purpose><description><para><computeroutput>proto::is_proto_expr</computeroutput> allows argument-dependent lookup to find Proto's operator overloads. For example:</para><para><programlisting> template&lt;typename T, typename Dummy = proto::is_proto_expr&gt;
 struct my_terminal
 {
     BOOST_PROTO_EXTENDS(
         typename proto::terminal&lt;T&gt;::type
       , my_terminal&lt;T&gt;
       , default_domain
     )
 };

 // ...
 my_terminal&lt;int&gt; _1, _2;
 _1 + _2; // OK, uses proto::operator+
</programlisting></para><para>Without the second <computeroutput>Dummy</computeroutput> template parameter, Proto's operator overloads would not be considered by name lookup. </para></description></struct><struct name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Tag"/>
    </template><purpose>extends&lt;&gt; class template for adding behaviors to a Proto expression template </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="proto_base_expr"><type>Expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><method-group name="public member functions"><method name="proto_base" cv=""><type>Expr &amp;</type></method><method name="proto_base" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></constructor><constructor><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></constructor><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Derived</template-arg><template-arg>Domain</template-arg><template-arg>tag::terminal</template-arg></specialization><purpose>extends&lt;&gt; class template for adding behaviors to a Proto expression template </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="proto_base_expr"><type>Expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><method-group name="public member functions"><method name="extends" cv=""><type/></method><method name="extends" cv=""><type/><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></method><method name="extends" cv=""><type/><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></method><method name="proto_base" cv=""><type>Expr &amp;</type></method><method name="proto_base" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived, const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived, const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived, const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived, const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/fusion.hpp"><para>Make any Proto expression a valid Fusion sequence </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="flatten"><purpose>A PolymorphicFunctionObject type that returns a "flattened" view of a Proto expression tree. </purpose><description><para>A PolymorphicFunctionObject type that returns a "flattened" view of a Proto expression tree. For a tree with a top-most node tag of type <computeroutput>T</computeroutput>, the elements of the flattened sequence are determined by recursing into each child node with the same tag type and returning those nodes of different type. So for instance, the Proto expression tree corresponding to the expression <computeroutput>a | b | c</computeroutput> has a flattened view with elements [a, b, c], even though the tree is grouped as <computeroutput>((a | b) | c)</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="pop_front"><purpose>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::pop_front()</computeroutput> algorithm on its argument. </purpose><description><para>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::pop_front()</computeroutput> algorithm on its argument. This is useful for defining a CallableTransform like <computeroutput>pop_front(_)</computeroutput> which removes the first child from a Proto expression node. Such a transform might be used as the first argument to the <computeroutput>proto::transform::fold&lt;&gt;</computeroutput> transform; that is, fold all but the first child. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>fusion::result_of::pop_front&lt; typename boost::remove_reference&lt; Expr &gt;::type const  &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>fusion::result_of::pop_front&lt; Expr const  &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse"><purpose>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::reverse()</computeroutput> algorithm on its argument. </purpose><description><para>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::reverse()</computeroutput> algorithm on its argument. This is useful for defining a CallableTransform like <computeroutput>reverse(_)</computeroutput> which reverses the order of the children of a Proto expression node. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>fusion::result_of::reverse&lt; typename boost::remove_reference&lt; Expr &gt;::type const  &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>fusion::result_of::reverse&lt; Expr const  &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><data-member name="flatten"><type><classname>functional::flatten</classname> const</type><purpose>A PolymorphicFunctionObject type that returns a "flattened" view of a Proto expression tree. </purpose><description><para><para>boost::proto::functional::flatten </para>
</para></description></data-member></namespace></namespace></header><header name="boost/xpressive/proto/generate.hpp"><para>Contains definition of generate&lt;&gt; class template, which end users can specialize for generating domain-specific expression wrappers. </para><namespace name="boost"><namespace name="proto"><namespace name="generatorns_"><struct name="default_generator"><purpose>A simple generator that passes an expression through unchanged. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. The <computeroutput>default_generator</computeroutput> makes no modifications to the expressions passed to it. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>A Proto expression </para></description></parameter><description><para>

</para></description><returns><para>expr </para></returns></method></method-group></struct><struct name="generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><purpose>A generator that wraps expressions passed to it in the specified extension wrapper. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>generator&lt;&gt;</computeroutput> wraps each expression passed to it in the <computeroutput>Extends&lt;&gt;</computeroutput> wrapper. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>A Proto expression </para></description></parameter><description><para>

</para></description><returns><para>Extends&lt;Expr&gt;(expr) </para></returns></method></method-group></struct><struct name="pod_generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><purpose>A generator that wraps expressions passed to it in the specified extension wrapper and uses aggregate initialization for the wrapper. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>pod_generator&lt;&gt;</computeroutput> wraps each expression passed to it in the <computeroutput>Extends&lt;&gt;</computeroutput> wrapper, and uses aggregate initialzation for the wrapped object. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The expression to wrap </para></description></parameter><description><para>

</para></description><returns><para>Extends&lt;Expr&gt; that = {expr}; return that; </para></returns></method></method-group></struct><struct name="by_value_generator"><template>
      <template-type-parameter name="Generator"/>
    </template><purpose>A composite generator that first replaces child nodes held by reference with ones held by value and then forwards the result on to another generator. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>by_value_generator&lt;&gt;</computeroutput> ensures all children nodes are held by value before forwarding the expression on to another generator for further processing. The <computeroutput>Generator</computeroutput> parameter defaults to <computeroutput>default_generator</computeroutput>. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static <classname>apply</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The expression to modify. </para></description></parameter><description><para>

</para></description><returns><para>Generator::make(deep_copy(expr)) </para></returns></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/literal.hpp"><para>The literal&lt;&gt; terminal wrapper, and the proto::lit() function for creating literal&lt;&gt; wrappers. </para><namespace name="boost"><namespace name="proto"><namespace name="utility"><struct name="literal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><purpose>A simple wrapper for a terminal, provided for ease of use. </purpose><description><para>A simple wrapper for a terminal, provided for ease of use. In all cases, <computeroutput>literal&lt;X&gt; l(x);</computeroutput> is equivalent to <computeroutput>terminal&lt;X&gt;type l = {x};</computeroutput>.</para><para>The <computeroutput>Domain</computeroutput> template parameter defaults to <computeroutput>proto::default_domain</computeroutput>. </para></description><typedef name="value_type"><type><classname>proto::result_of::arg</classname>&lt; terminal_type &gt;::type</type></typedef><typedef name="reference"><type><classname>proto::result_of::arg</classname>&lt; terminal_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>proto::result_of::arg</classname>&lt; terminal_type &gt;::const_reference</type></typedef><method-group name="public member functions"><method name="get" cv=""><type>reference</type></method><method name="get" cv="const"><type>const_reference</type></method></method-group><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype><classname>literal</classname>&lt; U, Domain &gt; const &amp;</paramtype></parameter></constructor></struct></namespace><overloaded-function name="lit"><signature><type>literal&lt; T &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap. </para></description></parameter></signature><signature><type>literal&lt; T const &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><purpose>A helper function for creating a <computeroutput>literal&lt;&gt;</computeroutput> wrapper. </purpose><description><para>



</para></description><returns><para>literal&lt;T &amp;&gt;(t) </para></returns><throws><simpara>Will not throw.</simpara></throws><notes><para>The returned value holds the argument by reference. </para></notes></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/make_expr.hpp"><para>Definition of the <computeroutput>make_expr()</computeroutput> and <computeroutput>unpack_expr()</computeroutput> utilities for building Proto expression nodes from children nodes or from a Fusion sequence of children nodes, respectively. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>This(A0)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2, A3 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2, A3, A4 &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0 const  &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>Construct an expression node with tag type <computeroutput>Tag</computeroutput> and in the domain <computeroutput>Domain</computeroutput>. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3, const A4 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="type"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, typename remove_reference&lt; Sequence &gt;::type &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence const  &gt;::type const</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="EnableIf1"/>
      <template-type-parameter name="EnableIf2"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct><struct-specialization name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>Sequence</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
      <template-type-parameter name="EnableIf1"/>
      <template-type-parameter name="EnableIf2"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization></namespace><overloaded-function name="unpack_expr"><signature><type>lazy_disable_if&lt; is_domain&lt; Sequence &gt;, <classname>result_of::unpack_expr</classname>&lt; Tag, Sequence const  &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence2 const  &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="Sequence2"/>
        </template><parameter name="sequence2"><paramtype>Sequence2 const &amp;</paramtype></parameter></signature><description><para>unpack_expr </para></description></overloaded-function><overloaded-function name="make_expr"><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, A0 const  &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, B0 const  &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>B0 const &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3, const A4 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3, const B4 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
          <template-type-parameter name="B4"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter><parameter name="b4"><paramtype>const B4 &amp;</paramtype></parameter></signature><description><para>make_expr </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/matches.hpp"><para>Contains definition of matches&lt;&gt; metafunction for determining if a given expression matches a given pattern. </para><namespace name="boost"><namespace name="proto"><namespace name="control"><struct name="not_"><template>
      <template-type-parameter name="Grammar"/>
    </template><purpose>Inverts the set of expressions matched by a grammar. When used as a transform, <computeroutput>not_&lt;&gt;</computeroutput> returns the current expression unchanged. </purpose><description><para>If an expression type <computeroutput>E</computeroutput> does not match a grammar <computeroutput>G</computeroutput>, then <computeroutput>E</computeroutput> does match <computeroutput>not_&lt;G&gt;</computeroutput>. For example, <computeroutput>not_&lt;terminal&lt;_&gt; &gt;</computeroutput> will match any non-terminal. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>Expr</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>not_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter><description><para>


</para></description><requires><para><computeroutput>matches&lt;Expr,not_&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>expr</computeroutput> </para></returns></method></method-group></struct><struct name="if_"><template>
      <template-type-parameter name="If"/>
      <template-type-parameter name="Then"/>
      <template-type-parameter name="Else"/>
    </template><purpose>Used to select one grammar or another based on the result of a compile-time Boolean. When used as a transform, <computeroutput>if_&lt;&gt;</computeroutput> selects between two transforms based on a compile-time Boolean. </purpose><description><para>When <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> is used as a grammar, <computeroutput>If</computeroutput> must be a Proto transform and <computeroutput>Then</computeroutput> and <computeroutput>Else</computeroutput> must be grammars. An expression type <computeroutput>E</computeroutput> matches <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>U</computeroutput>; or, if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>false</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>V</computeroutput>.</para><para>The template parameter <computeroutput>Then</computeroutput> defaults to <computeroutput>_</computeroutput> and <computeroutput>Else</computeroutput> defaults to <computeroutput>not&lt;_&gt;</computeroutput>, so an expression type <computeroutput>E</computeroutput> will match <computeroutput>if_&lt;If&gt;</computeroutput> if and only if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput>.</para><para><programlisting> // A grammar that only matches integral terminals,
 // using is_integral&lt;&gt; from Boost.Type_traits.
 struct IsIntegral
   : and_&lt;
         terminal&lt;_&gt;
       , if_&lt; is_integral&lt;_arg&gt;() &gt;
     &gt;
 {};
</programlisting></para><para>When <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> is used as a transform, <computeroutput>If</computeroutput>, <computeroutput>Then</computeroutput> and <computeroutput>Else</computeroutput> must be Proto transforms. When applying the transform to an expression <computeroutput>E</computeroutput>, state <computeroutput>S</computeroutput> and visitor <computeroutput>V</computeroutput>, if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,S,V)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> then the <computeroutput>Then</computeroutput> transform is applied; otherwise the <computeroutput>Else</computeroutput> transform is applied.</para><para><programlisting> // Match a terminal. If the terminal is integral, return
 // mpl::true_; otherwise, return mpl::false_.
 struct IsIntegral2
   : when&lt;
         terminal&lt;_&gt;
       , if_&lt;
             is_integral&lt;_arg&gt;()
           , mpl::true_()
           , mpl::false_()
         &gt;
     &gt;
 {};
</programlisting> </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="condition"><type>when&lt; _, If &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef><typedef name="which"><type>mpl::if_&lt; condition, when&lt; _, Then &gt;, when&lt; _, Else &gt;&gt;::type</type></typedef><typedef name="type"><type>which::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>if_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name="state"><paramtype>State const &amp;</paramtype><description><para>The current state </para></description></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype><description><para>A visitor of arbitrary type </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>result&lt;void(Expr, State, Visitor)&gt;::which()(expr, state, visitor)</computeroutput> </para></returns></method></method-group></struct><struct name="or_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><purpose>For matching one of a set of alternate grammars. Alternates tried in order to avoid ambiguity. When used as a transform, <computeroutput>or_&lt;&gt;</computeroutput> applies the transform associated with the first grammar that matches the expression. </purpose><description><para>An expression type <computeroutput>E</computeroutput> matches <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches any <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>.</para><para>When applying <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput> of type <computeroutput>E</computeroutput>, state <computeroutput>s</computeroutput> and visitor <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>Bx()(e, s, v)</computeroutput>, where <computeroutput>x</computeroutput> is the lowest number such that <computeroutput>matches&lt;E,Bx&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>or_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name="state"><paramtype>State const &amp;</paramtype><description><para>The current state </para></description></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype><description><para>A visitor of arbitrary type </para></description></parameter><description><para>


</para></description><requires><para><computeroutput>matches&lt;Expr,or_&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Visitor)&gt;::which()(expr, state, visitor)</computeroutput> </para></returns></method></method-group></struct><struct name="and_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><purpose>For matching all of a set of grammars. When used as a transform, <computeroutput>and_&lt;&gt;</computeroutput> applies the transform associated with the last grammar in the set. </purpose><description><para>An expression type <computeroutput>E</computeroutput> matches <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches all <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>.</para><para>When applying <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput>, state <computeroutput>s</computeroutput> and visitor <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>Bn()(e, s, v)</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>and_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name="state"><paramtype>State const &amp;</paramtype><description><para>The current state </para></description></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype><description><para>A visitor of arbitrary type </para></description></parameter><description><para>


</para></description><requires><para><computeroutput>matches&lt;Expr,and_&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Visitor)&gt;::which()(expr, state, visitor)</computeroutput> </para></returns></method></method-group></struct><struct name="switch_"><template>
      <template-type-parameter name="Cases"/>
    </template><purpose>For matching one of a set of alternate grammars, which are looked up based on an expression's tag type. When used as a transform, <computeroutput>switch_&lt;&gt;</computeroutput> applies the transform associated with the grammar that matches the expression. </purpose><description><para>
An expression type <computeroutput>E</computeroutput> matches <computeroutput>switch_&lt;C&gt;</computeroutput> if <computeroutput>E</computeroutput> matches <computeroutput>C::case_&lt;E::proto_tag&gt;</computeroutput>.</para><para>When applying <computeroutput>switch_&lt;C&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput> of type <computeroutput>E</computeroutput>, state <computeroutput>s</computeroutput> and visitor <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>C::case_&lt;E::proto_tag&gt;()(e, s, v)</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="which"><type>Cases::template case_&lt; typename Expr::proto_tag &gt;</type></typedef><typedef name="type"><type>which::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>switch_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name="state"><paramtype>State const &amp;</paramtype><description><para>The current state </para></description></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype><description><para>A visitor of arbitrary type </para></description></parameter><description><para>


</para></description><requires><para><computeroutput>matches&lt;Expr,switch_&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Visitor)&gt;::which()(expr, state, visitor)</computeroutput> </para></returns></method></method-group></struct><struct name="exact"><template>
      <template-type-parameter name="T"/>
    </template><purpose>For forcing exact matches of terminal types. </purpose><description><para>By default, matching terminals ignores references and cv-qualifiers. For instance, a terminal expression of type <computeroutput>terminal&lt;int const &amp;&gt;type</computeroutput> will match the grammar <computeroutput>terminal&lt;int&gt;</computeroutput>. If that is not desired, you can force an exact match with <computeroutput>terminal&lt;exact&lt;int&gt; &gt;</computeroutput>. This will only match integer terminals where the terminal is held by value. </para></description></struct><struct name="convertible_to"><template>
      <template-type-parameter name="T"/>
    </template><purpose>For matching terminals that are convertible to a type. </purpose><description><para>Use <computeroutput>convertible_to&lt;&gt;</computeroutput> to match a terminal that is convertible to some type. For example, the grammar <computeroutput>terminal&lt;convertible_to&lt;int&gt; &gt;</computeroutput> will match any terminal whose argument is convertible to an integer.</para><para>
</para></description></struct><struct name="vararg"><template>
      <template-type-parameter name="Grammar"/>
    </template><purpose>For matching a Grammar to a variable number of sub-expressions. </purpose><description><para>An expression type <computeroutput>expr&lt;AT, argsN&lt;A0,...An,U0,...Um&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, argsM&lt;B0,...Bn,vararg&lt;V&gt; &gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput> and if <computeroutput>Ux</computeroutput> matches <computeroutput>V</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,m)</computeroutput>.</para><para>For example:</para><para><programlisting> // Match any function call expression, irregardless
 // of the number of function arguments:
 struct Function
   : function&lt; vararg&lt;_&gt; &gt;
 {};
</programlisting></para><para>When used as a transform, <computeroutput>vararg&lt;G&gt;</computeroutput> applies <computeroutput>G</computeroutput>'s transform. </para></description><typedef name="proto_is_vararg_"><type>void</type></typedef></struct></namespace><namespace name="result_of"><struct name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template><purpose>A Boolean metafunction that evaluates whether a given expression type matches a grammar. </purpose><description><para><computeroutput>matches&lt;Expr,Grammar&gt;</computeroutput> inherits (indirectly) from <computeroutput>mpl::true_</computeroutput> if <computeroutput>Expr::proto_base_expr</computeroutput> matches <computeroutput>Grammar::proto_base_expr</computeroutput>, and from <computeroutput>mpl::false_</computeroutput> otherwise.</para><para>Non-terminal expressions are matched against a grammar according to the following rules:</para><para><itemizedlist>
<listitem><para>The wildcard pattern, <computeroutput>_</computeroutput>, matches any expression. </para></listitem>
<listitem><para>An expression <computeroutput>expr&lt;AT, argsN&lt;A0,A1,...An&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, argsN&lt;B0,B1,...Bn&gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>expr&lt;AT, argsN&lt;A0,...An,U0,...Um&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, argsM&lt;B0,...Bn,vararg&lt;V&gt; &gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput> and if <computeroutput>Ux</computeroutput> matches <computeroutput>V</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,m)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches some <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches all <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>if_&lt;T,U,V&gt;</computeroutput> if <computeroutput>when&lt;_,T&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>U</computeroutput>; or, if <computeroutput>when&lt;_,T&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>false</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>V</computeroutput>. (Note: <computeroutput>U</computeroutput> defaults to <computeroutput>_</computeroutput> and <computeroutput>V</computeroutput> defaults to <computeroutput>not&lt;_&gt;</computeroutput>.) </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>not_&lt;T&gt;</computeroutput> if <computeroutput>E</computeroutput> does not match <computeroutput>T</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>switch_&lt;C&gt;</computeroutput> if <computeroutput>E</computeroutput> matches <computeroutput>C::case_&lt;E::proto_tag&gt;</computeroutput>.</para></listitem>
</itemizedlist>
A terminal expression <computeroutput>expr&lt;tag::terminal,args0&lt;A&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT,args0&lt;B&gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>tag::terminal</computeroutput> and one of the following is true:</para><para><itemizedlist>
<listitem><para><computeroutput>B</computeroutput> is the wildcard pattern, <computeroutput>_</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>exact&lt;A&gt;</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>convertible_to&lt;X&gt;</computeroutput> and <computeroutput>is_convertible&lt;A,X&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X[M]</computeroutput> or <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X[proto::N]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X(&amp;)[proto::N]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X[M]</computeroutput> or <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X*</computeroutput>. </para></listitem>
<listitem><para><computeroutput>B</computeroutput> lambda-matches <computeroutput>A</computeroutput> (see below).</para></listitem>
</itemizedlist>
A type <computeroutput>B</computeroutput> lambda-matches <computeroutput>A</computeroutput> if one of the following is true:</para><para><itemizedlist>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>A</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is the wildcard pattern, <computeroutput>_</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>T&lt;B0,B1,...Bn&gt;</computeroutput> and <computeroutput>A</computeroutput> is <computeroutput>T&lt;A0,A1,...An&gt;</computeroutput> and for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>, <computeroutput>Ax</computeroutput> and <computeroutput>Bx</computeroutput> are types such that <computeroutput>Ax</computeroutput> lambda-matches <computeroutput>Bx</computeroutput> </para></listitem>
</itemizedlist>
</para></description></struct></namespace><namespace name="wildcardns_"><struct name="_"><purpose>A wildcard grammar element that matches any expression, and a transform that returns the current expression unchanged. </purpose><description><para>The wildcard type, <computeroutput>_</computeroutput>, is a grammar element such that <computeroutput>matches&lt;E,_&gt;::value</computeroutput> is <computeroutput>true</computeroutput> for any expression type <computeroutput>E</computeroutput>.</para><para>The wildcard can also be used as a stand-in for a template argument when matching terminals. For instance, the following is a grammar that will match any <computeroutput>std::complex&lt;&gt;</computeroutput> terminal:</para><para><programlisting> BOOST_MPL_ASSERT((
     matches&lt;
         terminal&lt;std::complex&lt;double&gt; &gt;::type
       , terminal&lt;std::complex&lt; _ &gt; &gt;
     &gt;
 ));
</programlisting></para><para>When used as a transform, <computeroutput>_</computeroutput> returns the current expression unchanged. For instance, in the following, <computeroutput>_</computeroutput> is used with the <computeroutput>fold&lt;&gt;</computeroutput> transform to fold the children of a node:</para><para><programlisting> struct CountChildren
   : or_&lt;
         // Terminals have no children
         when&lt;terminal&lt;_&gt;, mpl::int_&lt;0&gt;()&gt;
         // Use fold&lt;&gt; to count the children of non-terminals
       , otherwise&lt;
             fold&lt;
                 _ // &lt;-- fold the current expression
               , mpl::int_&lt;0&gt;()
               , mpl::plus&lt;_state, mpl::int_&lt;1&gt; &gt;()
             &gt;
         &gt;
     &gt;
 {};
</programlisting> </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>Expr</type></typedef></struct-specialization><typedef name="proto_base_expr"><type><classname>_</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>An expression </para></description></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter><description><para>

</para></description><returns><para><computeroutput>expr</computeroutput> </para></returns></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/operators.hpp"><para>Contains all the overloaded operators that make it possible to build Proto expression trees. </para><namespace name="boost"><namespace name="proto"><struct name="is_extension"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::mpl::false_</inherit></struct><namespace name="exprns_"><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="if_else"><type><classname>boost::proto::result_of::make_expr</classname>&lt; <classname>tag::if_else_</classname>, deduce_domain, A0 const &amp;, A1 const &amp;, A2 const &amp; &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>if_else </para></description></function></namespace></namespace></namespace></header><header name="boost/xpressive/proto/proto.hpp"><para>The proto expression template compiler and supporting utilities. </para></header><header name="boost/xpressive/proto/proto_fwd.hpp"><para>Forward declarations of all of proto's public types and functions. </para><namespace name="boost"><namespace name="proto"><namespace name="context"/><namespace name="control"><data-member name="N"><type>int const</type></data-member></namespace><namespace name="domainns_"/><namespace name="exops"/><namespace name="exprns_"/><namespace name="functional"><typedef name="make_terminal"><type><classname>make_expr</classname>&lt; <classname>tag::terminal</classname> &gt;</type></typedef><typedef name="make_posit"><type><classname>make_expr</classname>&lt; <classname>tag::posit</classname> &gt;</type></typedef><typedef name="make_negate"><type><classname>make_expr</classname>&lt; <classname>tag::negate</classname> &gt;</type></typedef><typedef name="make_dereference"><type><classname>make_expr</classname>&lt; <classname>tag::dereference</classname> &gt;</type></typedef><typedef name="make_complement"><type><classname>make_expr</classname>&lt; <classname>tag::complement</classname> &gt;</type></typedef><typedef name="make_address_of"><type><classname>make_expr</classname>&lt; <classname>tag::address_of</classname> &gt;</type></typedef><typedef name="make_logical_not"><type><classname>make_expr</classname>&lt; <classname>tag::logical_not</classname> &gt;</type></typedef><typedef name="make_pre_inc"><type><classname>make_expr</classname>&lt; <classname>tag::pre_inc</classname> &gt;</type></typedef><typedef name="make_pre_dec"><type><classname>make_expr</classname>&lt; <classname>tag::pre_dec</classname> &gt;</type></typedef><typedef name="make_post_inc"><type><classname>make_expr</classname>&lt; <classname>tag::post_inc</classname> &gt;</type></typedef><typedef name="make_post_dec"><type><classname>make_expr</classname>&lt; <classname>tag::post_dec</classname> &gt;</type></typedef><typedef name="make_shift_left"><type><classname>make_expr</classname>&lt; <classname>tag::shift_left</classname> &gt;</type></typedef><typedef name="make_shift_right"><type><classname>make_expr</classname>&lt; <classname>tag::shift_right</classname> &gt;</type></typedef><typedef name="make_multiplies"><type><classname>make_expr</classname>&lt; <classname>tag::multiplies</classname> &gt;</type></typedef><typedef name="make_divides"><type><classname>make_expr</classname>&lt; <classname>tag::divides</classname> &gt;</type></typedef><typedef name="make_modulus"><type><classname>make_expr</classname>&lt; <classname>tag::modulus</classname> &gt;</type></typedef><typedef name="make_plus"><type><classname>make_expr</classname>&lt; <classname>tag::plus</classname> &gt;</type></typedef><typedef name="make_minus"><type><classname>make_expr</classname>&lt; <classname>tag::minus</classname> &gt;</type></typedef><typedef name="make_less"><type><classname>make_expr</classname>&lt; <classname>tag::less</classname> &gt;</type></typedef><typedef name="make_greater"><type><classname>make_expr</classname>&lt; <classname>tag::greater</classname> &gt;</type></typedef><typedef name="make_less_equal"><type><classname>make_expr</classname>&lt; <classname>tag::less_equal</classname> &gt;</type></typedef><typedef name="make_greater_equal"><type><classname>make_expr</classname>&lt; <classname>tag::greater_equal</classname> &gt;</type></typedef><typedef name="make_equal_to"><type><classname>make_expr</classname>&lt; <classname>tag::equal_to</classname> &gt;</type></typedef><typedef name="make_not_equal_to"><type><classname>make_expr</classname>&lt; <classname>tag::not_equal_to</classname> &gt;</type></typedef><typedef name="make_logical_or"><type><classname>make_expr</classname>&lt; <classname>tag::logical_or</classname> &gt;</type></typedef><typedef name="make_logical_and"><type><classname>make_expr</classname>&lt; <classname>tag::logical_and</classname> &gt;</type></typedef><typedef name="make_bitwise_and"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_and</classname> &gt;</type></typedef><typedef name="make_bitwise_or"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_or</classname> &gt;</type></typedef><typedef name="make_bitwise_xor"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_xor</classname> &gt;</type></typedef><typedef name="make_comma"><type><classname>make_expr</classname>&lt; <classname>tag::comma</classname> &gt;</type></typedef><typedef name="make_mem_ptr"><type><classname>make_expr</classname>&lt; <classname>tag::mem_ptr</classname> &gt;</type></typedef><typedef name="make_assign"><type><classname>make_expr</classname>&lt; <classname>tag::assign</classname> &gt;</type></typedef><typedef name="make_shift_left_assign"><type><classname>make_expr</classname>&lt; <classname>tag::shift_left_assign</classname> &gt;</type></typedef><typedef name="make_shift_right_assign"><type><classname>make_expr</classname>&lt; <classname>tag::shift_right_assign</classname> &gt;</type></typedef><typedef name="make_multiplies_assign"><type><classname>make_expr</classname>&lt; <classname>tag::multiplies_assign</classname> &gt;</type></typedef><typedef name="make_divides_assign"><type><classname>make_expr</classname>&lt; <classname>tag::divides_assign</classname> &gt;</type></typedef><typedef name="make_modulus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::modulus_assign</classname> &gt;</type></typedef><typedef name="make_plus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::plus_assign</classname> &gt;</type></typedef><typedef name="make_minus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::minus_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_and_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_and_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_or_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_or_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_xor_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_xor_assign</classname> &gt;</type></typedef><typedef name="make_subscript"><type><classname>make_expr</classname>&lt; <classname>tag::subscript</classname> &gt;</type></typedef><typedef name="make_if_else"><type><classname>make_expr</classname>&lt; <classname>tag::if_else_</classname> &gt;</type></typedef><typedef name="make_function"><type><classname>make_expr</classname>&lt; <classname>tag::function</classname> &gt;</type></typedef></namespace><namespace name="generatorns_"/><namespace name="op"/><namespace name="refns_"/><namespace name="result_of"/><namespace name="tag"/><namespace name="transform"><struct name="callable"><typedef name="proto_is_callable_"><type>void</type></typedef></struct><typedef name="arg0"><type><classname>arg_c</classname>&lt; 0 &gt;</type></typedef><typedef name="arg1"><type><classname>arg_c</classname>&lt; 1 &gt;</type></typedef><typedef name="arg2"><type><classname>arg_c</classname>&lt; 2 &gt;</type></typedef><typedef name="arg3"><type><classname>arg_c</classname>&lt; 3 &gt;</type></typedef><typedef name="arg4"><type><classname>arg_c</classname>&lt; 4 &gt;</type></typedef><typedef name="arg5"><type><classname>arg_c</classname>&lt; 5 &gt;</type></typedef><typedef name="arg6"><type><classname>arg_c</classname>&lt; 6 &gt;</type></typedef><typedef name="arg7"><type><classname>arg_c</classname>&lt; 7 &gt;</type></typedef><typedef name="arg8"><type><classname>arg_c</classname>&lt; 8 &gt;</type></typedef><typedef name="arg9"><type><classname>arg_c</classname>&lt; 9 &gt;</type></typedef><typedef name="arg"><type><classname>arg0</classname></type></typedef><typedef name="left"><type><classname>arg0</classname></type></typedef><typedef name="right"><type><classname>arg1</classname></type></typedef></namespace><namespace name="utility"/><namespace name="wildcardns_"/><typedef name="_make_terminal"><type><classname>functional::make_terminal</classname></type></typedef><typedef name="_make_posit"><type><classname>functional::make_posit</classname></type></typedef><typedef name="_make_negate"><type><classname>functional::make_negate</classname></type></typedef><typedef name="_make_dereference"><type><classname>functional::make_dereference</classname></type></typedef><typedef name="_make_complement"><type><classname>functional::make_complement</classname></type></typedef><typedef name="_make_address_of"><type><classname>functional::make_address_of</classname></type></typedef><typedef name="_make_logical_not"><type><classname>functional::make_logical_not</classname></type></typedef><typedef name="_make_pre_inc"><type><classname>functional::make_pre_inc</classname></type></typedef><typedef name="_make_pre_dec"><type><classname>functional::make_pre_dec</classname></type></typedef><typedef name="_make_post_inc"><type><classname>functional::make_post_inc</classname></type></typedef><typedef name="_make_post_dec"><type><classname>functional::make_post_dec</classname></type></typedef><typedef name="_make_shift_left"><type><classname>functional::make_shift_left</classname></type></typedef><typedef name="_make_shift_right"><type><classname>functional::make_shift_right</classname></type></typedef><typedef name="_make_multiplies"><type><classname>functional::make_multiplies</classname></type></typedef><typedef name="_make_divides"><type><classname>functional::make_divides</classname></type></typedef><typedef name="_make_modulus"><type><classname>functional::make_modulus</classname></type></typedef><typedef name="_make_plus"><type><classname>functional::make_plus</classname></type></typedef><typedef name="_make_minus"><type><classname>functional::make_minus</classname></type></typedef><typedef name="_make_less"><type><classname>functional::make_less</classname></type></typedef><typedef name="_make_greater"><type><classname>functional::make_greater</classname></type></typedef><typedef name="_make_less_equal"><type><classname>functional::make_less_equal</classname></type></typedef><typedef name="_make_greater_equal"><type><classname>functional::make_greater_equal</classname></type></typedef><typedef name="_make_equal_to"><type><classname>functional::make_equal_to</classname></type></typedef><typedef name="_make_not_equal_to"><type><classname>functional::make_not_equal_to</classname></type></typedef><typedef name="_make_logical_or"><type><classname>functional::make_logical_or</classname></type></typedef><typedef name="_make_logical_and"><type><classname>functional::make_logical_and</classname></type></typedef><typedef name="_make_bitwise_and"><type><classname>functional::make_bitwise_and</classname></type></typedef><typedef name="_make_bitwise_or"><type><classname>functional::make_bitwise_or</classname></type></typedef><typedef name="_make_bitwise_xor"><type><classname>functional::make_bitwise_xor</classname></type></typedef><typedef name="_make_comma"><type><classname>functional::make_comma</classname></type></typedef><typedef name="_make_mem_ptr"><type><classname>functional::make_mem_ptr</classname></type></typedef><typedef name="_make_assign"><type><classname>functional::make_assign</classname></type></typedef><typedef name="_make_shift_left_assign"><type><classname>functional::make_shift_left_assign</classname></type></typedef><typedef name="_make_shift_right_assign"><type><classname>functional::make_shift_right_assign</classname></type></typedef><typedef name="_make_multiplies_assign"><type><classname>functional::make_multiplies_assign</classname></type></typedef><typedef name="_make_divides_assign"><type><classname>functional::make_divides_assign</classname></type></typedef><typedef name="_make_modulus_assign"><type><classname>functional::make_modulus_assign</classname></type></typedef><typedef name="_make_plus_assign"><type><classname>functional::make_plus_assign</classname></type></typedef><typedef name="_make_minus_assign"><type><classname>functional::make_minus_assign</classname></type></typedef><typedef name="_make_bitwise_and_assign"><type><classname>functional::make_bitwise_and_assign</classname></type></typedef><typedef name="_make_bitwise_or_assign"><type><classname>functional::make_bitwise_or_assign</classname></type></typedef><typedef name="_make_bitwise_xor_assign"><type><classname>functional::make_bitwise_xor_assign</classname></type></typedef><typedef name="_make_subscript"><type><classname>functional::make_subscript</classname></type></typedef><typedef name="_make_if_else"><type><classname>functional::make_if_else</classname></type></typedef><typedef name="_make_function"><type><classname>functional::make_function</classname></type></typedef><typedef name="_flatten"><type><classname>functional::flatten</classname></type></typedef><typedef name="_pop_front"><type><classname>functional::pop_front</classname></type></typedef><typedef name="_reverse"><type><classname>functional::reverse</classname></type></typedef><typedef name="_eval"><type><classname>functional::deep_copy</classname></type></typedef><typedef name="_deep_copy"><type><classname>functional::deep_copy</classname></type></typedef><typedef name="_expr"><type><classname>transform::expr</classname></type></typedef><typedef name="_state"><type><classname>transform::state</classname></type></typedef><typedef name="_visitor"><type><classname>transform::visitor</classname></type></typedef><typedef name="_arg0"><type><classname>transform::arg0</classname></type></typedef><typedef name="_arg1"><type><classname>transform::arg1</classname></type></typedef><typedef name="_arg2"><type><classname>transform::arg2</classname></type></typedef><typedef name="_arg3"><type><classname>transform::arg3</classname></type></typedef><typedef name="_arg4"><type><classname>transform::arg4</classname></type></typedef><typedef name="_arg5"><type><classname>transform::arg5</classname></type></typedef><typedef name="_arg6"><type><classname>transform::arg6</classname></type></typedef><typedef name="_arg7"><type><classname>transform::arg7</classname></type></typedef><typedef name="_arg8"><type><classname>transform::arg8</classname></type></typedef><typedef name="_arg9"><type><classname>transform::arg9</classname></type></typedef><typedef name="_arg"><type><classname>transform::arg</classname></type></typedef><typedef name="_left"><type><classname>transform::left</classname></type></typedef><typedef name="_right"><type><classname>transform::right</classname></type></typedef></namespace></namespace></header><header name="boost/xpressive/proto/ref.hpp"><para>Utility for storing a sub-expr by reference </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="unref"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; boost::remove_const&lt; boost::remove_reference&lt; T &gt;::type &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>ref_&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>ref_&lt; T &gt; const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="refns_"><struct name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="proto_base_expr"><type>Expr::proto_base_expr</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_domain"><type>Expr::proto_domain</type></typedef><typedef name="proto_is_ref_"><type>void</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>Expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><data-member name="expr"><type>Expr &amp;</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>mpl::if_&lt; is_const&lt; Expr &gt;, proto_base_expr const &amp;, proto_base_expr &amp; &gt;::type</type></method></method-group><method-group name="public static functions"><method name="make" cv=""><type>static <classname>ref_</classname>&lt; Expr &gt;</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>ref_&lt; Expr &gt;</template-arg></specialization></struct-specialization></namespace><namespace name="result_of"><struct name="unref"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>ref_&lt; T &gt;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>ref_&lt; T const &gt;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T const &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T const &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T const &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct-specialization></namespace><data-member name="unref"><type><classname>functional::unref</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/tags.hpp"><para>Contains the tags for all the overloadable operators in C++ </para><namespace name="boost"><namespace name="proto"><namespace name="tag"><struct name="terminal"><purpose>Tag type for terminals; aka, leaves in the expression tree. </purpose></struct><struct name="posit"><purpose>Tag type for the unary + operator. </purpose></struct><struct name="negate"><purpose>Tag type for the unary - operator. </purpose></struct><struct name="dereference"><purpose>Tag type for the unary * operator. </purpose></struct><struct name="complement"><purpose>Tag type for the unary ~ operator. </purpose></struct><struct name="address_of"><purpose>Tag type for the unary &amp; operator. </purpose></struct><struct name="logical_not"><purpose>Tag type for the unary ! operator. </purpose></struct><struct name="pre_inc"><purpose>Tag type for the unary prefix ++ operator. </purpose></struct><struct name="pre_dec"><purpose>Tag type for the unary prefix -- operator. </purpose></struct><struct name="post_inc"><purpose>Tag type for the unary postfix ++ operator. </purpose></struct><struct name="post_dec"><purpose>Tag type for the unary postfix -- operator. </purpose></struct><struct name="shift_left"><purpose>Tag type for the binary &lt;&lt; operator. </purpose></struct><struct name="shift_right"><purpose>Tag type for the binary &gt;&gt; operator. </purpose></struct><struct name="multiplies"><purpose>Tag type for the binary * operator. </purpose></struct><struct name="divides"><purpose>Tag type for the binary / operator. </purpose></struct><struct name="modulus"><purpose>Tag type for the binary % operator. </purpose></struct><struct name="plus"><purpose>Tag type for the binary + operator. </purpose></struct><struct name="minus"><purpose>Tag type for the binary - operator. </purpose></struct><struct name="less"><purpose>Tag type for the binary &lt; operator. </purpose></struct><struct name="greater"><purpose>Tag type for the binary &gt; operator. </purpose></struct><struct name="less_equal"><purpose>Tag type for the binary &lt;= operator. </purpose></struct><struct name="greater_equal"><purpose>Tag type for the binary &gt;= operator. </purpose></struct><struct name="equal_to"><purpose>Tag type for the binary == operator. </purpose></struct><struct name="not_equal_to"><purpose>Tag type for the binary != operator. </purpose></struct><struct name="logical_or"><purpose>Tag type for the binary || operator. </purpose></struct><struct name="logical_and"><purpose>Tag type for the binary &amp;&amp; operator. </purpose></struct><struct name="bitwise_and"><purpose>Tag type for the binary &amp; operator. </purpose></struct><struct name="bitwise_or"><purpose>Tag type for the binary | operator. </purpose></struct><struct name="bitwise_xor"><purpose>Tag type for the binary ^ operator. </purpose></struct><struct name="comma"><purpose>Tag type for the binary , operator. </purpose></struct><struct name="mem_ptr"><purpose>Tag type for the binary -&gt;* operator. </purpose></struct><struct name="assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="shift_left_assign"><purpose>Tag type for the binary &lt;&lt;= operator. </purpose></struct><struct name="shift_right_assign"><purpose>Tag type for the binary &gt;&gt;= operator. </purpose></struct><struct name="multiplies_assign"><purpose>Tag type for the binary *= operator. </purpose></struct><struct name="divides_assign"><purpose>Tag type for the binary /= operator. </purpose></struct><struct name="modulus_assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="plus_assign"><purpose>Tag type for the binary += operator. </purpose></struct><struct name="minus_assign"><purpose>Tag type for the binary -= operator. </purpose></struct><struct name="bitwise_and_assign"><purpose>Tag type for the binary &amp;= operator. </purpose></struct><struct name="bitwise_or_assign"><purpose>Tag type for the binary |= operator. </purpose></struct><struct name="bitwise_xor_assign"><purpose>Tag type for the binary ^= operator. </purpose></struct><struct name="subscript"><purpose>Tag type for the binary subscript operator. </purpose></struct><struct name="if_else_"><purpose>Tag type for the ternary ?: conditional operator. </purpose></struct><struct name="function"><purpose>Tag type for the nary function call operator. </purpose></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/traits.hpp"><para>Contains definitions for arg&lt;&gt;, arg_c&lt;&gt;, left&lt;&gt;, right&lt;&gt;, tag&lt;&gt;, and the helper functions arg(), arg_c(), left() and right(). </para><namespace name="boost"><namespace name="proto"><struct name="is_callable"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct name="is_aggregate"><template>
      <template-type-parameter name="T"/>
    </template><description><para>is_aggregate </para></description></struct><struct-specialization name="is_aggregate"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>proto::expr&lt; Tag</template-arg><template-arg>Args</template-arg><template-arg>N &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><namespace name="functional"><struct name="as_expr"><template>
      <template-type-parameter name="Domain"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_expr&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T const, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="Domain"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_arg&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T const, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="N"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><inherit access="public">boost::proto::result_of::arg&lt; boost::remove_const&lt; boost::remove_reference&lt; Expr &gt;::type &gt;::type, N &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><inherit access="public">boost::proto::result_of::left&lt; boost::remove_const&lt; boost::remove_reference&lt; Expr &gt;::type &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><inherit access="public">boost::proto::result_of::right&lt; boost::remove_const&lt; boost::remove_reference&lt; Expr &gt;::type &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="op"><struct name="terminal"><template>
      <template-type-parameter name="T"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>Expr</type></typedef></struct-specialization><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::terminal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="if_else_"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
      <template-type-parameter name="V"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::if_else_</classname>, <classname>args3</classname>&lt; T, U, V &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::if_else_</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><typedef name="proto_arg2"><type>V</type></typedef></struct><struct name="unary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="binary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="posit"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::posit</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::posit</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="negate"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::negate</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::negate</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="dereference"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::dereference</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::dereference</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="complement"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::complement</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::complement</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="address_of"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::address_of</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::address_of</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="logical_not"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_not</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_not</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="pre_inc"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::pre_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::pre_inc</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="pre_dec"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::pre_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::pre_dec</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="post_inc"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::post_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::post_inc</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="post_dec"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::post_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::post_dec</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef></struct><struct name="shift_left"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_left</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_left</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="shift_right"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_right</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_right</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="multiplies"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::multiplies</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::multiplies</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="divides"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::divides</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::divides</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="modulus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::modulus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::modulus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="plus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::plus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::plus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="minus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::minus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::minus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="less"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::less</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::less</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="greater"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::greater</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::greater</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="less_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::less_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::less_equal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::greater_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::greater_equal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::equal_to</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="not_equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::not_equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::not_equal_to</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="logical_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_or</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="logical_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_and</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_and</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_or</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_xor"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_xor</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_xor</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="comma"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::comma</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::comma</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="mem_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::mem_ptr</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::mem_ptr</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="shift_left_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_left_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_left_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="shift_right_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_right_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_right_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="multiplies_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::multiplies_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::multiplies_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="divides_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::divides_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::divides_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="modulus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::modulus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::modulus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="plus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::plus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::plus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="minus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::minus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::minus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_and_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_and_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_and_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_or_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_or_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_or_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="bitwise_xor_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_xor_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_xor_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct name="subscript"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::subscript</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef></struct><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type>A4</type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><typedef name="proto_is_callable_"><type>int</type></typedef><typedef name="type"><type>proto::expr&lt; Tag, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type>A4</type></typedef></struct-specialization></namespace><namespace name="result_of"><struct name="is_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">boost::mpl::false_</inherit></struct><struct-specialization name="is_ref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_ref_</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><struct name="is_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">boost::mpl::false_</inherit></struct><struct-specialization name="is_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><struct name="tag_of"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::proto_tag</type></typedef></struct><struct name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="proto_arg0"><type>mpl::eval_if&lt; mpl::or_&lt; boost::is_array&lt; T &gt;, is_function&lt; T &gt; &gt;, add_reference&lt; T &gt;, remove_cv&lt; T &gt;&gt;::type</type></typedef><typedef name="expr_type"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; proto_arg0 &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><typedef name="result_type"><type>type const</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type>T::proto_derived_expr</type></typedef><typedef name="result_type"><type>T &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="expr_type"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; T &amp; &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type>ref_&lt; T &gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="arg"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="N"/>
    </template></struct><struct name="left"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg0 &gt;</inherit></struct><struct name="right"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg1 &gt;</inherit></struct><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>0</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg0</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 0 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>1</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg1</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 1 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>2</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg2</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 2 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>3</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg3</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 3 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>4</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg4</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 4 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>5</template-arg></specialization><typedef name="wrapped_type"><type>Expr::proto_arg5</type></typedef><typedef name="type"><type><classname>unref</classname>&lt; wrapped_type &gt;::type</type></typedef><typedef name="reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::reference</type></typedef><typedef name="const_reference"><type><classname>unref</classname>&lt; wrapped_type &gt;::const_reference</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 5 &gt;</inherit></struct-specialization></namespace><data-member name="left"><type><classname>functional::left</classname> const</type></data-member><data-member name="right"><type><classname>functional::right</classname> const</type></data-member><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 &amp;</paramtype></parameter></function><overloaded-function name="as_expr"><signature><type><classname>result_of::as_expr</classname>&lt; T &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_expr</classname>&lt; T const  &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_expr</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></overloaded-function><overloaded-function name="as_arg"><signature><type><classname>result_of::as_arg</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_arg</classname>&lt; T const  &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_arg</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></overloaded-function><overloaded-function name="arg"><signature><type><classname>result_of::unref</classname>&lt; typename Expr::proto_base_expr::proto_arg0 &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unref</classname>&lt; typename Expr::proto_base_expr::proto_arg0 &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg</para><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></overloaded-function><overloaded-function name="arg_c"><signature><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg_c </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/transform.hpp"><para>Includes all the transforms in the transform/ sub-directory. </para></header><header name="boost/xpressive/proto/transform/arg.hpp"><para>Contains definition of the argN transforms. </para><namespace name="boost"><namespace name="proto"><struct name="_arg_c"><template>
      <template-nontype-parameter name="I"><type>int</type></template-nontype-parameter>
    </template><inherit access="public">boost::proto::transform::arg_c&lt; I &gt;</inherit></struct><namespace name="transform"><struct name="expr"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>Expr</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="state"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>State</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>State const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state_"><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="visitor"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>Visitor</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Visitor &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor_"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-nontype-parameter name="I"><type>int</type></template-nontype-parameter>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>proto::result_of::arg_c&lt; Expr, I &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>proto::result_of::arg_c&lt; Expr, I &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="_ref"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T &amp;)</template-arg></specialization><typedef name="type"><type>boost::reference_wrapper&lt; T &gt;</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><typedef name="type"><type>boost::reference_wrapper&lt; T const  &gt;</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>boost::reference_wrapper&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::reference_wrapper&lt; T const  &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/bind.hpp"><para>Contains definition of the bind&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="bind"><template>
      <template-type-parameter name="Fun"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; <classname>Fun</classname> &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
    </template><specialization><template-arg>Return()</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type() &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Return(A0)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type(A0) &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type(A0, A1) &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type(A0, A1, A2) &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type(A0, A1, A2, A3) &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="bind"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><classname>call</classname>&lt; typename <classname>make</classname>&lt; Return &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type(A0, A1, A2, A3, A4) &gt;</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/call.hpp"><para>Contains definition of the call&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="call"><template>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">Fun</inherit><typedef name="proto_is_callable_"><type>void</type></typedef></struct><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
    </template><specialization><template-arg>Fun()</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="Arg0"/>
    </template><specialization><template-arg>Fun(Arg0)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><specialization><template-arg>Fun(Arg0</template-arg><template-arg>Arg1)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><specialization><template-arg>Fun(Arg0</template-arg><template-arg>Arg1</template-arg><template-arg>Arg2)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>boost::result_of&lt; <classname>Fun</classname>(typename <classname>when</classname>&lt; _, Arg0 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, Arg1 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, Arg2 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type)&gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>boost::result_of&lt; <classname>Fun</classname>(typename <classname>when</classname>&lt; _, A0 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A1 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A2 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A3 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type)&gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type>boost::result_of&lt; <classname>Fun</classname>(typename <classname>when</classname>&lt; _, A0 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A1 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A2 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A3 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type, typename <classname>when</classname>&lt; _, A4 &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type)&gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold.hpp"><para>Contains definition of the fold&lt;&gt; and reverse_fold&lt;&gt; transforms.</para><para>Contains definition of the fold_tree&lt;&gt; and reverse_fold_tree&lt;&gt; transforms. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="sequence"><type><classname>when</classname>&lt; _, Sequence &gt;::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse_fold"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">boost::proto::transform::fold&lt; Sequence, State0, Fun &gt;</inherit></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold_tree.hpp"><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold_tree"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse_fold_tree"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/make.hpp"><para>Contains definition of the make&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="make"><template>
      <template-type-parameter name="Fun"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
    </template><specialization><template-arg>Return()</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Return(A0)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/pass_through.hpp"><para>TODO </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="pass_through"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/when.hpp"><para>Definition of when transform. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">Fun</inherit><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Fun"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Fun *</template-arg></specialization><inherit access="public">boost::proto::transform::when&lt; Grammar, Fun &gt;</inherit></struct-specialization><struct name="otherwise"><template>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">boost::proto::transform::when&lt; _, Fun &gt;</inherit></struct><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return()</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return() &gt;, <classname>make</classname>&lt; Return() &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return(A0)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return(A0) &gt;, <classname>make</classname>&lt; Return(A0) &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return(A0</template-arg><template-arg>A1)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return(A0, A1) &gt;, <classname>make</classname>&lt; Return(A0, A1) &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return(A0, A1, A2) &gt;, <classname>make</classname>&lt; Return(A0, A1, A2) &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return(A0, A1, A2, A3) &gt;, <classname>make</classname>&lt; Return(A0, A1, A2, A3) &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Return(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>State</template-arg><template-arg>Visitor)</template-arg></specialization><typedef name="impl"><type>mpl::if_&lt; <classname>is_callable</classname>&lt; Return &gt;, <classname>call</classname>&lt; Return(A0, A1, A2, A3, A4) &gt;, <classname>make</classname>&lt; Return(A0, A1, A2, A3, A4) &gt; &gt;::type</type></typedef><typedef name="type"><type>impl::template result&lt; void(Expr, State, Visitor) &gt;::type</type></typedef></struct-specialization><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr, State, Visitor) &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter><description><para>Function call operator </para></description></method></method-group></struct-specialization></namespace></namespace></namespace></header></library-reference>
